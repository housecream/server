
uipws.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000027e  00800100  00006020  00006094  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00006020  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000822  0080037e  0000629e  00006312  2**0
                  ALLOC
  3 .stab         00000378  00000000  00000000  00006314  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      0000005f  00000000  00000000  0000668c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000160  00000000  00000000  000066eb  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 000009e5  00000000  00000000  0000684b  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   0000571b  00000000  00000000  00007230  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 0000150a  00000000  00000000  0000c94b  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000033a3  00000000  00000000  0000de55  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000680  00000000  00000000  000111f8  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00001052  00000000  00000000  00011878  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000016b5  00000000  00000000  000128ca  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000150  00000000  00000000  00013f7f  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 43 0d 	jmp	0x1a86	; 0x1a86 <__ctors_end>
       4:	0c 94 60 0d 	jmp	0x1ac0	; 0x1ac0 <__bad_interrupt>
       8:	0c 94 8f 0d 	jmp	0x1b1e	; 0x1b1e <__vector_2>
       c:	0c 94 60 0d 	jmp	0x1ac0	; 0x1ac0 <__bad_interrupt>
      10:	0c 94 60 0d 	jmp	0x1ac0	; 0x1ac0 <__bad_interrupt>
      14:	0c 94 60 0d 	jmp	0x1ac0	; 0x1ac0 <__bad_interrupt>
      18:	0c 94 60 0d 	jmp	0x1ac0	; 0x1ac0 <__bad_interrupt>
      1c:	0c 94 60 0d 	jmp	0x1ac0	; 0x1ac0 <__bad_interrupt>
      20:	0c 94 60 0d 	jmp	0x1ac0	; 0x1ac0 <__bad_interrupt>
      24:	0c 94 60 0d 	jmp	0x1ac0	; 0x1ac0 <__bad_interrupt>
      28:	0c 94 60 0d 	jmp	0x1ac0	; 0x1ac0 <__bad_interrupt>
      2c:	0c 94 60 0d 	jmp	0x1ac0	; 0x1ac0 <__bad_interrupt>
      30:	0c 94 60 0d 	jmp	0x1ac0	; 0x1ac0 <__bad_interrupt>
      34:	0c 94 60 0d 	jmp	0x1ac0	; 0x1ac0 <__bad_interrupt>
      38:	0c 94 60 0d 	jmp	0x1ac0	; 0x1ac0 <__bad_interrupt>
      3c:	0c 94 60 0d 	jmp	0x1ac0	; 0x1ac0 <__bad_interrupt>
      40:	0c 94 62 0d 	jmp	0x1ac4	; 0x1ac4 <__vector_16>
      44:	0c 94 60 0d 	jmp	0x1ac0	; 0x1ac0 <__bad_interrupt>
      48:	0c 94 60 0d 	jmp	0x1ac0	; 0x1ac0 <__bad_interrupt>
      4c:	0c 94 60 0d 	jmp	0x1ac0	; 0x1ac0 <__bad_interrupt>
      50:	0c 94 60 0d 	jmp	0x1ac0	; 0x1ac0 <__bad_interrupt>
      54:	0c 94 60 0d 	jmp	0x1ac0	; 0x1ac0 <__bad_interrupt>
      58:	0c 94 60 0d 	jmp	0x1ac0	; 0x1ac0 <__bad_interrupt>
      5c:	0c 94 60 0d 	jmp	0x1ac0	; 0x1ac0 <__bad_interrupt>
      60:	0c 94 60 0d 	jmp	0x1ac0	; 0x1ac0 <__bad_interrupt>
      64:	0c 94 60 0d 	jmp	0x1ac0	; 0x1ac0 <__bad_interrupt>
      68:	0c 94 60 0d 	jmp	0x1ac0	; 0x1ac0 <__bad_interrupt>
      6c:	0c 94 60 0d 	jmp	0x1ac0	; 0x1ac0 <__bad_interrupt>

00000070 <__c.2490>:
      70:	1b 5b 50 00                                         .[P.

00000074 <__c.2488>:
      74:	23 00                                               #.

00000076 <__c.2483>:
      76:	0d 0a 72 65 61 64 79 2e 20 0d 0a 00                 ..ready. ...

00000082 <__c.2481>:
      82:	69 6e 69 74 20 43 50 32 32 30 30 20 2e 2e 2e 00     init CP2200 ....

00000092 <__c.2479>:
      92:	20 0d 0a 00                                          ...

00000096 <__c.2477>:
      96:	20 4e 45 54 4d 41 53 4b 20 3c 78 78 78 2e 78 78      NETMASK <xxx.xx
      a6:	78 2e 78 78 78 2e 78 78 78 3e 20 20 20 2f 2f 20     x.xxx.xxx>   // 
      b6:	64 69 73 70 6c 61 79 20 2f 20 73 65 74 20 6e 65     display / set ne
      c6:	74 6d 61 73 6b 0d 0a 00                             tmask...

000000ce <__c.2475>:
      ce:	20 49 50 20 3c 78 78 78 2e 78 78 78 2e 78 78 78      IP <xxx.xxx.xxx
      de:	2e 78 78 78 3e 20 20 20 20 20 20 20 20 2f 2f 20     .xxx>        // 
      ee:	64 69 73 70 6c 61 79 20 2f 20 73 65 74 20 49 50     display / set IP
      fe:	20 61 64 64 72 65 73 73 0d 0a 00                     address...

00000109 <__c.2473>:
     109:	20 43 50 52 45 53 45 54 20 20 20 20 20 20 20 20      CPRESET        
     119:	20 20 20 20 20 20 20 20 20 20 20 20 20 2f 2f 20                  // 
     129:	72 65 69 6e 69 74 69 61 6c 69 7a 65 20 65 74 68     reinitialize eth
     139:	65 72 6e 65 74 20 63 6f 6e 74 72 6f 6c 6c 65 72     ernet controller
     149:	20 0d 0a 00                                          ...

0000014d <__c.2471>:
     14d:	43 6f 6d 6d 61 6e 64 73 3a 20 0d 0a 00              Commands: ...

0000015a <__c.2469>:
     15a:	73 65 72 69 61 6c 3a 20 31 39 32 30 30 20 62 61     serial: 19200 ba
     16a:	75 64 20 38 4e 31 20 0d 0a 00                       ud 8N1 ...

00000174 <__c.2467>:
     174:	20 2a 2a 2a 20 65 6d 61 69 6c 3a 20 73 74 65 66      *** email: stef
     184:	61 6e 40 70 65 72 7a 62 6f 72 6e 2e 6e 65 74 20     an@perzborn.net 
     194:	0d 0a 00                                            ...

00000197 <__c.2465>:
     197:	20 2a 2a 2a 20 77 65 62 3a 20 77 77 77 2e 70 65      *** web: www.pe
     1a7:	72 7a 62 6f 72 6e 2e 6e 65 74 20 0d 0a 00           rzborn.net ...

000001b5 <__c.2463>:
     1b5:	20 2a 2a 2a 20 76 65 72 73 69 6f 6e 20 31 2e 31      *** version 1.1
     1c5:	20 61 64 61 70 74 65 64 20 62 79 20 53 2e 50 65      adapted by S.Pe
     1d5:	72 7a 62 6f 72 6e 20 5b 31 37 2e 30 36 2e 32 30     rzborn [17.06.20
     1e5:	30 37 5d 20 2a 2a 2a 20 0d 0a 00                    07] *** ...

000001f0 <__c.2461>:
     1f0:	0d 0a 41 64 61 6d 20 44 75 6e 6b 65 6c 73 20 75     ..Adam Dunkels u
     200:	49 50 20 77 65 62 73 65 72 76 65 72 20 65 78 61     IP webserver exa
     210:	6d 70 6c 65 20 66 6f 72 20 43 72 75 6d 62 36 34     mple for Crumb64
     220:	34 2d 4e 45 54 0d 0a 00                             4-NET...

00000228 <__c.2434>:
     228:	64 6f 6e 65 20 0a 0d 00                             done ...

00000230 <__c.2432>:
     230:	43 50 32 32 30 30 20 72 65 73 65 74 20 2e 2e 2e     CP2200 reset ...
	...

00000241 <__c.2430>:
     241:	43 50 52 45 53 45 54 00                             CPRESET.

00000249 <__c.2428>:
     249:	4e 45 54 4d 41 53 4b 00                             NETMASK.

00000251 <__c.2426>:
     251:	49 50 00                                            IP.

00000254 <__c.2366>:
     254:	0d 0a 00                                            ...

00000257 <__c.2361>:
     257:	2e 00                                               ..

00000259 <__c.2310>:
     259:	0d 0a 00                                            ...

0000025c <__c.2305>:
     25c:	2e 00                                               ..

0000025e <__c.2292>:
     25e:	20 62 79 74 65 73 20 0d 0a 00                        bytes ...

00000268 <__c.2290>:
     268:	61 76 61 69 6c 61 62 6c 65 20 52 41 4d 20 6d 65     available RAM me
     278:	6d 6f 72 79 3a 00                                   mory:.

0000027e <__c.2200>:
     27e:	74 69 6d 65 6f 75 74 0d 0a 00                       timeout...

00000288 <__c.2195>:
     288:	74 69 6d 65 6f 75 74 0d 0a 00                       timeout...

00000292 <__c.2165>:
     292:	0a 0d 00                                            ...

00000295 <__c.2160>:
     295:	0a 0d 4d 41 43 3a 00                                ..MAC:.

0000029c <__c.2060>:
     29c:	43 50 32 32 30 30 20 62 75 66 66 65 72 20 66 75     CP2200 buffer fu
     2ac:	6c 6c 0d 0a 00                                      ll...

000002b1 <http_http>:
     2b1:	68 74 74 70 3a 2f 2f 00                             http://.

000002b9 <http_200>:
     2b9:	32 30 30 20 00                                      200 .

000002be <http_301>:
     2be:	33 30 31 20 00                                      301 .

000002c3 <http_302>:
     2c3:	33 30 32 20 00                                      302 .

000002c8 <http_get>:
     2c8:	47 45 54 20 00                                      GET .

000002cd <http_10>:
     2cd:	48 54 54 50 2f 31 2e 30 00                          HTTP/1.0.

000002d6 <http_11>:
     2d6:	48 54 54 50 2f 31 2e 31 00                          HTTP/1.1.

000002df <http_content_type>:
     2df:	63 6f 6e 74 65 6e 74 2d 74 79 70 65 3a 20 00        content-type: .

000002ee <http_texthtml>:
     2ee:	74 65 78 74 2f 68 74 6d 6c 00                       text/html.

000002f8 <http_location>:
     2f8:	6c 6f 63 61 74 69 6f 6e 3a 20 00                    location: .

00000303 <http_host>:
     303:	68 6f 73 74 3a 20 00                                host: .

0000030a <http_crnl>:
     30a:	0d 0a 00                                            ...

0000030d <http_index_html>:
     30d:	2f 69 6e 64 65 78 2e 68 74 6d 6c 00                 /index.html.

00000319 <http_404_html>:
     319:	2f 34 30 34 2e 68 74 6d 6c 00                       /404.html.

00000323 <http_referer>:
     323:	52 65 66 65 72 65 72 3a 00                          Referer:.

0000032c <http_header_200>:
     32c:	48 54 54 50 2f 31 2e 30 20 32 30 30 20 4f 4b 0d     HTTP/1.0 200 OK.
     33c:	0a 53 65 72 76 65 72 3a 20 75 49 50 2f 31 2e 30     .Server: uIP/1.0
     34c:	20 68 74 74 70 3a 2f 2f 77 77 77 2e 73 69 63 73      http://www.sics
     35c:	2e 73 65 2f 7e 61 64 61 6d 2f 75 69 70 2f 0d 0a     .se/~adam/uip/..
     36c:	43 6f 6e 6e 65 63 74 69 6f 6e 3a 20 63 6c 6f 73     Connection: clos
     37c:	65 0d 0a 00                                         e...

00000380 <http_header_404>:
     380:	48 54 54 50 2f 31 2e 30 20 34 30 34 20 4e 6f 74     HTTP/1.0 404 Not
     390:	20 66 6f 75 6e 64 0d 0a 53 65 72 76 65 72 3a 20      found..Server: 
     3a0:	75 49 50 2f 31 2e 30 20 68 74 74 70 3a 2f 2f 77     uIP/1.0 http://w
     3b0:	77 77 2e 73 69 63 73 2e 73 65 2f 7e 61 64 61 6d     ww.sics.se/~adam
     3c0:	2f 75 69 70 2f 0d 0a 43 6f 6e 6e 65 63 74 69 6f     /uip/..Connectio
     3d0:	6e 3a 20 63 6c 6f 73 65 0d 0a 00                    n: close...

000003db <http_content_type_plain>:
     3db:	43 6f 6e 74 65 6e 74 2d 74 79 70 65 3a 20 74 65     Content-type: te
     3eb:	78 74 2f 70 6c 61 69 6e 0d 0a 0d 0a 00              xt/plain.....

000003f8 <http_content_type_html>:
     3f8:	43 6f 6e 74 65 6e 74 2d 74 79 70 65 3a 20 74 65     Content-type: te
     408:	78 74 2f 68 74 6d 6c 0d 0a 0d 0a 00                 xt/html.....

00000414 <http_content_type_css>:
     414:	43 6f 6e 74 65 6e 74 2d 74 79 70 65 3a 20 74 65     Content-type: te
     424:	78 74 2f 63 73 73 0d 0a 0d 0a 00                    xt/css.....

0000042f <http_content_type_text>:
     42f:	43 6f 6e 74 65 6e 74 2d 74 79 70 65 3a 20 74 65     Content-type: te
     43f:	78 74 2f 74 65 78 74 0d 0a 0d 0a 00                 xt/text.....

0000044b <http_content_type_png>:
     44b:	43 6f 6e 74 65 6e 74 2d 74 79 70 65 3a 20 69 6d     Content-type: im
     45b:	61 67 65 2f 70 6e 67 0d 0a 0d 0a 00                 age/png.....

00000467 <http_content_type_gif>:
     467:	43 6f 6e 74 65 6e 74 2d 74 79 70 65 3a 20 69 6d     Content-type: im
     477:	61 67 65 2f 67 69 66 0d 0a 0d 0a 00                 age/gif.....

00000483 <http_content_type_jpg>:
     483:	43 6f 6e 74 65 6e 74 2d 74 79 70 65 3a 20 69 6d     Content-type: im
     493:	61 67 65 2f 6a 70 65 67 0d 0a 0d 0a 00              age/jpeg.....

000004a0 <http_content_type_binary>:
     4a0:	43 6f 6e 74 65 6e 74 2d 74 79 70 65 3a 20 61 70     Content-type: ap
     4b0:	70 6c 69 63 61 74 69 6f 6e 2f 6f 63 74 65 74 2d     plication/octet-
     4c0:	73 74 72 65 61 6d 0d 0a 0d 0a 00                    stream.....

000004cb <http_html>:
     4cb:	2e 68 74 6d 6c 00                                   .html.

000004d1 <http_shtml>:
     4d1:	2e 73 68 74 6d 6c 00                                .shtml.

000004d8 <http_htm>:
     4d8:	2e 68 74 6d 00                                      .htm.

000004dd <http_css>:
     4dd:	2e 63 73 73 00                                      .css.

000004e2 <http_png>:
     4e2:	2e 70 6e 67 00                                      .png.

000004e7 <http_gif>:
     4e7:	2e 67 69 66 00                                      .gif.

000004ec <http_jpg>:
     4ec:	2e 6a 70 67 00                                      .jpg.

000004f1 <http_text>:
     4f1:	2e 74 78 74 00                                      .txt.

000004f6 <http_txt>:
     4f6:	2e 74 78 74 00                                      .txt.

000004fb <data_processes_shtml>:
     4fb:	2f 70 72 6f 63 65 73 73 65 73 2e 73 68 74 6d 6c     /processes.shtml
     50b:	00 25 21 3a 20 2f 68 65 61 64 65 72 2e 68 74 6d     .%!: /header.htm
     51b:	6c 0a 3c 68 31 3e 53 79 73 74 65 6d 20 70 72 6f     l.<h1>System pro
     52b:	63 65 73 73 65 73 3c 2f 68 31 3e 3c 62 72 3e 3c     cesses</h1><br><
     53b:	74 61 62 6c 65 20 77 69 64 74 68 3d 22 31 30 30     table width="100
     54b:	25 22 3e 0a 3c 74 72 3e 3c 74 68 3e 49 44 3c 2f     %">.<tr><th>ID</
     55b:	74 68 3e 3c 74 68 3e 4e 61 6d 65 3c 2f 74 68 3e     th><th>Name</th>
     56b:	3c 74 68 3e 50 72 69 6f 72 69 74 79 3c 2f 74 68     <th>Priority</th
     57b:	3e 3c 74 68 3e 50 6f 6c 6c 20 68 61 6e 64 6c 65     ><th>Poll handle
     58b:	72 3c 2f 74 68 3e 3c 74 68 3e 45 76 65 6e 74 20     r</th><th>Event 
     59b:	68 61 6e 64 6c 65 72 3c 2f 74 68 3e 3c 74 68 3e     handler</th><th>
     5ab:	50 72 6f 63 73 74 61 74 65 3c 2f 74 68 3e 3c 2f     Procstate</th></
     5bb:	74 72 3e 0a 25 21 20 70 72 6f 63 65 73 73 65 73     tr>.%! processes
     5cb:	0a 25 21 3a 20 2f 66 6f 6f 74 65 72 2e 68 74 6d     .%!: /footer.htm
     5db:	6c 00                                               l.

000005dd <data_404_html>:
     5dd:	2f 34 30 34 2e 68 74 6d 6c 00 3c 68 74 6d 6c 3e     /404.html.<html>
     5ed:	0a 20 20 3c 62 6f 64 79 20 62 67 63 6f 6c 6f 72     .  <body bgcolor
     5fd:	3d 22 77 68 69 74 65 22 3e 0a 20 20 20 20 3c 63     ="white">.    <c
     60d:	65 6e 74 65 72 3e 0a 20 20 20 20 20 20 3c 68 31     enter>.      <h1
     61d:	3e 34 30 34 20 2d 20 66 69 6c 65 20 6e 6f 74 20     >404 - file not 
     62d:	66 6f 75 6e 64 3c 2f 68 31 3e 0a 20 20 20 20 20     found</h1>.     
     63d:	20 3c 68 33 3e 47 6f 20 3c 61 20 68 72 65 66 3d      <h3>Go <a href=
     64d:	22 2f 22 3e 68 65 72 65 3c 2f 61 3e 20 69 6e 73     "/">here</a> ins
     65d:	74 65 61 64 2e 3c 2f 68 33 3e 0a 20 20 20 20 3c     tead.</h3>.    <
     66d:	2f 63 65 6e 74 65 72 3e 0a 20 20 3c 2f 62 6f 64     /center>.  </bod
     67d:	79 3e 0a 3c 2f 68 74 6d 6c 3e 00                    y>.</html>.

00000688 <data_files_shtml>:
     688:	2f 66 69 6c 65 73 2e 73 68 74 6d 6c 00 25 21 3a     /files.shtml.%!:
     698:	20 2f 68 65 61 64 65 72 2e 68 74 6d 6c 0a 3c 68      /header.html.<h
     6a8:	31 3e 46 69 6c 65 20 73 74 61 74 69 73 74 69 63     1>File statistic
     6b8:	73 3c 2f 68 31 3e 0a 3c 63 65 6e 74 65 72 3e 0a     s</h1>.<center>.
     6c8:	3c 74 61 62 6c 65 20 77 69 64 74 68 3d 22 33 30     <table width="30
     6d8:	30 22 3e 0a 3c 74 72 3e 3c 74 64 3e 3c 61 20 68     0">.<tr><td><a h
     6e8:	72 65 66 3d 22 2f 69 6e 64 65 78 2e 68 74 6d 6c     ref="/index.html
     6f8:	22 3e 2f 69 6e 64 65 78 2e 68 74 6d 6c 3c 2f 61     ">/index.html</a
     708:	3e 3c 2f 74 64 3e 0a 3c 74 64 3e 25 21 20 66 69     ></td>.<td>%! fi
     718:	6c 65 2d 73 74 61 74 73 20 2f 69 6e 64 65 78 2e     le-stats /index.
     728:	68 74 6d 6c 0a 3c 2f 74 64 3e 3c 74 64 3e 3c 69     html.</td><td><i
     738:	6d 67 20 73 72 63 3d 22 2f 66 61 64 65 2e 70 6e     mg src="/fade.pn
     748:	67 22 20 68 65 69 67 68 74 3d 31 30 20 77 69 64     g" height=10 wid
     758:	74 68 3d 25 21 20 66 69 6c 65 2d 73 74 61 74 73     th=%! file-stats
     768:	20 2f 69 6e 64 65 78 2e 68 74 6d 6c 0a 3e 20 3c      /index.html.> <
     778:	2f 74 64 3e 3c 2f 74 72 3e 0a 3c 74 72 3e 3c 74     /td></tr>.<tr><t
     788:	64 3e 3c 61 20 68 72 65 66 3d 22 2f 66 69 6c 65     d><a href="/file
     798:	73 2e 73 68 74 6d 6c 22 3e 2f 66 69 6c 65 73 2e     s.shtml">/files.
     7a8:	73 68 74 6d 6c 3c 2f 61 3e 3c 2f 74 64 3e 0a 3c     shtml</a></td>.<
     7b8:	74 64 3e 25 21 20 66 69 6c 65 2d 73 74 61 74 73     td>%! file-stats
     7c8:	20 2f 66 69 6c 65 73 2e 73 68 74 6d 6c 0a 3c 2f      /files.shtml.</
     7d8:	74 64 3e 3c 74 64 3e 3c 69 6d 67 20 73 72 63 3d     td><td><img src=
     7e8:	22 2f 66 61 64 65 2e 70 6e 67 22 20 68 65 69 67     "/fade.png" heig
     7f8:	68 74 3d 31 30 20 77 69 64 74 68 3d 25 21 20 66     ht=10 width=%! f
     808:	69 6c 65 2d 73 74 61 74 73 20 2f 66 69 6c 65 73     ile-stats /files
     818:	2e 73 68 74 6d 6c 0a 3e 20 3c 2f 74 64 3e 3c 2f     .shtml.> </td></
     828:	74 72 3e 0a 3c 74 72 3e 3c 74 64 3e 3c 61 20 68     tr>.<tr><td><a h
     838:	72 65 66 3d 22 2f 74 63 70 2e 73 68 74 6d 6c 22     ref="/tcp.shtml"
     848:	3e 2f 74 63 70 2e 73 68 74 6d 6c 3c 2f 61 3e 3c     >/tcp.shtml</a><
     858:	2f 74 64 3e 0a 3c 74 64 3e 25 21 20 66 69 6c 65     /td>.<td>%! file
     868:	2d 73 74 61 74 73 20 2f 74 63 70 2e 73 68 74 6d     -stats /tcp.shtm
     878:	6c 0a 3c 2f 74 64 3e 3c 74 64 3e 3c 69 6d 67 20     l.</td><td><img 
     888:	73 72 63 3d 22 2f 66 61 64 65 2e 70 6e 67 22 20     src="/fade.png" 
     898:	68 65 69 67 68 74 3d 31 30 20 77 69 64 74 68 3d     height=10 width=
     8a8:	25 21 20 66 69 6c 65 2d 73 74 61 74 73 20 2f 74     %! file-stats /t
     8b8:	63 70 2e 73 68 74 6d 6c 0a 3e 20 3c 2f 74 64 3e     cp.shtml.> </td>
     8c8:	3c 2f 74 72 3e 0a 3c 74 72 3e 3c 74 64 3e 3c 61     </tr>.<tr><td><a
     8d8:	20 68 72 65 66 3d 22 2f 73 74 61 74 73 2e 73 68      href="/stats.sh
     8e8:	74 6d 6c 22 3e 2f 73 74 61 74 73 2e 73 68 74 6d     tml">/stats.shtm
     8f8:	6c 3c 2f 61 3e 3c 2f 74 64 3e 0a 3c 74 64 3e 25     l</a></td>.<td>%
     908:	21 20 66 69 6c 65 2d 73 74 61 74 73 20 2f 73 74     ! file-stats /st
     918:	61 74 73 2e 73 68 74 6d 6c 0a 3c 2f 74 64 3e 3c     ats.shtml.</td><
     928:	74 64 3e 3c 69 6d 67 20 73 72 63 3d 22 2f 66 61     td><img src="/fa
     938:	64 65 2e 70 6e 67 22 20 68 65 69 67 68 74 3d 31     de.png" height=1
     948:	30 20 77 69 64 74 68 3d 25 21 20 66 69 6c 65 2d     0 width=%! file-
     958:	73 74 61 74 73 20 2f 73 74 61 74 73 2e 73 68 74     stats /stats.sht
     968:	6d 6c 0a 3e 20 3c 2f 74 64 3e 3c 2f 74 72 3e 0a     ml.> </td></tr>.
     978:	3c 74 72 3e 3c 74 64 3e 3c 61 20 68 72 65 66 3d     <tr><td><a href=
     988:	22 2f 73 74 79 6c 65 2e 63 73 73 22 3e 2f 73 74     "/style.css">/st
     998:	79 6c 65 2e 63 73 73 3c 2f 61 3e 3c 2f 74 64 3e     yle.css</a></td>
     9a8:	0a 3c 74 64 3e 25 21 20 66 69 6c 65 2d 73 74 61     .<td>%! file-sta
     9b8:	74 73 20 2f 73 74 79 6c 65 2e 63 73 73 0a 3c 2f     ts /style.css.</
     9c8:	74 64 3e 3c 74 64 3e 3c 69 6d 67 20 73 72 63 3d     td><td><img src=
     9d8:	22 2f 66 61 64 65 2e 70 6e 67 22 20 68 65 69 67     "/fade.png" heig
     9e8:	68 74 3d 31 30 20 77 69 64 74 68 3d 25 21 20 66     ht=10 width=%! f
     9f8:	69 6c 65 2d 73 74 61 74 73 20 2f 73 74 79 6c 65     ile-stats /style
     a08:	2e 63 73 73 0a 3e 20 3c 2f 74 64 3e 3c 2f 74 72     .css.> </td></tr
     a18:	3e 0a 3c 74 72 3e 3c 74 64 3e 3c 61 20 68 72 65     >.<tr><td><a hre
     a28:	66 3d 22 2f 34 30 34 2e 68 74 6d 6c 22 3e 2f 34     f="/404.html">/4
     a38:	30 34 2e 68 74 6d 6c 3c 2f 61 3e 3c 2f 74 64 3e     04.html</a></td>
     a48:	0a 3c 74 64 3e 25 21 20 66 69 6c 65 2d 73 74 61     .<td>%! file-sta
     a58:	74 73 20 2f 34 30 34 2e 68 74 6d 6c 0a 3c 2f 74     ts /404.html.</t
     a68:	64 3e 3c 74 64 3e 3c 69 6d 67 20 73 72 63 3d 22     d><td><img src="
     a78:	2f 66 61 64 65 2e 70 6e 67 22 20 68 65 69 67 68     /fade.png" heigh
     a88:	74 3d 31 30 20 77 69 64 74 68 3d 25 21 20 66 69     t=10 width=%! fi
     a98:	6c 65 2d 73 74 61 74 73 20 2f 34 30 34 2e 68 74     le-stats /404.ht
     aa8:	6d 6c 0a 3e 20 3c 2f 74 64 3e 3c 2f 74 72 3e 0a     ml.> </td></tr>.
     ab8:	3c 74 72 3e 3c 74 64 3e 3c 61 20 68 72 65 66 3d     <tr><td><a href=
     ac8:	22 2f 66 61 64 65 2e 70 6e 67 22 3e 2f 66 61 64     "/fade.png">/fad
     ad8:	65 2e 70 6e 67 3c 2f 61 3e 3c 2f 74 64 3e 0a 3c     e.png</a></td>.<
     ae8:	74 64 3e 25 21 20 66 69 6c 65 2d 73 74 61 74 73     td>%! file-stats
     af8:	20 2f 66 61 64 65 2e 70 6e 67 0a 3c 2f 74 64 3e      /fade.png.</td>
     b08:	3c 74 64 3e 3c 69 6d 67 20 73 72 63 3d 22 2f 66     <td><img src="/f
     b18:	61 64 65 2e 70 6e 67 22 20 68 65 69 67 68 74 3d     ade.png" height=
     b28:	31 30 20 77 69 64 74 68 3d 25 21 20 66 69 6c 65     10 width=%! file
     b38:	2d 73 74 61 74 73 20 2f 66 61 64 65 2e 70 6e 67     -stats /fade.png
     b48:	0a 3e 20 3c 2f 74 64 3e 3c 2f 74 72 3e 0a 3c 2f     .> </td></tr>.</
     b58:	74 61 62 6c 65 3e 0a 3c 2f 63 65 6e 74 65 72 3e     table>.</center>
     b68:	0a 25 21 3a 20 2f 66 6f 6f 74 65 72 2e 68 74 6d     .%!: /footer.htm
     b78:	6c 0a 00                                            l..

00000b7b <data_footer_html>:
     b7b:	2f 66 6f 6f 74 65 72 2e 68 74 6d 6c 00 20 20 3c     /footer.html.  <
     b8b:	2f 62 6f 64 79 3e 0a 3c 2f 68 74 6d 6c 3e 00        /body>.</html>.

00000b9a <data_header_html>:
     b9a:	2f 68 65 61 64 65 72 2e 68 74 6d 6c 00 3c 21 44     /header.html.<!D
     baa:	4f 43 54 59 50 45 20 48 54 4d 4c 20 50 55 42 4c     OCTYPE HTML PUBL
     bba:	49 43 20 22 2d 2f 2f 57 33 43 2f 2f 44 54 44 20     IC "-//W3C//DTD 
     bca:	48 54 4d 4c 20 34 2e 30 31 20 54 72 61 6e 73 69     HTML 4.01 Transi
     bda:	74 69 6f 6e 61 6c 2f 2f 45 4e 22 20 22 68 74 74     tional//EN" "htt
     bea:	70 3a 2f 2f 77 77 77 2e 77 33 2e 6f 72 67 2f 54     p://www.w3.org/T
     bfa:	52 2f 68 74 6d 6c 34 2f 6c 6f 6f 73 65 2e 64 74     R/html4/loose.dt
     c0a:	64 22 3e 0a 3c 68 74 6d 6c 3e 0a 20 20 3c 68 65     d">.<html>.  <he
     c1a:	61 64 3e 0a 20 20 20 20 3c 74 69 74 6c 65 3e 57     ad>.    <title>W
     c2a:	65 6c 63 6f 6d 65 20 74 6f 20 74 68 65 20 75 49     elcome to the uI
     c3a:	50 20 77 65 62 20 73 65 72 76 65 72 21 3c 2f 74     P web server!</t
     c4a:	69 74 6c 65 3e 0a 20 20 20 20 3c 6c 69 6e 6b 20     itle>.    <link 
     c5a:	72 65 6c 3d 22 73 74 79 6c 65 73 68 65 65 74 22     rel="stylesheet"
     c6a:	20 74 79 70 65 3d 22 74 65 78 74 2f 63 73 73 22      type="text/css"
     c7a:	20 68 72 65 66 3d 22 73 74 79 6c 65 2e 63 73 73      href="style.css
     c8a:	22 3e 20 20 0a 20 20 3c 2f 68 65 61 64 3e 0a 20     ">  .  </head>. 
     c9a:	20 3c 62 6f 64 79 20 62 67 63 6f 6c 6f 72 3d 22      <body bgcolor="
     caa:	23 66 66 66 65 65 63 22 20 74 65 78 74 3d 22 62     #fffeec" text="b
     cba:	6c 61 63 6b 22 3e 0a 0a 20 20 3c 64 69 76 20 63     lack">..  <div c
     cca:	6c 61 73 73 3d 22 6d 65 6e 75 22 3e 0a 20 20 3c     lass="menu">.  <
     cda:	64 69 76 20 63 6c 61 73 73 3d 22 6d 65 6e 75 62     div class="menub
     cea:	6f 78 22 3e 3c 61 20 68 72 65 66 3d 22 2f 22 3e     ox"><a href="/">
     cfa:	46 72 6f 6e 74 20 70 61 67 65 3c 2f 61 3e 3c 2f     Front page</a></
     d0a:	64 69 76 3e 0a 20 20 3c 64 69 76 20 63 6c 61 73     div>.  <div clas
     d1a:	73 3d 22 6d 65 6e 75 62 6f 78 22 3e 3c 61 20 68     s="menubox"><a h
     d2a:	72 65 66 3d 22 66 69 6c 65 73 2e 73 68 74 6d 6c     ref="files.shtml
     d3a:	22 3e 46 69 6c 65 20 73 74 61 74 69 73 74 69 63     ">File statistic
     d4a:	73 3c 2f 61 3e 3c 2f 64 69 76 3e 0a 20 20 3c 64     s</a></div>.  <d
     d5a:	69 76 20 63 6c 61 73 73 3d 22 6d 65 6e 75 62 6f     iv class="menubo
     d6a:	78 22 3e 3c 61 20 68 72 65 66 3d 22 73 74 61 74     x"><a href="stat
     d7a:	73 2e 73 68 74 6d 6c 22 3e 4e 65 74 77 6f 72 6b     s.shtml">Network
     d8a:	20 73 74 61 74 69 73 74 69 63 73 3c 2f 61 3e 3c      statistics</a><
     d9a:	2f 64 69 76 3e 0a 20 20 3c 64 69 76 20 63 6c 61     /div>.  <div cla
     daa:	73 73 3d 22 6d 65 6e 75 62 6f 78 22 3e 3c 61 20     ss="menubox"><a 
     dba:	68 72 65 66 3d 22 74 63 70 2e 73 68 74 6d 6c 22     href="tcp.shtml"
     dca:	3e 4e 65 74 77 6f 72 6b 0a 20 20 63 6f 6e 6e 65     >Network.  conne
     dda:	63 74 69 6f 6e 73 3c 2f 61 3e 3c 2f 64 69 76 3e     ctions</a></div>
     dea:	0a 20 20 3c 62 72 3e 0a 20 20 3c 2f 64 69 76 3e     .  <br>.  </div>
     dfa:	0a 20 20 0a 20 20 3c 64 69 76 20 63 6c 61 73 73     .  .  <div class
     e0a:	3d 22 63 6f 6e 74 65 6e 74 62 6c 6f 63 6b 22 3e     ="contentblock">
     e1a:	0a 00                                               ..

00000e1c <data_index_html>:
     e1c:	2f 69 6e 64 65 78 2e 68 74 6d 6c 00 3c 21 44 4f     /index.html.<!DO
     e2c:	43 54 59 50 45 20 48 54 4d 4c 20 50 55 42 4c 49     CTYPE HTML PUBLI
     e3c:	43 20 22 2d 2f 2f 57 33 43 2f 2f 44 54 44 20 48     C "-//W3C//DTD H
     e4c:	54 4d 4c 20 34 2e 30 31 20 54 72 61 6e 73 69 74     TML 4.01 Transit
     e5c:	69 6f 6e 61 6c 2f 2f 45 4e 22 20 22 68 74 74 70     ional//EN" "http
     e6c:	3a 2f 2f 77 77 77 2e 77 33 2e 6f 72 67 2f 54 52     ://www.w3.org/TR
     e7c:	2f 68 74 6d 6c 34 2f 6c 6f 6f 73 65 2e 64 74 64     /html4/loose.dtd
     e8c:	22 3e 0a 3c 68 74 6d 6c 3e 0a 20 20 3c 68 65 61     ">.<html>.  <hea
     e9c:	64 3e 0a 20 20 20 20 3c 74 69 74 6c 65 3e 57 65     d>.    <title>We
     eac:	6c 63 6f 6d 65 20 74 6f 20 74 68 65 20 75 49 50     lcome to the uIP
     ebc:	20 77 65 62 20 73 65 72 76 65 72 21 3c 2f 74 69      web server!</ti
     ecc:	74 6c 65 3e 0a 20 20 20 20 3c 6c 69 6e 6b 20 72     tle>.    <link r
     edc:	65 6c 3d 22 73 74 79 6c 65 73 68 65 65 74 22 20     el="stylesheet" 
     eec:	74 79 70 65 3d 22 74 65 78 74 2f 63 73 73 22 20     type="text/css" 
     efc:	68 72 65 66 3d 22 73 74 79 6c 65 2e 63 73 73 22     href="style.css"
     f0c:	3e 20 20 0a 20 20 3c 2f 68 65 61 64 3e 0a 20 20     >  .  </head>.  
     f1c:	3c 62 6f 64 79 20 62 67 63 6f 6c 6f 72 3d 22 23     <body bgcolor="#
     f2c:	66 66 66 65 65 63 22 20 74 65 78 74 3d 22 62 6c     fffeec" text="bl
     f3c:	61 63 6b 22 3e 0a 0a 20 20 3c 64 69 76 20 63 6c     ack">..  <div cl
     f4c:	61 73 73 3d 22 6d 65 6e 75 22 3e 0a 20 20 3c 64     ass="menu">.  <d
     f5c:	69 76 20 63 6c 61 73 73 3d 22 6d 65 6e 75 62 6f     iv class="menubo
     f6c:	78 22 3e 3c 61 20 68 72 65 66 3d 22 2f 22 3e 46     x"><a href="/">F
     f7c:	72 6f 6e 74 20 70 61 67 65 3c 2f 61 3e 3c 2f 64     ront page</a></d
     f8c:	69 76 3e 0a 20 20 3c 64 69 76 20 63 6c 61 73 73     iv>.  <div class
     f9c:	3d 22 6d 65 6e 75 62 6f 78 22 3e 3c 61 20 68 72     ="menubox"><a hr
     fac:	65 66 3d 22 66 69 6c 65 73 2e 73 68 74 6d 6c 22     ef="files.shtml"
     fbc:	3e 46 69 6c 65 20 73 74 61 74 69 73 74 69 63 73     >File statistics
     fcc:	3c 2f 61 3e 3c 2f 64 69 76 3e 0a 20 20 3c 64 69     </a></div>.  <di
     fdc:	76 20 63 6c 61 73 73 3d 22 6d 65 6e 75 62 6f 78     v class="menubox
     fec:	22 3e 3c 61 20 68 72 65 66 3d 22 73 74 61 74 73     "><a href="stats
     ffc:	2e 73 68 74 6d 6c 22 3e 4e 65 74 77 6f 72 6b 20     .shtml">Network 
    100c:	73 74 61 74 69 73 74 69 63 73 3c 2f 61 3e 3c 2f     statistics</a></
    101c:	64 69 76 3e 0a 20 20 3c 64 69 76 20 63 6c 61 73     div>.  <div clas
    102c:	73 3d 22 6d 65 6e 75 62 6f 78 22 3e 3c 61 20 68     s="menubox"><a h
    103c:	72 65 66 3d 22 74 63 70 2e 73 68 74 6d 6c 22 3e     ref="tcp.shtml">
    104c:	4e 65 74 77 6f 72 6b 0a 20 20 63 6f 6e 6e 65 63     Network.  connec
    105c:	74 69 6f 6e 73 3c 2f 61 3e 3c 2f 64 69 76 3e 0a     tions</a></div>.
    106c:	20 20 3c 62 72 3e 0a 20 20 3c 2f 64 69 76 3e 0a       <br>.  </div>.
    107c:	0a 20 20 3c 64 69 76 20 63 6c 61 73 73 3d 22 63     .  <div class="c
    108c:	6f 6e 74 65 6e 74 62 6c 6f 63 6b 22 3e 0a 20 20     ontentblock">.  
    109c:	3c 70 3e 0a 20 20 54 68 65 73 65 20 77 65 62 20     <p>.  These web 
    10ac:	70 61 67 65 73 20 61 72 65 20 73 65 72 76 65 64     pages are served
    10bc:	20 62 79 20 61 20 73 6d 61 6c 6c 20 77 65 62 20      by a small web 
    10cc:	73 65 72 76 65 72 20 72 75 6e 6e 69 6e 67 20 6f     server running o
    10dc:	6e 20 74 6f 70 20 6f 66 0a 20 20 74 68 65 20 3c     n top of.  the <
    10ec:	61 20 68 72 65 66 3d 22 68 74 74 70 3a 2f 2f 77     a href="http://w
    10fc:	77 77 2e 73 69 63 73 2e 73 65 2f 7e 61 64 61 6d     ww.sics.se/~adam
    110c:	2f 75 69 70 2f 22 3e 75 49 50 20 65 6d 62 65 64     /uip/">uIP embed
    111c:	64 65 64 20 54 43 50 2f 49 50 0a 20 20 73 74 61     ded TCP/IP.  sta
    112c:	63 6b 3c 2f 61 3e 2e 0a 20 20 3c 2f 70 3e 0a 20     ck</a>..  </p>. 
    113c:	20 3c 70 3e 0a 20 20 43 6c 69 63 6b 20 6f 6e 20      <p>.  Click on 
    114c:	74 68 65 20 6c 69 6e 6b 73 20 61 62 6f 76 65 20     the links above 
    115c:	66 6f 72 20 77 65 62 20 73 65 72 76 65 72 20 73     for web server s
    116c:	74 61 74 69 73 74 69 63 73 2e 0a 20 20 3c 2f 70     tatistics..  </p
    117c:	3e 0a 0a 20 20 3c 2f 62 6f 64 79 3e 0a 3c 2f 68     >..  </body>.</h
    118c:	74 6d 6c 3e 0a 00                                   tml>..

00001192 <data_style_css>:
    1192:	2f 73 74 79 6c 65 2e 63 73 73 00 68 31 20 0a 7b     /style.css.h1 .{
    11a2:	0a 20 20 74 65 78 74 2d 61 6c 69 67 6e 3a 20 63     .  text-align: c
    11b2:	65 6e 74 65 72 3b 0a 20 20 66 6f 6e 74 2d 73 69     enter;.  font-si
    11c2:	7a 65 3a 31 34 70 74 3b 0a 20 20 66 6f 6e 74 2d     ze:14pt;.  font-
    11d2:	66 61 6d 69 6c 79 3a 61 72 69 61 6c 2c 68 65 6c     family:arial,hel
    11e2:	76 65 74 69 63 61 3b 0a 20 20 66 6f 6e 74 2d 77     vetica;.  font-w
    11f2:	65 69 67 68 74 3a 62 6f 6c 64 3b 0a 20 20 70 61     eight:bold;.  pa
    1202:	64 64 69 6e 67 3a 31 30 70 78 3b 20 0a 7d 0a 0a     dding:10px; .}..
    1212:	62 6f 64 79 0a 7b 0a 0a 20 20 62 61 63 6b 67 72     body.{..  backgr
    1222:	6f 75 6e 64 2d 63 6f 6c 6f 72 3a 20 23 66 66 66     ound-color: #fff
    1232:	65 65 63 3b 0a 20 20 63 6f 6c 6f 72 3a 62 6c 61     eec;.  color:bla
    1242:	63 6b 3b 0a 0a 20 20 66 6f 6e 74 2d 73 69 7a 65     ck;..  font-size
    1252:	3a 38 70 74 3b 0a 20 20 66 6f 6e 74 2d 66 61 6d     :8pt;.  font-fam
    1262:	69 6c 79 3a 61 72 69 61 6c 2c 68 65 6c 76 65 74     ily:arial,helvet
    1272:	69 63 61 3b 0a 7d 0a 0a 2e 6d 65 6e 75 0a 7b 0a     ica;.}...menu.{.
    1282:	20 20 6d 61 72 67 69 6e 3a 20 34 70 78 3b 0a 20       margin: 4px;. 
    1292:	20 77 69 64 74 68 3a 36 30 25 3b 0a 0a 20 20 70      width:60%;..  p
    12a2:	61 64 64 69 6e 67 3a 32 70 78 3b 0a 09 0a 20 20     adding:2px;...  
    12b2:	62 6f 72 64 65 72 3a 20 73 6f 6c 69 64 20 31 70     border: solid 1p
    12c2:	78 3b 0a 20 20 62 61 63 6b 67 72 6f 75 6e 64 2d     x;.  background-
    12d2:	63 6f 6c 6f 72 3a 20 23 66 66 66 63 64 32 3b 0a     color: #fffcd2;.
    12e2:	20 20 74 65 78 74 2d 61 6c 69 67 6e 3a 6c 65 66       text-align:lef
    12f2:	74 3b 0a 20 20 0a 20 20 66 6f 6e 74 2d 73 69 7a     t;.  .  font-siz
    1302:	65 3a 39 70 74 3b 0a 20 20 66 6f 6e 74 2d 66 61     e:9pt;.  font-fa
    1312:	6d 69 6c 79 3a 61 72 69 61 6c 2c 68 65 6c 76 65     mily:arial,helve
    1322:	74 69 63 61 3b 20 20 0a 7d 0a 0a 64 69 76 2e 6d     tica;  .}..div.m
    1332:	65 6e 75 62 6f 78 0a 7b 0a 20 20 77 69 64 74 68     enubox.{.  width
    1342:	3a 20 32 35 25 3b 0a 20 20 62 6f 72 64 65 72 3a     : 25%;.  border:
    1352:	20 30 3b 0a 20 20 66 6c 6f 61 74 3a 20 6c 65 66      0;.  float: lef
    1362:	74 3b 0a 74 65 78 74 2d 61 6c 69 67 6e 3a 20 63     t;.text-align: c
    1372:	65 6e 74 65 72 3b 0a 7d 0a 0a 2e 63 6f 6e 74 65     enter;.}...conte
    1382:	6e 74 62 6c 6f 63 6b 0a 7b 20 20 0a 20 20 6d 61     ntblock.{  .  ma
    1392:	72 67 69 6e 3a 20 34 70 78 3b 0a 20 20 77 69 64     rgin: 4px;.  wid
    13a2:	74 68 3a 36 30 25 3b 0a 0a 20 20 70 61 64 64 69     th:60%;..  paddi
    13b2:	6e 67 3a 32 70 78 3b 0a 0a 20 20 62 6f 72 64 65     ng:2px;..  borde
    13c2:	72 3a 20 31 70 78 20 64 6f 74 74 65 64 3b 0a 20     r: 1px dotted;. 
    13d2:	20 62 61 63 6b 67 72 6f 75 6e 64 2d 63 6f 6c 6f      background-colo
    13e2:	72 3a 20 77 68 69 74 65 3b 0a 0a 20 20 66 6f 6e     r: white;..  fon
    13f2:	74 2d 73 69 7a 65 3a 38 70 74 3b 0a 20 20 66 6f     t-size:8pt;.  fo
    1402:	6e 74 2d 66 61 6d 69 6c 79 3a 61 72 69 61 6c 2c     nt-family:arial,
    1412:	68 65 6c 76 65 74 69 63 61 3b 20 20 0a 0a 7d 0a     helvetica;  ..}.
    1422:	0a 70 2e 69 6e 74 72 6f 0a 7b 0a 20 20 6d 61 72     .p.intro.{.  mar
    1432:	67 69 6e 2d 6c 65 66 74 3a 32 30 70 78 3b 0a 20     gin-left:20px;. 
    1442:	20 6d 61 72 67 69 6e 2d 72 69 67 68 74 3a 32 30      margin-right:20
    1452:	70 78 3b 0a 0a 20 20 66 6f 6e 74 2d 73 69 7a 65     px;..  font-size
    1462:	3a 31 30 70 74 3b 0a 2f 2a 20 20 66 6f 6e 74 2d     :10pt;./*  font-
    1472:	77 65 69 67 68 74 3a 62 6f 6c 64 3b 20 2a 2f 0a     weight:bold; */.
    1482:	20 20 66 6f 6e 74 2d 66 61 6d 69 6c 79 3a 61 72       font-family:ar
    1492:	69 61 6c 2c 68 65 6c 76 65 74 69 63 61 3b 20 20     ial,helvetica;  
    14a2:	0a 7d 0a 0a 70 2e 63 6c 69 6e 6b 0a 7b 0a 20 20     .}..p.clink.{.  
    14b2:	66 6f 6e 74 2d 73 69 7a 65 3a 31 32 70 74 3b 0a     font-size:12pt;.
    14c2:	20 20 66 6f 6e 74 2d 66 61 6d 69 6c 79 3a 63 6f       font-family:co
    14d2:	75 72 69 65 72 2c 6d 6f 6e 6f 73 70 61 63 65 3b     urier,monospace;
    14e2:	20 20 0a 20 20 74 65 78 74 2d 61 6c 69 67 6e 3a       .  text-align:
    14f2:	63 65 6e 74 65 72 3b 0a 7d 0a 0a 70 2e 63 6c 69     center;.}..p.cli
    1502:	6e 6b 39 0a 7b 0a 20 20 66 6f 6e 74 2d 73 69 7a     nk9.{.  font-siz
    1512:	65 3a 39 70 74 3b 0a 20 20 66 6f 6e 74 2d 66 61     e:9pt;.  font-fa
    1522:	6d 69 6c 79 3a 63 6f 75 72 69 65 72 2c 6d 6f 6e     mily:courier,mon
    1532:	6f 73 70 61 63 65 3b 20 20 0a 20 20 74 65 78 74     ospace;  .  text
    1542:	2d 61 6c 69 67 6e 3a 63 65 6e 74 65 72 3b 0a 7d     -align:center;.}
    1552:	0a 0a 0a 70 0a 7b 0a 20 20 70 61 64 64 69 6e 67     ...p.{.  padding
    1562:	2d 6c 65 66 74 3a 31 30 70 78 3b 0a 7d 0a 0a 70     -left:10px;.}..p
    1572:	2e 72 69 67 68 74 0a 7b 0a 20 20 74 65 78 74 2d     .right.{.  text-
    1582:	61 6c 69 67 6e 3a 72 69 67 68 74 3b 20 0a 7d 0a     align:right; .}.
    1592:	0a 00                                               ..

00001594 <data_tcp_shtml>:
    1594:	2f 74 63 70 2e 73 68 74 6d 6c 00 25 21 3a 20 2f     /tcp.shtml.%!: /
    15a4:	68 65 61 64 65 72 2e 68 74 6d 6c 0a 3c 68 31 3e     header.html.<h1>
    15b4:	43 75 72 72 65 6e 74 20 63 6f 6e 6e 65 63 74 69     Current connecti
    15c4:	6f 6e 73 3c 2f 68 31 3e 3c 62 72 3e 3c 74 61 62     ons</h1><br><tab
    15d4:	6c 65 20 77 69 64 74 68 3d 22 31 30 30 25 22 3e     le width="100%">
    15e4:	0a 3c 74 72 3e 3c 74 68 3e 4c 6f 63 61 6c 3c 2f     .<tr><th>Local</
    15f4:	74 68 3e 3c 74 68 3e 52 65 6d 6f 74 65 3c 2f 74     th><th>Remote</t
    1604:	68 3e 3c 74 68 3e 53 74 61 74 65 3c 2f 74 68 3e     h><th>State</th>
    1614:	3c 74 68 3e 52 65 74 72 61 6e 73 6d 69 73 73 69     <th>Retransmissi
    1624:	6f 6e 73 3c 2f 74 68 3e 3c 74 68 3e 54 69 6d 65     ons</th><th>Time
    1634:	72 3c 2f 74 68 3e 3c 74 68 3e 46 6c 61 67 73 3c     r</th><th>Flags<
    1644:	2f 74 68 3e 3c 2f 74 72 3e 0a 25 21 20 74 63 70     /th></tr>.%! tcp
    1654:	2d 63 6f 6e 6e 65 63 74 69 6f 6e 73 0a 25 21 3a     -connections.%!:
    1664:	20 2f 66 6f 6f 74 65 72 2e 68 74 6d 6c 0a 0a 00      /footer.html...

00001674 <data_fade_png>:
    1674:	2f 66 61 64 65 2e 70 6e 67 00 89 50 4e 47 0d 0a     /fade.png..PNG..
    1684:	1a 0a 00 00 00 0d 49 48 44 52 00 00 00 04 00 00     ......IHDR......
    1694:	00 0a 08 02 00 00 00 1c 99 68 59 00 00 00 09 70     .........hY....p
    16a4:	48 59 73 00 00 0b 13 00 00 0b 13 01 00 9a 9c 18     HYs.............
    16b4:	00 00 00 07 74 49 4d 45 07 d6 06 08 14 1b 39 af     ....tIME......9.
    16c4:	5b c0 e3 00 00 00 1d 74 45 58 74 43 6f 6d 6d 65     [......tEXtComme
    16d4:	6e 74 00 43 72 65 61 74 65 64 20 77 69 74 68 20     nt.Created with 
    16e4:	54 68 65 20 47 49 4d 50 ef 64 25 6e 00 00 00 3a     The GIMP.d%n...:
    16f4:	49 44 41 54 08 d7 75 8c 31 12 00 10 10 c4 2e 37     IDAT..u.1......7
    1704:	9e 40 65 fd ff 83 f4 0a 1c 8d 54 9b c9 cc 9a 3d     .@e.......T....=
    1714:	90 73 71 67 91 d4 74 36 a9 55 01 f8 29 58 c8 bf     .sqg..t6.U..)X..
    1724:	48 c4 81 74 0b a3 0f 7c db 04 e8 40 05 df a1 f3     H..t...|...@....
    1734:	fc 73 00 00 00 00 49 45 4e 44 ae 42 60 82 00        .s....IEND.B`..

00001743 <data_stats_shtml>:
    1743:	2f 73 74 61 74 73 2e 73 68 74 6d 6c 00 25 21 3a     /stats.shtml.%!:
    1753:	20 2f 68 65 61 64 65 72 2e 68 74 6d 6c 0a 3c 68      /header.html.<h
    1763:	31 3e 4e 65 74 77 6f 72 6b 20 73 74 61 74 69 73     1>Network statis
    1773:	74 69 63 73 3c 2f 68 31 3e 0a 3c 63 65 6e 74 65     tics</h1>.<cente
    1783:	72 3e 0a 3c 74 61 62 6c 65 20 77 69 64 74 68 3d     r>.<table width=
    1793:	22 33 30 30 22 20 62 6f 72 64 65 72 3d 22 30 22     "300" border="0"
    17a3:	3e 0a 3c 74 72 3e 3c 74 64 3e 3c 70 72 65 3e 0a     >.<tr><td><pre>.
    17b3:	49 50 20 20 20 20 20 20 20 20 20 20 20 50 61 63     IP           Pac
    17c3:	6b 65 74 73 20 72 65 63 65 69 76 65 64 0a 20 20     kets received.  
    17d3:	20 20 20 20 20 20 20 20 20 20 20 50 61 63 6b 65                Packe
    17e3:	74 73 20 73 65 6e 74 0a 09 20 20 20 20 20 50 61     ts sent..     Pa
    17f3:	63 6b 65 74 73 20 64 72 6f 70 70 65 64 0a 49 50     ckets dropped.IP
    1803:	20 65 72 72 6f 72 73 20 20 20 20 49 50 20 76 65      errors    IP ve
    1813:	72 73 69 6f 6e 2f 68 65 61 64 65 72 20 6c 65 6e     rsion/header len
    1823:	67 74 68 0a 20 20 20 20 20 20 20 20 20 20 20 20     gth.            
    1833:	20 49 50 20 6c 65 6e 67 74 68 2c 20 68 69 67 68      IP length, high
    1843:	20 62 79 74 65 0a 20 20 20 20 20 20 20 20 20 20      byte.          
    1853:	20 20 20 49 50 20 6c 65 6e 67 74 68 2c 20 6c 6f        IP length, lo
    1863:	77 20 62 79 74 65 0a 20 20 20 20 20 20 20 20 20     w byte.         
    1873:	20 20 20 20 49 50 20 66 72 61 67 6d 65 6e 74 73         IP fragments
    1883:	0a 20 20 20 20 20 20 20 20 20 20 20 20 20 48 65     .             He
    1893:	61 64 65 72 20 63 68 65 63 6b 73 75 6d 0a 20 20     ader checksum.  
    18a3:	20 20 20 20 20 20 20 20 20 20 20 57 72 6f 6e 67                Wrong
    18b3:	20 70 72 6f 74 6f 63 6f 6c 0a 49 43 4d 50 09 20      protocol.ICMP. 
    18c3:	20 20 20 20 50 61 63 6b 65 74 73 20 72 65 63 65         Packets rece
    18d3:	69 76 65 64 0a 20 20 20 20 20 20 20 20 20 20 20     ived.           
    18e3:	20 20 50 61 63 6b 65 74 73 20 73 65 6e 74 0a 20       Packets sent. 
    18f3:	20 20 20 20 20 20 20 20 20 20 20 20 50 61 63 6b                 Pack
    1903:	65 74 73 20 64 72 6f 70 70 65 64 0a 20 20 20 20     ets dropped.    
    1913:	20 20 20 20 20 20 20 20 20 54 79 70 65 20 65 72              Type er
    1923:	72 6f 72 73 0a 54 43 50 20 20 20 20 20 20 20 20     rors.TCP        
    1933:	20 20 50 61 63 6b 65 74 73 20 72 65 63 65 69 76       Packets receiv
    1943:	65 64 0a 20 20 20 20 20 20 20 20 20 20 20 20 20     ed.             
    1953:	50 61 63 6b 65 74 73 20 73 65 6e 74 0a 20 20 20     Packets sent.   
    1963:	20 20 20 20 20 20 20 20 20 20 50 61 63 6b 65 74               Packet
    1973:	73 20 64 72 6f 70 70 65 64 0a 20 20 20 20 20 20     s dropped.      
    1983:	20 20 20 20 20 20 20 43 68 65 63 6b 73 75 6d 20            Checksum 
    1993:	65 72 72 6f 72 73 0a 20 20 20 20 20 20 20 20 20     errors.         
    19a3:	20 20 20 20 44 61 74 61 20 70 61 63 6b 65 74 73         Data packets
    19b3:	20 77 69 74 68 6f 75 74 20 41 43 4b 73 0a 20 20      without ACKs.  
    19c3:	20 20 20 20 20 20 20 20 20 20 20 52 65 73 65 74                Reset
    19d3:	73 0a 20 20 20 20 20 20 20 20 20 20 20 20 20 52     s.             R
    19e3:	65 74 72 61 6e 73 6d 69 73 73 69 6f 6e 73 0a 09     etransmissions..
    19f3:	20 20 20 20 20 4e 6f 20 63 6f 6e 6e 65 63 74 69          No connecti
    1a03:	6f 6e 20 61 76 61 6c 69 61 62 6c 65 0a 09 20 20     on avaliable..  
    1a13:	20 20 20 43 6f 6e 6e 65 63 74 69 6f 6e 20 61 74        Connection at
    1a23:	74 65 6d 70 74 73 20 74 6f 20 63 6c 6f 73 65 64     tempts to closed
    1a33:	20 70 6f 72 74 73 0a 3c 2f 70 72 65 3e 3c 2f 74      ports.</pre></t
    1a43:	64 3e 3c 74 64 3e 3c 70 72 65 3e 25 21 20 6e 65     d><td><pre>%! ne
    1a53:	74 2d 73 74 61 74 73 0a 3c 2f 70 72 65 3e 3c 2f     t-stats.</pre></
    1a63:	74 61 62 6c 65 3e 0a 3c 2f 63 65 6e 74 65 72 3e     table>.</center>
    1a73:	0a 25 21 3a 20 2f 66 6f 6f 74 65 72 2e 68 74 6d     .%!: /footer.htm
    1a83:	6c 0a 00                                            l..

00001a86 <__ctors_end>:
    1a86:	11 24       	eor	r1, r1
    1a88:	1f be       	out	0x3f, r1	; 63
    1a8a:	cf ef       	ldi	r28, 0xFF	; 255
    1a8c:	d0 e1       	ldi	r29, 0x10	; 16
    1a8e:	de bf       	out	0x3e, r29	; 62
    1a90:	cd bf       	out	0x3d, r28	; 61

00001a92 <__do_copy_data>:
    1a92:	13 e0       	ldi	r17, 0x03	; 3
    1a94:	a0 e0       	ldi	r26, 0x00	; 0
    1a96:	b1 e0       	ldi	r27, 0x01	; 1
    1a98:	e0 e2       	ldi	r30, 0x20	; 32
    1a9a:	f0 e6       	ldi	r31, 0x60	; 96
    1a9c:	02 c0       	rjmp	.+4      	; 0x1aa2 <.do_copy_data_start>

00001a9e <.do_copy_data_loop>:
    1a9e:	05 90       	lpm	r0, Z+
    1aa0:	0d 92       	st	X+, r0

00001aa2 <.do_copy_data_start>:
    1aa2:	ae 37       	cpi	r26, 0x7E	; 126
    1aa4:	b1 07       	cpc	r27, r17
    1aa6:	d9 f7       	brne	.-10     	; 0x1a9e <.do_copy_data_loop>

00001aa8 <__do_clear_bss>:
    1aa8:	1b e0       	ldi	r17, 0x0B	; 11
    1aaa:	ae e7       	ldi	r26, 0x7E	; 126
    1aac:	b3 e0       	ldi	r27, 0x03	; 3
    1aae:	01 c0       	rjmp	.+2      	; 0x1ab2 <.do_clear_bss_start>

00001ab0 <.do_clear_bss_loop>:
    1ab0:	1d 92       	st	X+, r1

00001ab2 <.do_clear_bss_start>:
    1ab2:	a0 3a       	cpi	r26, 0xA0	; 160
    1ab4:	b1 07       	cpc	r27, r17
    1ab6:	e1 f7       	brne	.-8      	; 0x1ab0 <.do_clear_bss_loop>
    1ab8:	0e 94 87 10 	call	0x210e	; 0x210e <main>
    1abc:	0c 94 0f 30 	jmp	0x601e	; 0x601e <_exit>

00001ac0 <__bad_interrupt>:
    1ac0:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00001ac4 <__vector_16>:
    1ac4:	1f 92       	push	r1
    1ac6:	0f 92       	push	r0
    1ac8:	0f b6       	in	r0, 0x3f	; 63
    1aca:	0f 92       	push	r0
    1acc:	11 24       	eor	r1, r1
    1ace:	8f 93       	push	r24
    1ad0:	9f 93       	push	r25
    1ad2:	80 91 7f 03 	lds	r24, 0x037F
    1ad6:	81 50       	subi	r24, 0x01	; 1
    1ad8:	80 93 7f 03 	sts	0x037F, r24
    1adc:	88 23       	and	r24, r24
    1ade:	c1 f4       	brne	.+48     	; 0x1b10 <__vector_16+0x4c>
    1ae0:	87 e9       	ldi	r24, 0x97	; 151
    1ae2:	80 93 7f 03 	sts	0x037F, r24
    1ae6:	80 91 35 04 	lds	r24, 0x0435
    1aea:	90 91 36 04 	lds	r25, 0x0436
    1aee:	01 96       	adiw	r24, 0x01	; 1
    1af0:	90 93 36 04 	sts	0x0436, r25
    1af4:	80 93 35 04 	sts	0x0435, r24
    1af8:	80 91 7e 03 	lds	r24, 0x037E
    1afc:	88 23       	and	r24, r24
    1afe:	29 f4       	brne	.+10     	; 0x1b0a <__vector_16+0x46>
    1b00:	41 98       	cbi	0x08, 1	; 8
    1b02:	81 e0       	ldi	r24, 0x01	; 1
    1b04:	80 93 7e 03 	sts	0x037E, r24
    1b08:	03 c0       	rjmp	.+6      	; 0x1b10 <__vector_16+0x4c>
    1b0a:	41 9a       	sbi	0x08, 1	; 8
    1b0c:	10 92 7e 03 	sts	0x037E, r1
    1b10:	9f 91       	pop	r25
    1b12:	8f 91       	pop	r24
    1b14:	0f 90       	pop	r0
    1b16:	0f be       	out	0x3f, r0	; 63
    1b18:	0f 90       	pop	r0
    1b1a:	1f 90       	pop	r1
    1b1c:	18 95       	reti

00001b1e <__vector_2>:
    1b1e:	1f 92       	push	r1
    1b20:	0f 92       	push	r0
    1b22:	0f b6       	in	r0, 0x3f	; 63
    1b24:	0f 92       	push	r0
    1b26:	11 24       	eor	r1, r1
    1b28:	28 98       	cbi	0x05, 0	; 5
    1b2a:	0f 90       	pop	r0
    1b2c:	0f be       	out	0x3f, r0	; 63
    1b2e:	0f 90       	pop	r0
    1b30:	1f 90       	pop	r1
    1b32:	18 95       	reti

00001b34 <InitUART>:
    1b34:	10 92 c5 00 	sts	0x00C5, r1
    1b38:	80 e4       	ldi	r24, 0x40	; 64
    1b3a:	80 93 c4 00 	sts	0x00C4, r24
    1b3e:	88 e1       	ldi	r24, 0x18	; 24
    1b40:	80 93 c1 00 	sts	0x00C1, r24
    1b44:	86 e0       	ldi	r24, 0x06	; 6
    1b46:	80 93 c2 00 	sts	0x00C2, r24
    1b4a:	10 92 c0 00 	sts	0x00C0, r1
    1b4e:	08 95       	ret

00001b50 <uart_putc_P>:
    1b50:	fc 01       	movw	r30, r24
    1b52:	80 91 c0 00 	lds	r24, 0x00C0
    1b56:	85 ff       	sbrs	r24, 5
    1b58:	fc cf       	rjmp	.-8      	; 0x1b52 <uart_putc_P+0x2>
    1b5a:	84 91       	lpm	r24, Z
    1b5c:	80 93 c6 00 	sts	0x00C6, r24
    1b60:	80 e0       	ldi	r24, 0x00	; 0
    1b62:	90 e0       	ldi	r25, 0x00	; 0
    1b64:	08 95       	ret

00001b66 <uart_putc>:
    1b66:	98 2f       	mov	r25, r24
    1b68:	80 91 c0 00 	lds	r24, 0x00C0
    1b6c:	85 ff       	sbrs	r24, 5
    1b6e:	fc cf       	rjmp	.-8      	; 0x1b68 <uart_putc+0x2>
    1b70:	90 93 c6 00 	sts	0x00C6, r25
    1b74:	80 e0       	ldi	r24, 0x00	; 0
    1b76:	90 e0       	ldi	r25, 0x00	; 0
    1b78:	08 95       	ret

00001b7a <uart_puts>:
    1b7a:	fc 01       	movw	r30, r24
    1b7c:	07 c0       	rjmp	.+14     	; 0x1b8c <uart_puts+0x12>
    1b7e:	80 91 c0 00 	lds	r24, 0x00C0
    1b82:	85 ff       	sbrs	r24, 5
    1b84:	fc cf       	rjmp	.-8      	; 0x1b7e <uart_puts+0x4>
    1b86:	90 93 c6 00 	sts	0x00C6, r25
    1b8a:	31 96       	adiw	r30, 0x01	; 1
    1b8c:	90 81       	ld	r25, Z
    1b8e:	99 23       	and	r25, r25
    1b90:	b1 f7       	brne	.-20     	; 0x1b7e <uart_puts+0x4>
    1b92:	08 95       	ret

00001b94 <uart_puts_P>:
    1b94:	cf 93       	push	r28
    1b96:	df 93       	push	r29
    1b98:	ec 01       	movw	r28, r24
    1b9a:	04 c0       	rjmp	.+8      	; 0x1ba4 <uart_puts_P+0x10>
    1b9c:	ce 01       	movw	r24, r28
    1b9e:	0e 94 a8 0d 	call	0x1b50	; 0x1b50 <uart_putc_P>
    1ba2:	21 96       	adiw	r28, 0x01	; 1
    1ba4:	fe 01       	movw	r30, r28
    1ba6:	84 91       	lpm	r24, Z
    1ba8:	88 23       	and	r24, r24
    1baa:	c1 f7       	brne	.-16     	; 0x1b9c <uart_puts_P+0x8>
    1bac:	df 91       	pop	r29
    1bae:	cf 91       	pop	r28
    1bb0:	08 95       	ret

00001bb2 <uart_getc>:
    1bb2:	80 91 c0 00 	lds	r24, 0x00C0
    1bb6:	87 ff       	sbrs	r24, 7
    1bb8:	fc cf       	rjmp	.-8      	; 0x1bb2 <uart_getc>
    1bba:	80 91 c6 00 	lds	r24, 0x00C6
    1bbe:	90 e0       	ldi	r25, 0x00	; 0
    1bc0:	08 95       	ret

00001bc2 <itohex>:
    1bc2:	dc 01       	movw	r26, r24
    1bc4:	44 30       	cpi	r20, 0x04	; 4
    1bc6:	10 f4       	brcc	.+4      	; 0x1bcc <itohex+0xa>
    1bc8:	20 e0       	ldi	r18, 0x00	; 0
    1bca:	0c c0       	rjmp	.+24     	; 0x1be4 <itohex+0x22>
    1bcc:	cb 01       	movw	r24, r22
    1bce:	89 2f       	mov	r24, r25
    1bd0:	99 27       	eor	r25, r25
    1bd2:	82 95       	swap	r24
    1bd4:	8f 70       	andi	r24, 0x0F	; 15
    1bd6:	8a 30       	cpi	r24, 0x0A	; 10
    1bd8:	10 f0       	brcs	.+4      	; 0x1bde <itohex+0x1c>
    1bda:	89 5c       	subi	r24, 0xC9	; 201
    1bdc:	01 c0       	rjmp	.+2      	; 0x1be0 <itohex+0x1e>
    1bde:	80 5d       	subi	r24, 0xD0	; 208
    1be0:	8c 93       	st	X, r24
    1be2:	21 e0       	ldi	r18, 0x01	; 1
    1be4:	43 30       	cpi	r20, 0x03	; 3
    1be6:	80 f0       	brcs	.+32     	; 0x1c08 <itohex+0x46>
    1be8:	87 2f       	mov	r24, r23
    1bea:	99 27       	eor	r25, r25
    1bec:	8f 70       	andi	r24, 0x0F	; 15
    1bee:	e2 2f       	mov	r30, r18
    1bf0:	f0 e0       	ldi	r31, 0x00	; 0
    1bf2:	8a 30       	cpi	r24, 0x0A	; 10
    1bf4:	20 f0       	brcs	.+8      	; 0x1bfe <itohex+0x3c>
    1bf6:	ea 0f       	add	r30, r26
    1bf8:	fb 1f       	adc	r31, r27
    1bfa:	89 5c       	subi	r24, 0xC9	; 201
    1bfc:	03 c0       	rjmp	.+6      	; 0x1c04 <itohex+0x42>
    1bfe:	ea 0f       	add	r30, r26
    1c00:	fb 1f       	adc	r31, r27
    1c02:	80 5d       	subi	r24, 0xD0	; 208
    1c04:	80 83       	st	Z, r24
    1c06:	2f 5f       	subi	r18, 0xFF	; 255
    1c08:	42 30       	cpi	r20, 0x02	; 2
    1c0a:	a8 f0       	brcs	.+42     	; 0x1c36 <itohex+0x74>
    1c0c:	cb 01       	movw	r24, r22
    1c0e:	80 7f       	andi	r24, 0xF0	; 240
    1c10:	90 70       	andi	r25, 0x00	; 0
    1c12:	34 e0       	ldi	r19, 0x04	; 4
    1c14:	95 95       	asr	r25
    1c16:	87 95       	ror	r24
    1c18:	3a 95       	dec	r19
    1c1a:	e1 f7       	brne	.-8      	; 0x1c14 <itohex+0x52>
    1c1c:	e2 2f       	mov	r30, r18
    1c1e:	f0 e0       	ldi	r31, 0x00	; 0
    1c20:	8a 30       	cpi	r24, 0x0A	; 10
    1c22:	20 f0       	brcs	.+8      	; 0x1c2c <itohex+0x6a>
    1c24:	ea 0f       	add	r30, r26
    1c26:	fb 1f       	adc	r31, r27
    1c28:	89 5c       	subi	r24, 0xC9	; 201
    1c2a:	03 c0       	rjmp	.+6      	; 0x1c32 <itohex+0x70>
    1c2c:	ea 0f       	add	r30, r26
    1c2e:	fb 1f       	adc	r31, r27
    1c30:	80 5d       	subi	r24, 0xD0	; 208
    1c32:	80 83       	st	Z, r24
    1c34:	2f 5f       	subi	r18, 0xFF	; 255
    1c36:	44 23       	and	r20, r20
    1c38:	71 f0       	breq	.+28     	; 0x1c56 <itohex+0x94>
    1c3a:	6f 70       	andi	r22, 0x0F	; 15
    1c3c:	e2 2f       	mov	r30, r18
    1c3e:	f0 e0       	ldi	r31, 0x00	; 0
    1c40:	6a 30       	cpi	r22, 0x0A	; 10
    1c42:	20 f0       	brcs	.+8      	; 0x1c4c <itohex+0x8a>
    1c44:	ea 0f       	add	r30, r26
    1c46:	fb 1f       	adc	r31, r27
    1c48:	69 5c       	subi	r22, 0xC9	; 201
    1c4a:	03 c0       	rjmp	.+6      	; 0x1c52 <itohex+0x90>
    1c4c:	ea 0f       	add	r30, r26
    1c4e:	fb 1f       	adc	r31, r27
    1c50:	60 5d       	subi	r22, 0xD0	; 208
    1c52:	60 83       	st	Z, r22
    1c54:	2f 5f       	subi	r18, 0xFF	; 255
    1c56:	a2 0f       	add	r26, r18
    1c58:	b1 1d       	adc	r27, r1
    1c5a:	1c 92       	st	X, r1
    1c5c:	08 95       	ret

00001c5e <clock_init>:
    1c5e:	f8 94       	cli
    1c60:	82 e0       	ldi	r24, 0x02	; 2
    1c62:	84 bd       	out	0x24, r24	; 36
    1c64:	95 e0       	ldi	r25, 0x05	; 5
    1c66:	95 bd       	out	0x25, r25	; 37
    1c68:	90 e8       	ldi	r25, 0x80	; 128
    1c6a:	97 bd       	out	0x27, r25	; 39
    1c6c:	80 93 6e 00 	sts	0x006E, r24
    1c70:	78 94       	sei
    1c72:	08 95       	ret

00001c74 <clock_time>:
    1c74:	80 91 35 04 	lds	r24, 0x0435
    1c78:	90 91 36 04 	lds	r25, 0x0436
    1c7c:	08 95       	ret

00001c7e <uip_log>:
    1c7e:	0e 94 bd 0d 	call	0x1b7a	; 0x1b7a <uart_puts>
    1c82:	08 95       	ret

00001c84 <cmd_netmask>:
    1c84:	6f 92       	push	r6
    1c86:	7f 92       	push	r7
    1c88:	8f 92       	push	r8
    1c8a:	9f 92       	push	r9
    1c8c:	bf 92       	push	r11
    1c8e:	cf 92       	push	r12
    1c90:	df 92       	push	r13
    1c92:	ef 92       	push	r14
    1c94:	ff 92       	push	r15
    1c96:	0f 93       	push	r16
    1c98:	1f 93       	push	r17
    1c9a:	cf 93       	push	r28
    1c9c:	df 93       	push	r29
    1c9e:	cd b7       	in	r28, 0x3d	; 61
    1ca0:	de b7       	in	r29, 0x3e	; 62
    1ca2:	2e 97       	sbiw	r28, 0x0e	; 14
    1ca4:	0f b6       	in	r0, 0x3f	; 63
    1ca6:	f8 94       	cli
    1ca8:	de bf       	out	0x3e, r29	; 62
    1caa:	0f be       	out	0x3f, r0	; 63
    1cac:	cd bf       	out	0x3d, r28	; 61
    1cae:	7c 01       	movw	r14, r24
    1cb0:	80 91 b4 05 	lds	r24, 0x05B4
    1cb4:	90 91 b5 05 	lds	r25, 0x05B5
    1cb8:	9a 83       	std	Y+2, r25	; 0x02
    1cba:	89 83       	std	Y+1, r24	; 0x01
    1cbc:	80 91 b6 05 	lds	r24, 0x05B6
    1cc0:	90 91 b7 05 	lds	r25, 0x05B7
    1cc4:	9c 83       	std	Y+4, r25	; 0x04
    1cc6:	8b 83       	std	Y+3, r24	; 0x03
    1cc8:	6e 01       	movw	r12, r28
    1cca:	08 94       	sec
    1ccc:	c1 1c       	adc	r12, r1
    1cce:	d1 1c       	adc	r13, r1
    1cd0:	f7 01       	movw	r30, r14
    1cd2:	80 81       	ld	r24, Z
    1cd4:	88 23       	and	r24, r24
    1cd6:	19 f0       	breq	.+6      	; 0x1cde <cmd_netmask+0x5a>
    1cd8:	97 01       	movw	r18, r14
    1cda:	bb 24       	eor	r11, r11
    1cdc:	40 c0       	rjmp	.+128    	; 0x1d5e <cmd_netmask+0xda>
    1cde:	8e 01       	movw	r16, r28
    1ce0:	0b 5f       	subi	r16, 0xFB	; 251
    1ce2:	1f 4f       	sbci	r17, 0xFF	; 255
    1ce4:	89 81       	ldd	r24, Y+1	; 0x01
    1ce6:	4a e0       	ldi	r20, 0x0A	; 10
    1ce8:	50 e0       	ldi	r21, 0x00	; 0
    1cea:	b8 01       	movw	r22, r16
    1cec:	90 e0       	ldi	r25, 0x00	; 0
    1cee:	0e 94 c1 2c 	call	0x5982	; 0x5982 <itoa>
    1cf2:	0e 94 bd 0d 	call	0x1b7a	; 0x1b7a <uart_puts>
    1cf6:	76 01       	movw	r14, r12
    1cf8:	b7 e5       	ldi	r27, 0x57	; 87
    1cfa:	8b 2e       	mov	r8, r27
    1cfc:	b2 e0       	ldi	r27, 0x02	; 2
    1cfe:	9b 2e       	mov	r9, r27
    1d00:	68 01       	movw	r12, r16
    1d02:	8e 01       	movw	r16, r28
    1d04:	0c 5f       	subi	r16, 0xFC	; 252
    1d06:	1f 4f       	sbci	r17, 0xFF	; 255
    1d08:	c4 01       	movw	r24, r8
    1d0a:	0e 94 ca 0d 	call	0x1b94	; 0x1b94 <uart_puts_P>
    1d0e:	f7 01       	movw	r30, r14
    1d10:	81 81       	ldd	r24, Z+1	; 0x01
    1d12:	4a e0       	ldi	r20, 0x0A	; 10
    1d14:	50 e0       	ldi	r21, 0x00	; 0
    1d16:	b6 01       	movw	r22, r12
    1d18:	90 e0       	ldi	r25, 0x00	; 0
    1d1a:	0e 94 c1 2c 	call	0x5982	; 0x5982 <itoa>
    1d1e:	0e 94 bd 0d 	call	0x1b7a	; 0x1b7a <uart_puts>
    1d22:	08 94       	sec
    1d24:	e1 1c       	adc	r14, r1
    1d26:	f1 1c       	adc	r15, r1
    1d28:	e0 16       	cp	r14, r16
    1d2a:	f1 06       	cpc	r15, r17
    1d2c:	69 f7       	brne	.-38     	; 0x1d08 <cmd_netmask+0x84>
    1d2e:	84 e5       	ldi	r24, 0x54	; 84
    1d30:	92 e0       	ldi	r25, 0x02	; 2
    1d32:	0e 94 ca 0d 	call	0x1b94	; 0x1b94 <uart_puts_P>
    1d36:	41 c0       	rjmp	.+130    	; 0x1dba <cmd_netmask+0x136>
    1d38:	8e 32       	cpi	r24, 0x2E	; 46
    1d3a:	71 f4       	brne	.+28     	; 0x1d58 <cmd_netmask+0xd4>
    1d3c:	f7 01       	movw	r30, r14
    1d3e:	10 82       	st	Z, r1
    1d40:	86 01       	movw	r16, r12
    1d42:	0b 0d       	add	r16, r11
    1d44:	11 1d       	adc	r17, r1
    1d46:	c9 01       	movw	r24, r18
    1d48:	0e 94 1a 2c 	call	0x5834	; 0x5834 <atoi>
    1d4c:	f8 01       	movw	r30, r16
    1d4e:	80 83       	st	Z, r24
    1d50:	b3 94       	inc	r11
    1d52:	97 01       	movw	r18, r14
    1d54:	2f 5f       	subi	r18, 0xFF	; 255
    1d56:	3f 4f       	sbci	r19, 0xFF	; 255
    1d58:	08 94       	sec
    1d5a:	e1 1c       	adc	r14, r1
    1d5c:	f1 1c       	adc	r15, r1
    1d5e:	f7 01       	movw	r30, r14
    1d60:	80 81       	ld	r24, Z
    1d62:	88 23       	and	r24, r24
    1d64:	19 f0       	breq	.+6      	; 0x1d6c <cmd_netmask+0xe8>
    1d66:	f3 e0       	ldi	r31, 0x03	; 3
    1d68:	fb 15       	cp	r31, r11
    1d6a:	30 f7       	brcc	.-52     	; 0x1d38 <cmd_netmask+0xb4>
    1d6c:	f7 01       	movw	r30, r14
    1d6e:	10 82       	st	Z, r1
    1d70:	86 01       	movw	r16, r12
    1d72:	0b 0d       	add	r16, r11
    1d74:	11 1d       	adc	r17, r1
    1d76:	c9 01       	movw	r24, r18
    1d78:	0e 94 1a 2c 	call	0x5834	; 0x5834 <atoi>
    1d7c:	f8 01       	movw	r30, r16
    1d7e:	80 83       	st	Z, r24
    1d80:	f6 01       	movw	r30, r12
    1d82:	22 81       	ldd	r18, Z+2	; 0x02
    1d84:	30 e0       	ldi	r19, 0x00	; 0
    1d86:	32 2f       	mov	r19, r18
    1d88:	22 27       	eor	r18, r18
    1d8a:	83 81       	ldd	r24, Z+3	; 0x03
    1d8c:	90 e0       	ldi	r25, 0x00	; 0
    1d8e:	28 2b       	or	r18, r24
    1d90:	39 2b       	or	r19, r25
    1d92:	63 2e       	mov	r6, r19
    1d94:	72 2e       	mov	r7, r18
    1d96:	21 81       	ldd	r18, Z+1	; 0x01
    1d98:	30 e0       	ldi	r19, 0x00	; 0
    1d9a:	80 81       	ld	r24, Z
    1d9c:	90 e0       	ldi	r25, 0x00	; 0
    1d9e:	98 2f       	mov	r25, r24
    1da0:	88 27       	eor	r24, r24
    1da2:	28 2b       	or	r18, r24
    1da4:	39 2b       	or	r19, r25
    1da6:	83 2e       	mov	r8, r19
    1da8:	92 2e       	mov	r9, r18
    1daa:	90 92 b5 05 	sts	0x05B5, r9
    1dae:	80 92 b4 05 	sts	0x05B4, r8
    1db2:	70 92 b7 05 	sts	0x05B7, r7
    1db6:	60 92 b6 05 	sts	0x05B6, r6
    1dba:	2e 96       	adiw	r28, 0x0e	; 14
    1dbc:	0f b6       	in	r0, 0x3f	; 63
    1dbe:	f8 94       	cli
    1dc0:	de bf       	out	0x3e, r29	; 62
    1dc2:	0f be       	out	0x3f, r0	; 63
    1dc4:	cd bf       	out	0x3d, r28	; 61
    1dc6:	df 91       	pop	r29
    1dc8:	cf 91       	pop	r28
    1dca:	1f 91       	pop	r17
    1dcc:	0f 91       	pop	r16
    1dce:	ff 90       	pop	r15
    1dd0:	ef 90       	pop	r14
    1dd2:	df 90       	pop	r13
    1dd4:	cf 90       	pop	r12
    1dd6:	bf 90       	pop	r11
    1dd8:	9f 90       	pop	r9
    1dda:	8f 90       	pop	r8
    1ddc:	7f 90       	pop	r7
    1dde:	6f 90       	pop	r6
    1de0:	08 95       	ret

00001de2 <cmd_ip>:
    1de2:	6f 92       	push	r6
    1de4:	7f 92       	push	r7
    1de6:	8f 92       	push	r8
    1de8:	9f 92       	push	r9
    1dea:	bf 92       	push	r11
    1dec:	cf 92       	push	r12
    1dee:	df 92       	push	r13
    1df0:	ef 92       	push	r14
    1df2:	ff 92       	push	r15
    1df4:	0f 93       	push	r16
    1df6:	1f 93       	push	r17
    1df8:	cf 93       	push	r28
    1dfa:	df 93       	push	r29
    1dfc:	cd b7       	in	r28, 0x3d	; 61
    1dfe:	de b7       	in	r29, 0x3e	; 62
    1e00:	2e 97       	sbiw	r28, 0x0e	; 14
    1e02:	0f b6       	in	r0, 0x3f	; 63
    1e04:	f8 94       	cli
    1e06:	de bf       	out	0x3e, r29	; 62
    1e08:	0f be       	out	0x3f, r0	; 63
    1e0a:	cd bf       	out	0x3d, r28	; 61
    1e0c:	7c 01       	movw	r14, r24
    1e0e:	80 91 b8 05 	lds	r24, 0x05B8
    1e12:	90 91 b9 05 	lds	r25, 0x05B9
    1e16:	9a 83       	std	Y+2, r25	; 0x02
    1e18:	89 83       	std	Y+1, r24	; 0x01
    1e1a:	80 91 ba 05 	lds	r24, 0x05BA
    1e1e:	90 91 bb 05 	lds	r25, 0x05BB
    1e22:	9c 83       	std	Y+4, r25	; 0x04
    1e24:	8b 83       	std	Y+3, r24	; 0x03
    1e26:	6e 01       	movw	r12, r28
    1e28:	08 94       	sec
    1e2a:	c1 1c       	adc	r12, r1
    1e2c:	d1 1c       	adc	r13, r1
    1e2e:	f7 01       	movw	r30, r14
    1e30:	80 81       	ld	r24, Z
    1e32:	88 23       	and	r24, r24
    1e34:	19 f0       	breq	.+6      	; 0x1e3c <cmd_ip+0x5a>
    1e36:	97 01       	movw	r18, r14
    1e38:	bb 24       	eor	r11, r11
    1e3a:	40 c0       	rjmp	.+128    	; 0x1ebc <cmd_ip+0xda>
    1e3c:	8e 01       	movw	r16, r28
    1e3e:	0b 5f       	subi	r16, 0xFB	; 251
    1e40:	1f 4f       	sbci	r17, 0xFF	; 255
    1e42:	89 81       	ldd	r24, Y+1	; 0x01
    1e44:	4a e0       	ldi	r20, 0x0A	; 10
    1e46:	50 e0       	ldi	r21, 0x00	; 0
    1e48:	b8 01       	movw	r22, r16
    1e4a:	90 e0       	ldi	r25, 0x00	; 0
    1e4c:	0e 94 c1 2c 	call	0x5982	; 0x5982 <itoa>
    1e50:	0e 94 bd 0d 	call	0x1b7a	; 0x1b7a <uart_puts>
    1e54:	76 01       	movw	r14, r12
    1e56:	8c e5       	ldi	r24, 0x5C	; 92
    1e58:	88 2e       	mov	r8, r24
    1e5a:	82 e0       	ldi	r24, 0x02	; 2
    1e5c:	98 2e       	mov	r9, r24
    1e5e:	68 01       	movw	r12, r16
    1e60:	8e 01       	movw	r16, r28
    1e62:	0c 5f       	subi	r16, 0xFC	; 252
    1e64:	1f 4f       	sbci	r17, 0xFF	; 255
    1e66:	c4 01       	movw	r24, r8
    1e68:	0e 94 ca 0d 	call	0x1b94	; 0x1b94 <uart_puts_P>
    1e6c:	f7 01       	movw	r30, r14
    1e6e:	81 81       	ldd	r24, Z+1	; 0x01
    1e70:	4a e0       	ldi	r20, 0x0A	; 10
    1e72:	50 e0       	ldi	r21, 0x00	; 0
    1e74:	b6 01       	movw	r22, r12
    1e76:	90 e0       	ldi	r25, 0x00	; 0
    1e78:	0e 94 c1 2c 	call	0x5982	; 0x5982 <itoa>
    1e7c:	0e 94 bd 0d 	call	0x1b7a	; 0x1b7a <uart_puts>
    1e80:	08 94       	sec
    1e82:	e1 1c       	adc	r14, r1
    1e84:	f1 1c       	adc	r15, r1
    1e86:	e0 16       	cp	r14, r16
    1e88:	f1 06       	cpc	r15, r17
    1e8a:	69 f7       	brne	.-38     	; 0x1e66 <cmd_ip+0x84>
    1e8c:	89 e5       	ldi	r24, 0x59	; 89
    1e8e:	92 e0       	ldi	r25, 0x02	; 2
    1e90:	0e 94 ca 0d 	call	0x1b94	; 0x1b94 <uart_puts_P>
    1e94:	41 c0       	rjmp	.+130    	; 0x1f18 <cmd_ip+0x136>
    1e96:	8e 32       	cpi	r24, 0x2E	; 46
    1e98:	71 f4       	brne	.+28     	; 0x1eb6 <cmd_ip+0xd4>
    1e9a:	f7 01       	movw	r30, r14
    1e9c:	10 82       	st	Z, r1
    1e9e:	86 01       	movw	r16, r12
    1ea0:	0b 0d       	add	r16, r11
    1ea2:	11 1d       	adc	r17, r1
    1ea4:	c9 01       	movw	r24, r18
    1ea6:	0e 94 1a 2c 	call	0x5834	; 0x5834 <atoi>
    1eaa:	f8 01       	movw	r30, r16
    1eac:	80 83       	st	Z, r24
    1eae:	b3 94       	inc	r11
    1eb0:	97 01       	movw	r18, r14
    1eb2:	2f 5f       	subi	r18, 0xFF	; 255
    1eb4:	3f 4f       	sbci	r19, 0xFF	; 255
    1eb6:	08 94       	sec
    1eb8:	e1 1c       	adc	r14, r1
    1eba:	f1 1c       	adc	r15, r1
    1ebc:	f7 01       	movw	r30, r14
    1ebe:	80 81       	ld	r24, Z
    1ec0:	88 23       	and	r24, r24
    1ec2:	19 f0       	breq	.+6      	; 0x1eca <cmd_ip+0xe8>
    1ec4:	f3 e0       	ldi	r31, 0x03	; 3
    1ec6:	fb 15       	cp	r31, r11
    1ec8:	30 f7       	brcc	.-52     	; 0x1e96 <cmd_ip+0xb4>
    1eca:	f7 01       	movw	r30, r14
    1ecc:	10 82       	st	Z, r1
    1ece:	86 01       	movw	r16, r12
    1ed0:	0b 0d       	add	r16, r11
    1ed2:	11 1d       	adc	r17, r1
    1ed4:	c9 01       	movw	r24, r18
    1ed6:	0e 94 1a 2c 	call	0x5834	; 0x5834 <atoi>
    1eda:	f8 01       	movw	r30, r16
    1edc:	80 83       	st	Z, r24
    1ede:	f6 01       	movw	r30, r12
    1ee0:	22 81       	ldd	r18, Z+2	; 0x02
    1ee2:	30 e0       	ldi	r19, 0x00	; 0
    1ee4:	32 2f       	mov	r19, r18
    1ee6:	22 27       	eor	r18, r18
    1ee8:	83 81       	ldd	r24, Z+3	; 0x03
    1eea:	90 e0       	ldi	r25, 0x00	; 0
    1eec:	28 2b       	or	r18, r24
    1eee:	39 2b       	or	r19, r25
    1ef0:	63 2e       	mov	r6, r19
    1ef2:	72 2e       	mov	r7, r18
    1ef4:	21 81       	ldd	r18, Z+1	; 0x01
    1ef6:	30 e0       	ldi	r19, 0x00	; 0
    1ef8:	80 81       	ld	r24, Z
    1efa:	90 e0       	ldi	r25, 0x00	; 0
    1efc:	98 2f       	mov	r25, r24
    1efe:	88 27       	eor	r24, r24
    1f00:	28 2b       	or	r18, r24
    1f02:	39 2b       	or	r19, r25
    1f04:	83 2e       	mov	r8, r19
    1f06:	92 2e       	mov	r9, r18
    1f08:	90 92 b9 05 	sts	0x05B9, r9
    1f0c:	80 92 b8 05 	sts	0x05B8, r8
    1f10:	70 92 bb 05 	sts	0x05BB, r7
    1f14:	60 92 ba 05 	sts	0x05BA, r6
    1f18:	2e 96       	adiw	r28, 0x0e	; 14
    1f1a:	0f b6       	in	r0, 0x3f	; 63
    1f1c:	f8 94       	cli
    1f1e:	de bf       	out	0x3e, r29	; 62
    1f20:	0f be       	out	0x3f, r0	; 63
    1f22:	cd bf       	out	0x3d, r28	; 61
    1f24:	df 91       	pop	r29
    1f26:	cf 91       	pop	r28
    1f28:	1f 91       	pop	r17
    1f2a:	0f 91       	pop	r16
    1f2c:	ff 90       	pop	r15
    1f2e:	ef 90       	pop	r14
    1f30:	df 90       	pop	r13
    1f32:	cf 90       	pop	r12
    1f34:	bf 90       	pop	r11
    1f36:	9f 90       	pop	r9
    1f38:	8f 90       	pop	r8
    1f3a:	7f 90       	pop	r7
    1f3c:	6f 90       	pop	r6
    1f3e:	08 95       	ret

00001f40 <parse>:
    1f40:	ef 92       	push	r14
    1f42:	ff 92       	push	r15
    1f44:	0f 93       	push	r16
    1f46:	1f 93       	push	r17
    1f48:	cf 93       	push	r28
    1f4a:	df 93       	push	r29
    1f4c:	cd b7       	in	r28, 0x3d	; 61
    1f4e:	de b7       	in	r29, 0x3e	; 62
    1f50:	c0 5a       	subi	r28, 0xA0	; 160
    1f52:	d0 40       	sbci	r29, 0x00	; 0
    1f54:	0f b6       	in	r0, 0x3f	; 63
    1f56:	f8 94       	cli
    1f58:	de bf       	out	0x3e, r29	; 62
    1f5a:	0f be       	out	0x3f, r0	; 63
    1f5c:	cd bf       	out	0x3d, r28	; 61
    1f5e:	ac 01       	movw	r20, r24
    1f60:	90 e0       	ldi	r25, 0x00	; 0
    1f62:	ee 24       	eor	r14, r14
    1f64:	ff 24       	eor	r15, r15
    1f66:	be 01       	movw	r22, r28
    1f68:	6f 5f       	subi	r22, 0xFF	; 255
    1f6a:	7f 4f       	sbci	r23, 0xFF	; 255
    1f6c:	01 c0       	rjmp	.+2      	; 0x1f70 <parse+0x30>
    1f6e:	9f 5f       	subi	r25, 0xFF	; 255
    1f70:	da 01       	movw	r26, r20
    1f72:	a9 0f       	add	r26, r25
    1f74:	b1 1d       	adc	r27, r1
    1f76:	2c 91       	ld	r18, X
    1f78:	82 2f       	mov	r24, r18
    1f7a:	81 50       	subi	r24, 0x01	; 1
    1f7c:	80 32       	cpi	r24, 0x20	; 32
    1f7e:	b8 f3       	brcs	.-18     	; 0x1f6e <parse+0x2e>
    1f80:	f7 01       	movw	r30, r14
    1f82:	ee 0f       	add	r30, r30
    1f84:	ff 1f       	adc	r31, r31
    1f86:	e6 0f       	add	r30, r22
    1f88:	f7 1f       	adc	r31, r23
    1f8a:	b1 83       	std	Z+1, r27	; 0x01
    1f8c:	a0 83       	st	Z, r26
    1f8e:	08 94       	sec
    1f90:	e1 1c       	adc	r14, r1
    1f92:	f1 1c       	adc	r15, r1
    1f94:	22 23       	and	r18, r18
    1f96:	11 f4       	brne	.+4      	; 0x1f9c <parse+0x5c>
    1f98:	17 c0       	rjmp	.+46     	; 0x1fc8 <parse+0x88>
    1f9a:	9f 5f       	subi	r25, 0xFF	; 255
    1f9c:	29 2f       	mov	r18, r25
    1f9e:	30 e0       	ldi	r19, 0x00	; 0
    1fa0:	fa 01       	movw	r30, r20
    1fa2:	e2 0f       	add	r30, r18
    1fa4:	f3 1f       	adc	r31, r19
    1fa6:	80 81       	ld	r24, Z
    1fa8:	81 32       	cpi	r24, 0x21	; 33
    1faa:	18 f4       	brcc	.+6      	; 0x1fb2 <parse+0x72>
    1fac:	88 23       	and	r24, r24
    1fae:	39 f4       	brne	.+14     	; 0x1fbe <parse+0x7e>
    1fb0:	0b c0       	rjmp	.+22     	; 0x1fc8 <parse+0x88>
    1fb2:	da 01       	movw	r26, r20
    1fb4:	8c 91       	ld	r24, X
    1fb6:	28 0f       	add	r18, r24
    1fb8:	31 1d       	adc	r19, r1
    1fba:	23 2b       	or	r18, r19
    1fbc:	71 f7       	brne	.-36     	; 0x1f9a <parse+0x5a>
    1fbe:	10 82       	st	Z, r1
    1fc0:	ba e0       	ldi	r27, 0x0A	; 10
    1fc2:	eb 16       	cp	r14, r27
    1fc4:	f1 04       	cpc	r15, r1
    1fc6:	9c f2       	brlt	.-90     	; 0x1f6e <parse+0x2e>
    1fc8:	09 81       	ldd	r16, Y+1	; 0x01
    1fca:	1a 81       	ldd	r17, Y+2	; 0x02
    1fcc:	c8 01       	movw	r24, r16
    1fce:	0e 94 b7 2c 	call	0x596e	; 0x596e <strupr>
    1fd2:	61 e5       	ldi	r22, 0x51	; 81
    1fd4:	72 e0       	ldi	r23, 0x02	; 2
    1fd6:	c8 01       	movw	r24, r16
    1fd8:	0e 94 4c 2c 	call	0x5898	; 0x5898 <strcmp_P>
    1fdc:	89 2b       	or	r24, r25
    1fde:	99 f4       	brne	.+38     	; 0x2006 <parse+0xc6>
    1fe0:	f8 01       	movw	r30, r16
    1fe2:	01 90       	ld	r0, Z+
    1fe4:	00 20       	and	r0, r0
    1fe6:	e9 f7       	brne	.-6      	; 0x1fe2 <parse+0xa2>
    1fe8:	33 97       	sbiw	r30, 0x03	; 3
    1fea:	e0 17       	cp	r30, r16
    1fec:	f1 07       	cpc	r31, r17
    1fee:	59 f4       	brne	.+22     	; 0x2006 <parse+0xc6>
    1ff0:	82 e0       	ldi	r24, 0x02	; 2
    1ff2:	e8 16       	cp	r14, r24
    1ff4:	f1 04       	cpc	r15, r1
    1ff6:	1c f0       	brlt	.+6      	; 0x1ffe <parse+0xbe>
    1ff8:	8b 81       	ldd	r24, Y+3	; 0x03
    1ffa:	9c 81       	ldd	r25, Y+4	; 0x04
    1ffc:	02 c0       	rjmp	.+4      	; 0x2002 <parse+0xc2>
    1ffe:	80 e0       	ldi	r24, 0x00	; 0
    2000:	91 e0       	ldi	r25, 0x01	; 1
    2002:	0e 94 f1 0e 	call	0x1de2	; 0x1de2 <cmd_ip>
    2006:	69 e4       	ldi	r22, 0x49	; 73
    2008:	72 e0       	ldi	r23, 0x02	; 2
    200a:	c8 01       	movw	r24, r16
    200c:	0e 94 4c 2c 	call	0x5898	; 0x5898 <strcmp_P>
    2010:	89 2b       	or	r24, r25
    2012:	99 f4       	brne	.+38     	; 0x203a <parse+0xfa>
    2014:	f8 01       	movw	r30, r16
    2016:	01 90       	ld	r0, Z+
    2018:	00 20       	and	r0, r0
    201a:	e9 f7       	brne	.-6      	; 0x2016 <parse+0xd6>
    201c:	38 97       	sbiw	r30, 0x08	; 8
    201e:	e0 17       	cp	r30, r16
    2020:	f1 07       	cpc	r31, r17
    2022:	59 f4       	brne	.+22     	; 0x203a <parse+0xfa>
    2024:	a2 e0       	ldi	r26, 0x02	; 2
    2026:	ea 16       	cp	r14, r26
    2028:	f1 04       	cpc	r15, r1
    202a:	1c f0       	brlt	.+6      	; 0x2032 <parse+0xf2>
    202c:	8b 81       	ldd	r24, Y+3	; 0x03
    202e:	9c 81       	ldd	r25, Y+4	; 0x04
    2030:	02 c0       	rjmp	.+4      	; 0x2036 <parse+0xf6>
    2032:	80 e0       	ldi	r24, 0x00	; 0
    2034:	91 e0       	ldi	r25, 0x01	; 1
    2036:	0e 94 42 0e 	call	0x1c84	; 0x1c84 <cmd_netmask>
    203a:	61 e4       	ldi	r22, 0x41	; 65
    203c:	72 e0       	ldi	r23, 0x02	; 2
    203e:	c8 01       	movw	r24, r16
    2040:	0e 94 4c 2c 	call	0x5898	; 0x5898 <strcmp_P>
    2044:	89 2b       	or	r24, r25
    2046:	91 f4       	brne	.+36     	; 0x206c <parse+0x12c>
    2048:	f8 01       	movw	r30, r16
    204a:	01 90       	ld	r0, Z+
    204c:	00 20       	and	r0, r0
    204e:	e9 f7       	brne	.-6      	; 0x204a <parse+0x10a>
    2050:	38 97       	sbiw	r30, 0x08	; 8
    2052:	e0 17       	cp	r30, r16
    2054:	f1 07       	cpc	r31, r17
    2056:	51 f4       	brne	.+20     	; 0x206c <parse+0x12c>
    2058:	80 e3       	ldi	r24, 0x30	; 48
    205a:	92 e0       	ldi	r25, 0x02	; 2
    205c:	0e 94 ca 0d 	call	0x1b94	; 0x1b94 <uart_puts_P>
    2060:	0e 94 3e 14 	call	0x287c	; 0x287c <network_device_init>
    2064:	88 e2       	ldi	r24, 0x28	; 40
    2066:	92 e0       	ldi	r25, 0x02	; 2
    2068:	0e 94 ca 0d 	call	0x1b94	; 0x1b94 <uart_puts_P>
    206c:	c0 56       	subi	r28, 0x60	; 96
    206e:	df 4f       	sbci	r29, 0xFF	; 255
    2070:	0f b6       	in	r0, 0x3f	; 63
    2072:	f8 94       	cli
    2074:	de bf       	out	0x3e, r29	; 62
    2076:	0f be       	out	0x3f, r0	; 63
    2078:	cd bf       	out	0x3d, r28	; 61
    207a:	df 91       	pop	r29
    207c:	cf 91       	pop	r28
    207e:	1f 91       	pop	r17
    2080:	0f 91       	pop	r16
    2082:	ff 90       	pop	r15
    2084:	ef 90       	pop	r14
    2086:	08 95       	ret

00002088 <AvailRAM>:
    2088:	ef 92       	push	r14
    208a:	ff 92       	push	r15
    208c:	0f 93       	push	r16
    208e:	1f 93       	push	r17
    2090:	cf 93       	push	r28
    2092:	df 93       	push	r29
    2094:	cd b7       	in	r28, 0x3d	; 61
    2096:	de b7       	in	r29, 0x3e	; 62
    2098:	2a 97       	sbiw	r28, 0x0a	; 10
    209a:	0f b6       	in	r0, 0x3f	; 63
    209c:	f8 94       	cli
    209e:	de bf       	out	0x3e, r29	; 62
    20a0:	0f be       	out	0x3f, r0	; 63
    20a2:	cd bf       	out	0x3d, r28	; 61
    20a4:	40 ea       	ldi	r20, 0xA0	; 160
    20a6:	e4 2e       	mov	r14, r20
    20a8:	4f e0       	ldi	r20, 0x0F	; 15
    20aa:	f4 2e       	mov	r15, r20
    20ac:	c7 01       	movw	r24, r14
    20ae:	0e 94 1c 2b 	call	0x5638	; 0x5638 <malloc>
    20b2:	00 97       	sbiw	r24, 0x00	; 0
    20b4:	41 f4       	brne	.+16     	; 0x20c6 <AvailRAM+0x3e>
    20b6:	86 ef       	ldi	r24, 0xF6	; 246
    20b8:	9f ef       	ldi	r25, 0xFF	; 255
    20ba:	e8 0e       	add	r14, r24
    20bc:	f9 1e       	adc	r15, r25
    20be:	e1 14       	cp	r14, r1
    20c0:	f1 04       	cpc	r15, r1
    20c2:	19 f0       	breq	.+6      	; 0x20ca <AvailRAM+0x42>
    20c4:	f3 cf       	rjmp	.-26     	; 0x20ac <AvailRAM+0x24>
    20c6:	0e 94 c4 2b 	call	0x5788	; 0x5788 <free>
    20ca:	88 e6       	ldi	r24, 0x68	; 104
    20cc:	92 e0       	ldi	r25, 0x02	; 2
    20ce:	0e 94 ca 0d 	call	0x1b94	; 0x1b94 <uart_puts_P>
    20d2:	4a e0       	ldi	r20, 0x0A	; 10
    20d4:	50 e0       	ldi	r21, 0x00	; 0
    20d6:	8e 01       	movw	r16, r28
    20d8:	0f 5f       	subi	r16, 0xFF	; 255
    20da:	1f 4f       	sbci	r17, 0xFF	; 255
    20dc:	b8 01       	movw	r22, r16
    20de:	c7 01       	movw	r24, r14
    20e0:	0e 94 c1 2c 	call	0x5982	; 0x5982 <itoa>
    20e4:	c8 01       	movw	r24, r16
    20e6:	0e 94 bd 0d 	call	0x1b7a	; 0x1b7a <uart_puts>
    20ea:	8e e5       	ldi	r24, 0x5E	; 94
    20ec:	92 e0       	ldi	r25, 0x02	; 2
    20ee:	0e 94 ca 0d 	call	0x1b94	; 0x1b94 <uart_puts_P>
    20f2:	c7 01       	movw	r24, r14
    20f4:	2a 96       	adiw	r28, 0x0a	; 10
    20f6:	0f b6       	in	r0, 0x3f	; 63
    20f8:	f8 94       	cli
    20fa:	de bf       	out	0x3e, r29	; 62
    20fc:	0f be       	out	0x3f, r0	; 63
    20fe:	cd bf       	out	0x3d, r28	; 61
    2100:	df 91       	pop	r29
    2102:	cf 91       	pop	r28
    2104:	1f 91       	pop	r17
    2106:	0f 91       	pop	r16
    2108:	ff 90       	pop	r15
    210a:	ef 90       	pop	r14
    210c:	08 95       	ret

0000210e <main>:
    210e:	2f 92       	push	r2
    2110:	3f 92       	push	r3
    2112:	4f 92       	push	r4
    2114:	5f 92       	push	r5
    2116:	6f 92       	push	r6
    2118:	7f 92       	push	r7
    211a:	8f 92       	push	r8
    211c:	9f 92       	push	r9
    211e:	af 92       	push	r10
    2120:	bf 92       	push	r11
    2122:	cf 92       	push	r12
    2124:	df 92       	push	r13
    2126:	ef 92       	push	r14
    2128:	ff 92       	push	r15
    212a:	0f 93       	push	r16
    212c:	1f 93       	push	r17
    212e:	cf 93       	push	r28
    2130:	df 93       	push	r29
    2132:	cd b7       	in	r28, 0x3d	; 61
    2134:	de b7       	in	r29, 0x3e	; 62
    2136:	c8 55       	subi	r28, 0x58	; 88
    2138:	d0 40       	sbci	r29, 0x00	; 0
    213a:	0f b6       	in	r0, 0x3f	; 63
    213c:	f8 94       	cli
    213e:	de bf       	out	0x3e, r29	; 62
    2140:	0f be       	out	0x3f, r0	; 63
    2142:	cd bf       	out	0x3d, r28	; 61
    2144:	11 b8       	out	0x01, r1	; 1
    2146:	8f ef       	ldi	r24, 0xFF	; 255
    2148:	84 b9       	out	0x04, r24	; 4
    214a:	87 b9       	out	0x07, r24	; 7
    214c:	12 b8       	out	0x02, r1	; 2
    214e:	15 b8       	out	0x05, r1	; 5
    2150:	87 ef       	ldi	r24, 0xF7	; 247
    2152:	88 b9       	out	0x08, r24	; 8
    2154:	45 9a       	sbi	0x08, 5	; 8
    2156:	44 9a       	sbi	0x08, 4	; 8
    2158:	43 98       	cbi	0x08, 3	; 8
    215a:	46 98       	cbi	0x08, 6	; 8
    215c:	47 9a       	sbi	0x08, 7	; 8
    215e:	0e 94 9a 0d 	call	0x1b34	; 0x1b34 <InitUART>
    2162:	80 ef       	ldi	r24, 0xF0	; 240
    2164:	91 e0       	ldi	r25, 0x01	; 1
    2166:	0e 94 ca 0d 	call	0x1b94	; 0x1b94 <uart_puts_P>
    216a:	85 eb       	ldi	r24, 0xB5	; 181
    216c:	91 e0       	ldi	r25, 0x01	; 1
    216e:	0e 94 ca 0d 	call	0x1b94	; 0x1b94 <uart_puts_P>
    2172:	87 e9       	ldi	r24, 0x97	; 151
    2174:	91 e0       	ldi	r25, 0x01	; 1
    2176:	0e 94 ca 0d 	call	0x1b94	; 0x1b94 <uart_puts_P>
    217a:	84 e7       	ldi	r24, 0x74	; 116
    217c:	91 e0       	ldi	r25, 0x01	; 1
    217e:	0e 94 ca 0d 	call	0x1b94	; 0x1b94 <uart_puts_P>
    2182:	8a e5       	ldi	r24, 0x5A	; 90
    2184:	91 e0       	ldi	r25, 0x01	; 1
    2186:	0e 94 ca 0d 	call	0x1b94	; 0x1b94 <uart_puts_P>
    218a:	8d e4       	ldi	r24, 0x4D	; 77
    218c:	91 e0       	ldi	r25, 0x01	; 1
    218e:	0e 94 ca 0d 	call	0x1b94	; 0x1b94 <uart_puts_P>
    2192:	89 e0       	ldi	r24, 0x09	; 9
    2194:	91 e0       	ldi	r25, 0x01	; 1
    2196:	0e 94 ca 0d 	call	0x1b94	; 0x1b94 <uart_puts_P>
    219a:	8e ec       	ldi	r24, 0xCE	; 206
    219c:	90 e0       	ldi	r25, 0x00	; 0
    219e:	0e 94 ca 0d 	call	0x1b94	; 0x1b94 <uart_puts_P>
    21a2:	86 e9       	ldi	r24, 0x96	; 150
    21a4:	90 e0       	ldi	r25, 0x00	; 0
    21a6:	0e 94 ca 0d 	call	0x1b94	; 0x1b94 <uart_puts_P>
    21aa:	82 e9       	ldi	r24, 0x92	; 146
    21ac:	90 e0       	ldi	r25, 0x00	; 0
    21ae:	0e 94 ca 0d 	call	0x1b94	; 0x1b94 <uart_puts_P>
    21b2:	24 ef       	ldi	r18, 0xF4	; 244
    21b4:	31 e0       	ldi	r19, 0x01	; 1
    21b6:	84 ef       	ldi	r24, 0xF4	; 244
    21b8:	91 e0       	ldi	r25, 0x01	; 1
    21ba:	01 97       	sbiw	r24, 0x01	; 1
    21bc:	f1 f7       	brne	.-4      	; 0x21ba <main+0xac>
    21be:	21 50       	subi	r18, 0x01	; 1
    21c0:	30 40       	sbci	r19, 0x00	; 0
    21c2:	c9 f7       	brne	.-14     	; 0x21b6 <main+0xa8>
    21c4:	0e 94 44 10 	call	0x2088	; 0x2088 <AvailRAM>
    21c8:	24 ef       	ldi	r18, 0xF4	; 244
    21ca:	31 e0       	ldi	r19, 0x01	; 1
    21cc:	84 ef       	ldi	r24, 0xF4	; 244
    21ce:	91 e0       	ldi	r25, 0x01	; 1
    21d0:	01 97       	sbiw	r24, 0x01	; 1
    21d2:	f1 f7       	brne	.-4      	; 0x21d0 <main+0xc2>
    21d4:	21 50       	subi	r18, 0x01	; 1
    21d6:	30 40       	sbci	r19, 0x00	; 0
    21d8:	c9 f7       	brne	.-14     	; 0x21cc <main+0xbe>
    21da:	f8 94       	cli
    21dc:	88 e0       	ldi	r24, 0x08	; 8
    21de:	80 93 69 00 	sts	0x0069, r24
    21e2:	82 e0       	ldi	r24, 0x02	; 2
    21e4:	8d bb       	out	0x1d, r24	; 29
    21e6:	78 94       	sei
    21e8:	82 e8       	ldi	r24, 0x82	; 130
    21ea:	90 e0       	ldi	r25, 0x00	; 0
    21ec:	0e 94 ca 0d 	call	0x1b94	; 0x1b94 <uart_puts_P>
    21f0:	00 e5       	ldi	r16, 0x50	; 80
    21f2:	13 ec       	ldi	r17, 0xC3	; 195
    21f4:	c8 01       	movw	r24, r16
    21f6:	01 97       	sbiw	r24, 0x01	; 1
    21f8:	f1 f7       	brne	.-4      	; 0x21f6 <main+0xe8>
    21fa:	0e 94 3e 14 	call	0x287c	; 0x287c <network_device_init>
    21fe:	0e 94 2f 0e 	call	0x1c5e	; 0x1c5e <clock_init>
    2202:	64 ef       	ldi	r22, 0xF4	; 244
    2204:	71 e0       	ldi	r23, 0x01	; 1
    2206:	6e 01       	movw	r12, r28
    2208:	08 94       	sec
    220a:	c1 1c       	adc	r12, r1
    220c:	d1 1c       	adc	r13, r1
    220e:	c6 01       	movw	r24, r12
    2210:	0e 94 ba 23 	call	0x4774	; 0x4774 <timer_set>
    2214:	a5 e0       	ldi	r26, 0x05	; 5
    2216:	ea 2e       	mov	r14, r26
    2218:	f1 2c       	mov	r15, r1
    221a:	ec 0e       	add	r14, r28
    221c:	fd 1e       	adc	r15, r29
    221e:	60 e1       	ldi	r22, 0x10	; 16
    2220:	77 e2       	ldi	r23, 0x27	; 39
    2222:	c7 01       	movw	r24, r14
    2224:	0e 94 ba 23 	call	0x4774	; 0x4774 <timer_set>
    2228:	86 e7       	ldi	r24, 0x76	; 118
    222a:	90 e0       	ldi	r25, 0x00	; 0
    222c:	0e 94 ca 0d 	call	0x1b94	; 0x1b94 <uart_puts_P>
    2230:	c8 01       	movw	r24, r16
    2232:	01 97       	sbiw	r24, 0x01	; 1
    2234:	f1 f7       	brne	.-4      	; 0x2232 <main+0x124>
    2236:	0e 94 c4 20 	call	0x4188	; 0x4188 <uip_arp_init>
    223a:	0e 94 68 15 	call	0x2ad0	; 0x2ad0 <uip_init>
    223e:	0e 94 6f 24 	call	0x48de	; 0x48de <httpd_init>
    2242:	aa 24       	eor	r10, r10
    2244:	bb 24       	eor	r11, r11
    2246:	46 01       	movw	r8, r12
    2248:	67 01       	movw	r12, r14
    224a:	f4 e4       	ldi	r31, 0x44	; 68
    224c:	2f 2e       	mov	r2, r31
    224e:	f4 e0       	ldi	r31, 0x04	; 4
    2250:	3f 2e       	mov	r3, r31
    2252:	e9 e0       	ldi	r30, 0x09	; 9
    2254:	ee 2e       	mov	r14, r30
    2256:	f1 2c       	mov	r15, r1
    2258:	ec 0e       	add	r14, r28
    225a:	fd 1e       	adc	r15, r29
    225c:	74 e7       	ldi	r23, 0x74	; 116
    225e:	47 2e       	mov	r4, r23
    2260:	70 e0       	ldi	r23, 0x00	; 0
    2262:	57 2e       	mov	r5, r23
    2264:	60 e7       	ldi	r22, 0x70	; 112
    2266:	66 2e       	mov	r6, r22
    2268:	60 e0       	ldi	r22, 0x00	; 0
    226a:	76 2e       	mov	r7, r22
    226c:	0e 94 00 14 	call	0x2800	; 0x2800 <network_device_read>
    2270:	90 93 38 04 	sts	0x0438, r25
    2274:	80 93 37 04 	sts	0x0437, r24
    2278:	89 2b       	or	r24, r25
    227a:	81 f1       	breq	.+96     	; 0x22dc <main+0x1ce>
    227c:	00 91 c8 05 	lds	r16, 0x05C8
    2280:	10 91 c9 05 	lds	r17, 0x05C9
    2284:	80 e0       	ldi	r24, 0x00	; 0
    2286:	98 e0       	ldi	r25, 0x08	; 8
    2288:	0e 94 ef 15 	call	0x2bde	; 0x2bde <htons>
    228c:	08 17       	cp	r16, r24
    228e:	19 07       	cpc	r17, r25
    2290:	79 f4       	brne	.+30     	; 0x22b0 <main+0x1a2>
    2292:	0e 94 5c 1f 	call	0x3eb8	; 0x3eb8 <uip_arp_ipin>
    2296:	81 e0       	ldi	r24, 0x01	; 1
    2298:	0e 94 17 16 	call	0x2c2e	; 0x2c2e <uip_process>
    229c:	80 91 37 04 	lds	r24, 0x0437
    22a0:	90 91 38 04 	lds	r25, 0x0438
    22a4:	89 2b       	or	r24, r25
    22a6:	09 f4       	brne	.+2      	; 0x22aa <main+0x19c>
    22a8:	46 c0       	rjmp	.+140    	; 0x2336 <main+0x228>
    22aa:	0e 94 92 1f 	call	0x3f24	; 0x3f24 <uip_arp_out>
    22ae:	13 c0       	rjmp	.+38     	; 0x22d6 <main+0x1c8>
    22b0:	00 91 c8 05 	lds	r16, 0x05C8
    22b4:	10 91 c9 05 	lds	r17, 0x05C9
    22b8:	86 e0       	ldi	r24, 0x06	; 6
    22ba:	98 e0       	ldi	r25, 0x08	; 8
    22bc:	0e 94 ef 15 	call	0x2bde	; 0x2bde <htons>
    22c0:	08 17       	cp	r16, r24
    22c2:	19 07       	cpc	r17, r25
    22c4:	c1 f5       	brne	.+112    	; 0x2336 <main+0x228>
    22c6:	0e 94 b1 1e 	call	0x3d62	; 0x3d62 <uip_arp_arpin>
    22ca:	80 91 37 04 	lds	r24, 0x0437
    22ce:	90 91 38 04 	lds	r25, 0x0438
    22d2:	89 2b       	or	r24, r25
    22d4:	81 f1       	breq	.+96     	; 0x2336 <main+0x228>
    22d6:	0e 94 a8 12 	call	0x2550	; 0x2550 <network_device_send>
    22da:	2d c0       	rjmp	.+90     	; 0x2336 <main+0x228>
    22dc:	c4 01       	movw	r24, r8
    22de:	0e 94 98 23 	call	0x4730	; 0x4730 <timer_expired>
    22e2:	89 2b       	or	r24, r25
    22e4:	41 f1       	breq	.+80     	; 0x2336 <main+0x228>
    22e6:	c4 01       	movw	r24, r8
    22e8:	0e 94 8e 23 	call	0x471c	; 0x471c <timer_reset>
    22ec:	81 01       	movw	r16, r2
    22ee:	10 93 43 04 	sts	0x0443, r17
    22f2:	00 93 42 04 	sts	0x0442, r16
    22f6:	82 e0       	ldi	r24, 0x02	; 2
    22f8:	0e 94 17 16 	call	0x2c2e	; 0x2c2e <uip_process>
    22fc:	80 91 37 04 	lds	r24, 0x0437
    2300:	90 91 38 04 	lds	r25, 0x0438
    2304:	89 2b       	or	r24, r25
    2306:	21 f0       	breq	.+8      	; 0x2310 <main+0x202>
    2308:	0e 94 92 1f 	call	0x3f24	; 0x3f24 <uip_arp_out>
    230c:	0e 94 a8 12 	call	0x2550	; 0x2550 <network_device_send>
    2310:	02 56       	subi	r16, 0x62	; 98
    2312:	1f 4f       	sbci	r17, 0xFF	; 255
    2314:	95 e0       	ldi	r25, 0x05	; 5
    2316:	00 38       	cpi	r16, 0x80	; 128
    2318:	19 07       	cpc	r17, r25
    231a:	49 f7       	brne	.-46     	; 0x22ee <main+0x1e0>
    231c:	c6 01       	movw	r24, r12
    231e:	0e 94 98 23 	call	0x4730	; 0x4730 <timer_expired>
    2322:	89 2b       	or	r24, r25
    2324:	29 f0       	breq	.+10     	; 0x2330 <main+0x222>
    2326:	c6 01       	movw	r24, r12
    2328:	0e 94 8e 23 	call	0x471c	; 0x471c <timer_reset>
    232c:	0e 94 97 20 	call	0x412e	; 0x412e <uip_arp_timer>
    2330:	52 e0       	ldi	r21, 0x02	; 2
    2332:	a5 2e       	mov	r10, r21
    2334:	b1 2c       	mov	r11, r1
    2336:	80 91 c0 00 	lds	r24, 0x00C0
    233a:	87 ff       	sbrs	r24, 7
    233c:	97 cf       	rjmp	.-210    	; 0x226c <main+0x15e>
    233e:	10 91 c6 00 	lds	r17, 0x00C6
    2342:	80 91 c0 00 	lds	r24, 0x00C0
    2346:	85 ff       	sbrs	r24, 5
    2348:	fc cf       	rjmp	.-8      	; 0x2342 <main+0x234>
    234a:	10 93 c6 00 	sts	0x00C6, r17
    234e:	1d 30       	cpi	r17, 0x0D	; 13
    2350:	a1 f4       	brne	.+40     	; 0x237a <main+0x26c>
    2352:	80 91 c0 00 	lds	r24, 0x00C0
    2356:	85 ff       	sbrs	r24, 5
    2358:	fc cf       	rjmp	.-8      	; 0x2352 <main+0x244>
    235a:	8a e0       	ldi	r24, 0x0A	; 10
    235c:	80 93 c6 00 	sts	0x00C6, r24
    2360:	ae 0c       	add	r10, r14
    2362:	bf 1c       	adc	r11, r15
    2364:	f5 01       	movw	r30, r10
    2366:	10 82       	st	Z, r1
    2368:	c7 01       	movw	r24, r14
    236a:	0e 94 a0 0f 	call	0x1f40	; 0x1f40 <parse>
    236e:	c2 01       	movw	r24, r4
    2370:	0e 94 ca 0d 	call	0x1b94	; 0x1b94 <uart_puts_P>
    2374:	aa 24       	eor	r10, r10
    2376:	bb 24       	eor	r11, r11
    2378:	12 c0       	rjmp	.+36     	; 0x239e <main+0x290>
    237a:	18 30       	cpi	r17, 0x08	; 8
    237c:	59 f4       	brne	.+22     	; 0x2394 <main+0x286>
    237e:	1a 14       	cp	r1, r10
    2380:	1b 04       	cpc	r1, r11
    2382:	0c f0       	brlt	.+2      	; 0x2386 <main+0x278>
    2384:	73 cf       	rjmp	.-282    	; 0x226c <main+0x15e>
    2386:	08 94       	sec
    2388:	a1 08       	sbc	r10, r1
    238a:	b1 08       	sbc	r11, r1
    238c:	c3 01       	movw	r24, r6
    238e:	0e 94 ca 0d 	call	0x1b94	; 0x1b94 <uart_puts_P>
    2392:	6c cf       	rjmp	.-296    	; 0x226c <main+0x15e>
    2394:	fe e4       	ldi	r31, 0x4E	; 78
    2396:	af 16       	cp	r10, r31
    2398:	b1 04       	cpc	r11, r1
    239a:	0c f0       	brlt	.+2      	; 0x239e <main+0x290>
    239c:	67 cf       	rjmp	.-306    	; 0x226c <main+0x15e>
    239e:	f7 01       	movw	r30, r14
    23a0:	ea 0d       	add	r30, r10
    23a2:	fb 1d       	adc	r31, r11
    23a4:	10 83       	st	Z, r17
    23a6:	08 94       	sec
    23a8:	a1 1c       	adc	r10, r1
    23aa:	b1 1c       	adc	r11, r1
    23ac:	5f cf       	rjmp	.-322    	; 0x226c <main+0x15e>

000023ae <write_CP2200>:
    23ae:	43 9a       	sbi	0x08, 3	; 8
    23b0:	2f ef       	ldi	r18, 0xFF	; 255
    23b2:	21 b9       	out	0x01, r18	; 1
    23b4:	82 b9       	out	0x02, r24	; 2
    23b6:	43 98       	cbi	0x08, 3	; 8
    23b8:	44 98       	cbi	0x08, 4	; 8
    23ba:	62 b9       	out	0x02, r22	; 2
    23bc:	44 9a       	sbi	0x08, 4	; 8
    23be:	62 b9       	out	0x02, r22	; 2
    23c0:	11 b8       	out	0x01, r1	; 1
    23c2:	08 95       	ret

000023c4 <CP2200_WriteRXBuffer>:
    23c4:	ff 92       	push	r15
    23c6:	0f 93       	push	r16
    23c8:	1f 93       	push	r17
    23ca:	8c 01       	movw	r16, r24
    23cc:	f6 2e       	mov	r15, r22
    23ce:	68 2f       	mov	r22, r24
    23d0:	89 e0       	ldi	r24, 0x09	; 9
    23d2:	90 e0       	ldi	r25, 0x00	; 0
    23d4:	0e 94 d7 11 	call	0x23ae	; 0x23ae <write_CP2200>
    23d8:	01 2f       	mov	r16, r17
    23da:	11 27       	eor	r17, r17
    23dc:	60 2f       	mov	r22, r16
    23de:	88 e0       	ldi	r24, 0x08	; 8
    23e0:	90 e0       	ldi	r25, 0x00	; 0
    23e2:	0e 94 d7 11 	call	0x23ae	; 0x23ae <write_CP2200>
    23e6:	6f 2d       	mov	r22, r15
    23e8:	82 e0       	ldi	r24, 0x02	; 2
    23ea:	90 e0       	ldi	r25, 0x00	; 0
    23ec:	0e 94 d7 11 	call	0x23ae	; 0x23ae <write_CP2200>
    23f0:	1f 91       	pop	r17
    23f2:	0f 91       	pop	r16
    23f4:	ff 90       	pop	r15
    23f6:	08 95       	ret

000023f8 <CP2200_WriteTXBuffer>:
    23f8:	ff 92       	push	r15
    23fa:	0f 93       	push	r16
    23fc:	1f 93       	push	r17
    23fe:	8c 01       	movw	r16, r24
    2400:	f6 2e       	mov	r15, r22
    2402:	68 2f       	mov	r22, r24
    2404:	89 e0       	ldi	r24, 0x09	; 9
    2406:	90 e0       	ldi	r25, 0x00	; 0
    2408:	0e 94 d7 11 	call	0x23ae	; 0x23ae <write_CP2200>
    240c:	01 2f       	mov	r16, r17
    240e:	11 27       	eor	r17, r17
    2410:	60 2f       	mov	r22, r16
    2412:	88 e0       	ldi	r24, 0x08	; 8
    2414:	90 e0       	ldi	r25, 0x00	; 0
    2416:	0e 94 d7 11 	call	0x23ae	; 0x23ae <write_CP2200>
    241a:	6f 2d       	mov	r22, r15
    241c:	84 e0       	ldi	r24, 0x04	; 4
    241e:	90 e0       	ldi	r25, 0x00	; 0
    2420:	0e 94 d7 11 	call	0x23ae	; 0x23ae <write_CP2200>
    2424:	1f 91       	pop	r17
    2426:	0f 91       	pop	r16
    2428:	ff 90       	pop	r15
    242a:	08 95       	ret

0000242c <read_CP2200>:
    242c:	43 9a       	sbi	0x08, 3	; 8
    242e:	2f ef       	ldi	r18, 0xFF	; 255
    2430:	21 b9       	out	0x01, r18	; 1
    2432:	82 b9       	out	0x02, r24	; 2
    2434:	43 98       	cbi	0x08, 3	; 8
    2436:	11 b8       	out	0x01, r1	; 1
    2438:	45 98       	cbi	0x08, 5	; 8
    243a:	80 b1       	in	r24, 0x00	; 0
    243c:	80 b1       	in	r24, 0x00	; 0
    243e:	80 b1       	in	r24, 0x00	; 0
    2440:	80 b1       	in	r24, 0x00	; 0
    2442:	80 b1       	in	r24, 0x00	; 0
    2444:	45 9a       	sbi	0x08, 5	; 8
    2446:	90 e0       	ldi	r25, 0x00	; 0
    2448:	08 95       	ret

0000244a <CP2200_WritePacket>:
    244a:	0f 93       	push	r16
    244c:	1f 93       	push	r17
    244e:	cf 93       	push	r28
    2450:	df 93       	push	r29
    2452:	84 e5       	ldi	r24, 0x54	; 84
    2454:	90 e0       	ldi	r25, 0x00	; 0
    2456:	0e 94 16 12 	call	0x242c	; 0x242c <read_CP2200>
    245a:	88 23       	and	r24, r24
    245c:	d1 f7       	brne	.-12     	; 0x2452 <CP2200_WritePacket+0x8>
    245e:	60 e0       	ldi	r22, 0x00	; 0
    2460:	89 e5       	ldi	r24, 0x59	; 89
    2462:	90 e0       	ldi	r25, 0x00	; 0
    2464:	0e 94 d7 11 	call	0x23ae	; 0x23ae <write_CP2200>
    2468:	60 e0       	ldi	r22, 0x00	; 0
    246a:	8a e5       	ldi	r24, 0x5A	; 90
    246c:	90 e0       	ldi	r25, 0x00	; 0
    246e:	0e 94 d7 11 	call	0x23ae	; 0x23ae <write_CP2200>
    2472:	80 e0       	ldi	r24, 0x00	; 0
    2474:	90 e0       	ldi	r25, 0x00	; 0
    2476:	ec 01       	movw	r28, r24
    2478:	21 96       	adiw	r28, 0x01	; 1
    247a:	fc 01       	movw	r30, r24
    247c:	e4 54       	subi	r30, 0x44	; 68
    247e:	fa 4f       	sbci	r31, 0xFA	; 250
    2480:	60 81       	ld	r22, Z
    2482:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <CP2200_WriteTXBuffer>
    2486:	ce 30       	cpi	r28, 0x0E	; 14
    2488:	d1 05       	cpc	r29, r1
    248a:	11 f0       	breq	.+4      	; 0x2490 <CP2200_WritePacket+0x46>
    248c:	ce 01       	movw	r24, r28
    248e:	f3 cf       	rjmp	.-26     	; 0x2476 <CP2200_WritePacket+0x2c>
    2490:	80 91 37 04 	lds	r24, 0x0437
    2494:	90 91 38 04 	lds	r25, 0x0438
    2498:	c7 97       	sbiw	r24, 0x37	; 55
    249a:	60 f0       	brcs	.+24     	; 0x24b4 <CP2200_WritePacket+0x6a>
    249c:	14 c0       	rjmp	.+40     	; 0x24c6 <CP2200_WritePacket+0x7c>
    249e:	8e 01       	movw	r16, r28
    24a0:	0f 5f       	subi	r16, 0xFF	; 255
    24a2:	1f 4f       	sbci	r17, 0xFF	; 255
    24a4:	fe 01       	movw	r30, r28
    24a6:	e4 54       	subi	r30, 0x44	; 68
    24a8:	fa 4f       	sbci	r31, 0xFA	; 250
    24aa:	60 81       	ld	r22, Z
    24ac:	ce 01       	movw	r24, r28
    24ae:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <CP2200_WriteTXBuffer>
    24b2:	e8 01       	movw	r28, r16
    24b4:	80 91 37 04 	lds	r24, 0x0437
    24b8:	90 91 38 04 	lds	r25, 0x0438
    24bc:	c8 17       	cp	r28, r24
    24be:	d9 07       	cpc	r29, r25
    24c0:	70 f3       	brcs	.-36     	; 0x249e <CP2200_WritePacket+0x54>
    24c2:	27 c0       	rjmp	.+78     	; 0x2512 <CP2200_WritePacket+0xc8>
    24c4:	e8 01       	movw	r28, r16
    24c6:	8e 01       	movw	r16, r28
    24c8:	0f 5f       	subi	r16, 0xFF	; 255
    24ca:	1f 4f       	sbci	r17, 0xFF	; 255
    24cc:	fe 01       	movw	r30, r28
    24ce:	e4 54       	subi	r30, 0x44	; 68
    24d0:	fa 4f       	sbci	r31, 0xFA	; 250
    24d2:	60 81       	ld	r22, Z
    24d4:	ce 01       	movw	r24, r28
    24d6:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <CP2200_WriteTXBuffer>
    24da:	06 33       	cpi	r16, 0x36	; 54
    24dc:	11 05       	cpc	r17, r1
    24de:	91 f7       	brne	.-28     	; 0x24c4 <CP2200_WritePacket+0x7a>
    24e0:	00 e0       	ldi	r16, 0x00	; 0
    24e2:	10 e0       	ldi	r17, 0x00	; 0
    24e4:	0c c0       	rjmp	.+24     	; 0x24fe <CP2200_WritePacket+0xb4>
    24e6:	e0 91 40 04 	lds	r30, 0x0440
    24ea:	f0 91 41 04 	lds	r31, 0x0441
    24ee:	e0 0f       	add	r30, r16
    24f0:	f1 1f       	adc	r31, r17
    24f2:	60 81       	ld	r22, Z
    24f4:	ce 01       	movw	r24, r28
    24f6:	0e 94 fc 11 	call	0x23f8	; 0x23f8 <CP2200_WriteTXBuffer>
    24fa:	0f 5f       	subi	r16, 0xFF	; 255
    24fc:	1f 4f       	sbci	r17, 0xFF	; 255
    24fe:	e8 01       	movw	r28, r16
    2500:	e6 96       	adiw	r28, 0x36	; 54
    2502:	80 91 37 04 	lds	r24, 0x0437
    2506:	90 91 38 04 	lds	r25, 0x0438
    250a:	c6 97       	sbiw	r24, 0x36	; 54
    250c:	08 17       	cp	r16, r24
    250e:	19 07       	cpc	r17, r25
    2510:	50 f3       	brcs	.-44     	; 0x24e6 <CP2200_WritePacket+0x9c>
    2512:	6d 2f       	mov	r22, r29
    2514:	77 27       	eor	r23, r23
    2516:	87 e5       	ldi	r24, 0x57	; 87
    2518:	90 e0       	ldi	r25, 0x00	; 0
    251a:	0e 94 d7 11 	call	0x23ae	; 0x23ae <write_CP2200>
    251e:	6c 2f       	mov	r22, r28
    2520:	88 e5       	ldi	r24, 0x58	; 88
    2522:	90 e0       	ldi	r25, 0x00	; 0
    2524:	0e 94 d7 11 	call	0x23ae	; 0x23ae <write_CP2200>
    2528:	60 e0       	ldi	r22, 0x00	; 0
    252a:	89 e5       	ldi	r24, 0x59	; 89
    252c:	90 e0       	ldi	r25, 0x00	; 0
    252e:	0e 94 d7 11 	call	0x23ae	; 0x23ae <write_CP2200>
    2532:	60 e0       	ldi	r22, 0x00	; 0
    2534:	8a e5       	ldi	r24, 0x5A	; 90
    2536:	90 e0       	ldi	r25, 0x00	; 0
    2538:	0e 94 d7 11 	call	0x23ae	; 0x23ae <write_CP2200>
    253c:	61 e0       	ldi	r22, 0x01	; 1
    253e:	83 e5       	ldi	r24, 0x53	; 83
    2540:	90 e0       	ldi	r25, 0x00	; 0
    2542:	0e 94 d7 11 	call	0x23ae	; 0x23ae <write_CP2200>
    2546:	df 91       	pop	r29
    2548:	cf 91       	pop	r28
    254a:	1f 91       	pop	r17
    254c:	0f 91       	pop	r16
    254e:	08 95       	ret

00002550 <network_device_send>:
    2550:	0e 94 25 12 	call	0x244a	; 0x244a <CP2200_WritePacket>
    2554:	08 95       	ret

00002556 <CP2200_ReadPacket>:
    2556:	0f 93       	push	r16
    2558:	1f 93       	push	r17
    255a:	cf 93       	push	r28
    255c:	df 93       	push	r29
    255e:	8f e1       	ldi	r24, 0x1F	; 31
    2560:	90 e0       	ldi	r25, 0x00	; 0
    2562:	0e 94 16 12 	call	0x242c	; 0x242c <read_CP2200>
    2566:	90 e0       	ldi	r25, 0x00	; 0
    2568:	d8 2f       	mov	r29, r24
    256a:	cc 27       	eor	r28, r28
    256c:	80 e2       	ldi	r24, 0x20	; 32
    256e:	90 e0       	ldi	r25, 0x00	; 0
    2570:	0e 94 16 12 	call	0x242c	; 0x242c <read_CP2200>
    2574:	90 e0       	ldi	r25, 0x00	; 0
    2576:	c8 2b       	or	r28, r24
    2578:	d9 2b       	or	r29, r25
    257a:	00 e0       	ldi	r16, 0x00	; 0
    257c:	10 e0       	ldi	r17, 0x00	; 0
    257e:	0a c0       	rjmp	.+20     	; 0x2594 <CP2200_ReadPacket+0x3e>
    2580:	81 e0       	ldi	r24, 0x01	; 1
    2582:	90 e0       	ldi	r25, 0x00	; 0
    2584:	0e 94 16 12 	call	0x242c	; 0x242c <read_CP2200>
    2588:	f8 01       	movw	r30, r16
    258a:	e4 54       	subi	r30, 0x44	; 68
    258c:	fa 4f       	sbci	r31, 0xFA	; 250
    258e:	80 83       	st	Z, r24
    2590:	0f 5f       	subi	r16, 0xFF	; 255
    2592:	1f 4f       	sbci	r17, 0xFF	; 255
    2594:	0c 17       	cp	r16, r28
    2596:	1d 07       	cpc	r17, r29
    2598:	99 f7       	brne	.-26     	; 0x2580 <CP2200_ReadPacket+0x2a>
    259a:	ce 01       	movw	r24, r28
    259c:	df 91       	pop	r29
    259e:	cf 91       	pop	r28
    25a0:	1f 91       	pop	r17
    25a2:	0f 91       	pop	r16
    25a4:	08 95       	ret

000025a6 <CP2200_ReadRXBuffer>:
    25a6:	0f 93       	push	r16
    25a8:	1f 93       	push	r17
    25aa:	8c 01       	movw	r16, r24
    25ac:	68 2f       	mov	r22, r24
    25ae:	89 e0       	ldi	r24, 0x09	; 9
    25b0:	90 e0       	ldi	r25, 0x00	; 0
    25b2:	0e 94 d7 11 	call	0x23ae	; 0x23ae <write_CP2200>
    25b6:	01 2f       	mov	r16, r17
    25b8:	11 27       	eor	r17, r17
    25ba:	60 2f       	mov	r22, r16
    25bc:	88 e0       	ldi	r24, 0x08	; 8
    25be:	90 e0       	ldi	r25, 0x00	; 0
    25c0:	0e 94 d7 11 	call	0x23ae	; 0x23ae <write_CP2200>
    25c4:	82 e0       	ldi	r24, 0x02	; 2
    25c6:	90 e0       	ldi	r25, 0x00	; 0
    25c8:	0e 94 16 12 	call	0x242c	; 0x242c <read_CP2200>
    25cc:	90 e0       	ldi	r25, 0x00	; 0
    25ce:	1f 91       	pop	r17
    25d0:	0f 91       	pop	r16
    25d2:	08 95       	ret

000025d4 <CP2200_ReadTXBuffer>:
    25d4:	0f 93       	push	r16
    25d6:	1f 93       	push	r17
    25d8:	8c 01       	movw	r16, r24
    25da:	68 2f       	mov	r22, r24
    25dc:	89 e0       	ldi	r24, 0x09	; 9
    25de:	90 e0       	ldi	r25, 0x00	; 0
    25e0:	0e 94 d7 11 	call	0x23ae	; 0x23ae <write_CP2200>
    25e4:	01 2f       	mov	r16, r17
    25e6:	11 27       	eor	r17, r17
    25e8:	60 2f       	mov	r22, r16
    25ea:	88 e0       	ldi	r24, 0x08	; 8
    25ec:	90 e0       	ldi	r25, 0x00	; 0
    25ee:	0e 94 d7 11 	call	0x23ae	; 0x23ae <write_CP2200>
    25f2:	84 e0       	ldi	r24, 0x04	; 4
    25f4:	90 e0       	ldi	r25, 0x00	; 0
    25f6:	0e 94 16 12 	call	0x242c	; 0x242c <read_CP2200>
    25fa:	90 e0       	ldi	r25, 0x00	; 0
    25fc:	1f 91       	pop	r17
    25fe:	0f 91       	pop	r16
    2600:	08 95       	ret

00002602 <cpWriteMac>:
    2602:	0f 93       	push	r16
    2604:	1f 93       	push	r17
    2606:	8b 01       	movw	r16, r22
    2608:	68 2f       	mov	r22, r24
    260a:	8a e0       	ldi	r24, 0x0A	; 10
    260c:	90 e0       	ldi	r25, 0x00	; 0
    260e:	0e 94 d7 11 	call	0x23ae	; 0x23ae <write_CP2200>
    2612:	61 2f       	mov	r22, r17
    2614:	77 27       	eor	r23, r23
    2616:	67 fd       	sbrc	r22, 7
    2618:	7a 95       	dec	r23
    261a:	8b e0       	ldi	r24, 0x0B	; 11
    261c:	90 e0       	ldi	r25, 0x00	; 0
    261e:	0e 94 d7 11 	call	0x23ae	; 0x23ae <write_CP2200>
    2622:	60 2f       	mov	r22, r16
    2624:	8c e0       	ldi	r24, 0x0C	; 12
    2626:	90 e0       	ldi	r25, 0x00	; 0
    2628:	0e 94 d7 11 	call	0x23ae	; 0x23ae <write_CP2200>
    262c:	61 e0       	ldi	r22, 0x01	; 1
    262e:	8d e0       	ldi	r24, 0x0D	; 13
    2630:	90 e0       	ldi	r25, 0x00	; 0
    2632:	0e 94 d7 11 	call	0x23ae	; 0x23ae <write_CP2200>
    2636:	1f 91       	pop	r17
    2638:	0f 91       	pop	r16
    263a:	08 95       	ret

0000263c <Init_CP2000>:
    263c:	0f 93       	push	r16
    263e:	1f 93       	push	r17
    2640:	cf 93       	push	r28
    2642:	df 93       	push	r29
    2644:	83 e6       	ldi	r24, 0x63	; 99
    2646:	90 e0       	ldi	r25, 0x00	; 0
    2648:	0e 94 16 12 	call	0x242c	; 0x242c <read_CP2200>
    264c:	64 e0       	ldi	r22, 0x04	; 4
    264e:	85 e7       	ldi	r24, 0x75	; 117
    2650:	90 e0       	ldi	r25, 0x00	; 0
    2652:	0e 94 d7 11 	call	0x23ae	; 0x23ae <write_CP2200>
    2656:	83 e6       	ldi	r24, 0x63	; 99
    2658:	90 e0       	ldi	r25, 0x00	; 0
    265a:	0e 94 16 12 	call	0x242c	; 0x242c <read_CP2200>
    265e:	85 ff       	sbrs	r24, 5
    2660:	fa cf       	rjmp	.-12     	; 0x2656 <Init_CP2000+0x1a>
    2662:	6e ef       	ldi	r22, 0xFE	; 254
    2664:	89 e7       	ldi	r24, 0x79	; 121
    2666:	90 e0       	ldi	r25, 0x00	; 0
    2668:	0e 94 d7 11 	call	0x23ae	; 0x23ae <write_CP2200>
    266c:	60 e0       	ldi	r22, 0x00	; 0
    266e:	88 e7       	ldi	r24, 0x78	; 120
    2670:	90 e0       	ldi	r25, 0x00	; 0
    2672:	0e 94 d7 11 	call	0x23ae	; 0x23ae <write_CP2200>
    2676:	08 e8       	ldi	r16, 0x88	; 136
    2678:	13 e1       	ldi	r17, 0x13	; 19
    267a:	c8 01       	movw	r24, r16
    267c:	01 97       	sbiw	r24, 0x01	; 1
    267e:	f1 f7       	brne	.-4      	; 0x267c <Init_CP2000+0x40>
    2680:	8f e7       	ldi	r24, 0x7F	; 127
    2682:	90 e0       	ldi	r25, 0x00	; 0
    2684:	0e 94 16 12 	call	0x242c	; 0x242c <read_CP2200>
    2688:	60 e8       	ldi	r22, 0x80	; 128
    268a:	88 e7       	ldi	r24, 0x78	; 120
    268c:	90 e0       	ldi	r25, 0x00	; 0
    268e:	0e 94 d7 11 	call	0x23ae	; 0x23ae <write_CP2200>
    2692:	c8 01       	movw	r24, r16
    2694:	01 97       	sbiw	r24, 0x01	; 1
    2696:	f1 f7       	brne	.-4      	; 0x2694 <Init_CP2000+0x58>
    2698:	60 ee       	ldi	r22, 0xE0	; 224
    269a:	88 e7       	ldi	r24, 0x78	; 120
    269c:	90 e0       	ldi	r25, 0x00	; 0
    269e:	0e 94 d7 11 	call	0x23ae	; 0x23ae <write_CP2200>
    26a2:	2e ee       	ldi	r18, 0xEE	; 238
    26a4:	32 e0       	ldi	r19, 0x02	; 2
    26a6:	84 ef       	ldi	r24, 0xF4	; 244
    26a8:	91 e0       	ldi	r25, 0x01	; 1
    26aa:	01 97       	sbiw	r24, 0x01	; 1
    26ac:	f1 f7       	brne	.-4      	; 0x26aa <Init_CP2000+0x6e>
    26ae:	21 50       	subi	r18, 0x01	; 1
    26b0:	30 40       	sbci	r19, 0x00	; 0
    26b2:	c9 f7       	brne	.-14     	; 0x26a6 <Init_CP2000+0x6a>
    26b4:	c8 eb       	ldi	r28, 0xB8	; 184
    26b6:	db e0       	ldi	r29, 0x0B	; 11
    26b8:	05 c0       	rjmp	.+10     	; 0x26c4 <Init_CP2000+0x88>
    26ba:	88 e8       	ldi	r24, 0x88	; 136
    26bc:	93 e1       	ldi	r25, 0x13	; 19
    26be:	01 97       	sbiw	r24, 0x01	; 1
    26c0:	f1 f7       	brne	.-4      	; 0x26be <Init_CP2000+0x82>
    26c2:	21 97       	sbiw	r28, 0x01	; 1
    26c4:	8f e7       	ldi	r24, 0x7F	; 127
    26c6:	90 e0       	ldi	r25, 0x00	; 0
    26c8:	0e 94 16 12 	call	0x242c	; 0x242c <read_CP2200>
    26cc:	80 fd       	sbrc	r24, 0
    26ce:	03 c0       	rjmp	.+6      	; 0x26d6 <Init_CP2000+0x9a>
    26d0:	20 97       	sbiw	r28, 0x00	; 0
    26d2:	99 f7       	brne	.-26     	; 0x26ba <Init_CP2000+0x7e>
    26d4:	02 c0       	rjmp	.+4      	; 0x26da <Init_CP2000+0x9e>
    26d6:	cd 2b       	or	r28, r29
    26d8:	21 f4       	brne	.+8      	; 0x26e2 <Init_CP2000+0xa6>
    26da:	88 e8       	ldi	r24, 0x88	; 136
    26dc:	92 e0       	ldi	r25, 0x02	; 2
    26de:	0e 94 ca 0d 	call	0x1b94	; 0x1b94 <uart_puts_P>
    26e2:	c8 eb       	ldi	r28, 0xB8	; 184
    26e4:	db e0       	ldi	r29, 0x0B	; 11
    26e6:	05 c0       	rjmp	.+10     	; 0x26f2 <Init_CP2000+0xb6>
    26e8:	88 e8       	ldi	r24, 0x88	; 136
    26ea:	93 e1       	ldi	r25, 0x13	; 19
    26ec:	01 97       	sbiw	r24, 0x01	; 1
    26ee:	f1 f7       	brne	.-4      	; 0x26ec <Init_CP2000+0xb0>
    26f0:	21 97       	sbiw	r28, 0x01	; 1
    26f2:	88 e7       	ldi	r24, 0x78	; 120
    26f4:	90 e0       	ldi	r25, 0x00	; 0
    26f6:	0e 94 16 12 	call	0x242c	; 0x242c <read_CP2200>
    26fa:	80 fd       	sbrc	r24, 0
    26fc:	03 c0       	rjmp	.+6      	; 0x2704 <Init_CP2000+0xc8>
    26fe:	20 97       	sbiw	r28, 0x00	; 0
    2700:	99 f7       	brne	.-26     	; 0x26e8 <Init_CP2000+0xac>
    2702:	02 c0       	rjmp	.+4      	; 0x2708 <Init_CP2000+0xcc>
    2704:	cd 2b       	or	r28, r29
    2706:	21 f4       	brne	.+8      	; 0x2710 <Init_CP2000+0xd4>
    2708:	8e e7       	ldi	r24, 0x7E	; 126
    270a:	92 e0       	ldi	r25, 0x02	; 2
    270c:	0e 94 ca 0d 	call	0x1b94	; 0x1b94 <uart_puts_P>
    2710:	63 eb       	ldi	r22, 0xB3	; 179
    2712:	70 e4       	ldi	r23, 0x40	; 64
    2714:	81 e0       	ldi	r24, 0x01	; 1
    2716:	0e 94 01 13 	call	0x2602	; 0x2602 <cpWriteMac>
    271a:	65 e1       	ldi	r22, 0x15	; 21
    271c:	70 e0       	ldi	r23, 0x00	; 0
    271e:	82 e0       	ldi	r24, 0x02	; 2
    2720:	0e 94 01 13 	call	0x2602	; 0x2602 <cpWriteMac>
    2724:	62 e1       	ldi	r22, 0x12	; 18
    2726:	7c e0       	ldi	r23, 0x0C	; 12
    2728:	83 e0       	ldi	r24, 0x03	; 3
    272a:	0e 94 01 13 	call	0x2602	; 0x2602 <cpWriteMac>
    272e:	6e ee       	ldi	r22, 0xEE	; 238
    2730:	75 e0       	ldi	r23, 0x05	; 5
    2732:	85 e0       	ldi	r24, 0x05	; 5
    2734:	0e 94 01 13 	call	0x2602	; 0x2602 <cpWriteMac>
    2738:	6a ef       	ldi	r22, 0xFA	; 250
    273a:	88 e6       	ldi	r24, 0x68	; 104
    273c:	90 e0       	ldi	r25, 0x00	; 0
    273e:	0e 94 d7 11 	call	0x23ae	; 0x23ae <write_CP2200>
    2742:	6f e1       	ldi	r22, 0x1F	; 31
    2744:	89 e6       	ldi	r24, 0x69	; 105
    2746:	90 e0       	ldi	r25, 0x00	; 0
    2748:	0e 94 d7 11 	call	0x23ae	; 0x23ae <write_CP2200>
    274c:	85 e0       	ldi	r24, 0x05	; 5
    274e:	90 e0       	ldi	r25, 0x00	; 0
    2750:	0e 94 16 12 	call	0x242c	; 0x242c <read_CP2200>
    2754:	08 2f       	mov	r16, r24
    2756:	10 e0       	ldi	r17, 0x00	; 0
    2758:	85 e0       	ldi	r24, 0x05	; 5
    275a:	90 e0       	ldi	r25, 0x00	; 0
    275c:	0e 94 16 12 	call	0x242c	; 0x242c <read_CP2200>
    2760:	90 e0       	ldi	r25, 0x00	; 0
    2762:	98 2f       	mov	r25, r24
    2764:	88 27       	eor	r24, r24
    2766:	80 2b       	or	r24, r16
    2768:	91 2b       	or	r25, r17
    276a:	bc 01       	movw	r22, r24
    276c:	82 e1       	ldi	r24, 0x12	; 18
    276e:	0e 94 01 13 	call	0x2602	; 0x2602 <cpWriteMac>
    2772:	85 e0       	ldi	r24, 0x05	; 5
    2774:	90 e0       	ldi	r25, 0x00	; 0
    2776:	0e 94 16 12 	call	0x242c	; 0x242c <read_CP2200>
    277a:	08 2f       	mov	r16, r24
    277c:	10 e0       	ldi	r17, 0x00	; 0
    277e:	85 e0       	ldi	r24, 0x05	; 5
    2780:	90 e0       	ldi	r25, 0x00	; 0
    2782:	0e 94 16 12 	call	0x242c	; 0x242c <read_CP2200>
    2786:	90 e0       	ldi	r25, 0x00	; 0
    2788:	98 2f       	mov	r25, r24
    278a:	88 27       	eor	r24, r24
    278c:	80 2b       	or	r24, r16
    278e:	91 2b       	or	r25, r17
    2790:	bc 01       	movw	r22, r24
    2792:	81 e1       	ldi	r24, 0x11	; 17
    2794:	0e 94 01 13 	call	0x2602	; 0x2602 <cpWriteMac>
    2798:	85 e0       	ldi	r24, 0x05	; 5
    279a:	90 e0       	ldi	r25, 0x00	; 0
    279c:	0e 94 16 12 	call	0x242c	; 0x242c <read_CP2200>
    27a0:	08 2f       	mov	r16, r24
    27a2:	10 e0       	ldi	r17, 0x00	; 0
    27a4:	85 e0       	ldi	r24, 0x05	; 5
    27a6:	90 e0       	ldi	r25, 0x00	; 0
    27a8:	0e 94 16 12 	call	0x242c	; 0x242c <read_CP2200>
    27ac:	90 e0       	ldi	r25, 0x00	; 0
    27ae:	98 2f       	mov	r25, r24
    27b0:	88 27       	eor	r24, r24
    27b2:	80 2b       	or	r24, r16
    27b4:	91 2b       	or	r25, r17
    27b6:	bc 01       	movw	r22, r24
    27b8:	80 e1       	ldi	r24, 0x10	; 16
    27ba:	0e 94 01 13 	call	0x2602	; 0x2602 <cpWriteMac>
    27be:	6c e0       	ldi	r22, 0x0C	; 12
    27c0:	80 e7       	ldi	r24, 0x70	; 112
    27c2:	90 e0       	ldi	r25, 0x00	; 0
    27c4:	0e 94 d7 11 	call	0x23ae	; 0x23ae <write_CP2200>
    27c8:	61 e0       	ldi	r22, 0x01	; 1
    27ca:	70 e0       	ldi	r23, 0x00	; 0
    27cc:	80 e0       	ldi	r24, 0x00	; 0
    27ce:	0e 94 01 13 	call	0x2602	; 0x2602 <cpWriteMac>
    27d2:	63 e0       	ldi	r22, 0x03	; 3
    27d4:	84 e6       	ldi	r24, 0x64	; 100
    27d6:	90 e0       	ldi	r25, 0x00	; 0
    27d8:	0e 94 d7 11 	call	0x23ae	; 0x23ae <write_CP2200>
    27dc:	60 e0       	ldi	r22, 0x00	; 0
    27de:	8d e7       	ldi	r24, 0x7D	; 125
    27e0:	90 e0       	ldi	r25, 0x00	; 0
    27e2:	0e 94 d7 11 	call	0x23ae	; 0x23ae <write_CP2200>
    27e6:	83 e6       	ldi	r24, 0x63	; 99
    27e8:	90 e0       	ldi	r25, 0x00	; 0
    27ea:	0e 94 16 12 	call	0x242c	; 0x242c <read_CP2200>
    27ee:	8f e7       	ldi	r24, 0x7F	; 127
    27f0:	90 e0       	ldi	r25, 0x00	; 0
    27f2:	0e 94 16 12 	call	0x242c	; 0x242c <read_CP2200>
    27f6:	df 91       	pop	r29
    27f8:	cf 91       	pop	r28
    27fa:	1f 91       	pop	r17
    27fc:	0f 91       	pop	r16
    27fe:	08 95       	ret

00002800 <network_device_read>:
    2800:	cf 93       	push	r28
    2802:	df 93       	push	r29
    2804:	83 e6       	ldi	r24, 0x63	; 99
    2806:	90 e0       	ldi	r25, 0x00	; 0
    2808:	0e 94 16 12 	call	0x242c	; 0x242c <read_CP2200>
    280c:	80 93 80 03 	sts	0x0380, r24
    2810:	81 ff       	sbrs	r24, 1
    2812:	0e c0       	rjmp	.+28     	; 0x2830 <network_device_read+0x30>
    2814:	8c e9       	ldi	r24, 0x9C	; 156
    2816:	92 e0       	ldi	r25, 0x02	; 2
    2818:	0e 94 ca 0d 	call	0x1b94	; 0x1b94 <uart_puts_P>
    281c:	61 e0       	ldi	r22, 0x01	; 1
    281e:	81 e1       	ldi	r24, 0x11	; 17
    2820:	90 e0       	ldi	r25, 0x00	; 0
    2822:	0e 94 d7 11 	call	0x23ae	; 0x23ae <write_CP2200>
    2826:	60 e0       	ldi	r22, 0x00	; 0
    2828:	81 e1       	ldi	r24, 0x11	; 17
    282a:	90 e0       	ldi	r25, 0x00	; 0
    282c:	0e 94 d7 11 	call	0x23ae	; 0x23ae <write_CP2200>
    2830:	10 92 80 03 	sts	0x0380, r1
    2834:	8d e1       	ldi	r24, 0x1D	; 29
    2836:	90 e0       	ldi	r25, 0x00	; 0
    2838:	0e 94 16 12 	call	0x242c	; 0x242c <read_CP2200>
    283c:	87 ff       	sbrs	r24, 7
    283e:	18 c0       	rjmp	.+48     	; 0x2870 <network_device_read+0x70>
    2840:	8e e1       	ldi	r24, 0x1E	; 30
    2842:	90 e0       	ldi	r25, 0x00	; 0
    2844:	0e 94 16 12 	call	0x242c	; 0x242c <read_CP2200>
    2848:	87 ff       	sbrs	r24, 7
    284a:	12 c0       	rjmp	.+36     	; 0x2870 <network_device_read+0x70>
    284c:	28 9a       	sbi	0x05, 0	; 5
    284e:	87 e1       	ldi	r24, 0x17	; 23
    2850:	90 e0       	ldi	r25, 0x00	; 0
    2852:	0e 94 16 12 	call	0x242c	; 0x242c <read_CP2200>
    2856:	88 e1       	ldi	r24, 0x18	; 24
    2858:	90 e0       	ldi	r25, 0x00	; 0
    285a:	0e 94 16 12 	call	0x242c	; 0x242c <read_CP2200>
    285e:	0e 94 ab 12 	call	0x2556	; 0x2556 <CP2200_ReadPacket>
    2862:	ec 01       	movw	r28, r24
    2864:	66 e0       	ldi	r22, 0x06	; 6
    2866:	81 e1       	ldi	r24, 0x11	; 17
    2868:	90 e0       	ldi	r25, 0x00	; 0
    286a:	0e 94 d7 11 	call	0x23ae	; 0x23ae <write_CP2200>
    286e:	02 c0       	rjmp	.+4      	; 0x2874 <network_device_read+0x74>
    2870:	c0 e0       	ldi	r28, 0x00	; 0
    2872:	d0 e0       	ldi	r29, 0x00	; 0
    2874:	ce 01       	movw	r24, r28
    2876:	df 91       	pop	r29
    2878:	cf 91       	pop	r28
    287a:	08 95       	ret

0000287c <network_device_init>:
    287c:	ef 92       	push	r14
    287e:	ff 92       	push	r15
    2880:	0f 93       	push	r16
    2882:	1f 93       	push	r17
    2884:	cf 93       	push	r28
    2886:	df 93       	push	r29
    2888:	cd b7       	in	r28, 0x3d	; 61
    288a:	de b7       	in	r29, 0x3e	; 62
    288c:	60 97       	sbiw	r28, 0x10	; 16
    288e:	0f b6       	in	r0, 0x3f	; 63
    2890:	f8 94       	cli
    2892:	de bf       	out	0x3e, r29	; 62
    2894:	0f be       	out	0x3f, r0	; 63
    2896:	cd bf       	out	0x3d, r28	; 61
    2898:	0e 94 1e 13 	call	0x263c	; 0x263c <Init_CP2000>
    289c:	6a ef       	ldi	r22, 0xFA	; 250
    289e:	88 e6       	ldi	r24, 0x68	; 104
    28a0:	90 e0       	ldi	r25, 0x00	; 0
    28a2:	0e 94 d7 11 	call	0x23ae	; 0x23ae <write_CP2200>
    28a6:	6f e1       	ldi	r22, 0x1F	; 31
    28a8:	89 e6       	ldi	r24, 0x69	; 105
    28aa:	90 e0       	ldi	r25, 0x00	; 0
    28ac:	0e 94 d7 11 	call	0x23ae	; 0x23ae <write_CP2200>
    28b0:	85 e9       	ldi	r24, 0x95	; 149
    28b2:	92 e0       	ldi	r25, 0x02	; 2
    28b4:	0e 94 ca 0d 	call	0x1b94	; 0x1b94 <uart_puts_P>
    28b8:	7e 01       	movw	r14, r28
    28ba:	08 94       	sec
    28bc:	e1 1c       	adc	r14, r1
    28be:	f1 1c       	adc	r15, r1
    28c0:	8e 01       	movw	r16, r28
    28c2:	09 5f       	subi	r16, 0xF9	; 249
    28c4:	1f 4f       	sbci	r17, 0xFF	; 255
    28c6:	85 e0       	ldi	r24, 0x05	; 5
    28c8:	90 e0       	ldi	r25, 0x00	; 0
    28ca:	0e 94 16 12 	call	0x242c	; 0x242c <read_CP2200>
    28ce:	f7 01       	movw	r30, r14
    28d0:	81 93       	st	Z+, r24
    28d2:	7f 01       	movw	r14, r30
    28d4:	90 e0       	ldi	r25, 0x00	; 0
    28d6:	42 e0       	ldi	r20, 0x02	; 2
    28d8:	bc 01       	movw	r22, r24
    28da:	c8 01       	movw	r24, r16
    28dc:	0e 94 e1 0d 	call	0x1bc2	; 0x1bc2 <itohex>
    28e0:	c8 01       	movw	r24, r16
    28e2:	0e 94 bd 0d 	call	0x1b7a	; 0x1b7a <uart_puts>
    28e6:	e0 16       	cp	r14, r16
    28e8:	f1 06       	cpc	r15, r17
    28ea:	69 f7       	brne	.-38     	; 0x28c6 <network_device_init+0x4a>
    28ec:	82 e9       	ldi	r24, 0x92	; 146
    28ee:	92 e0       	ldi	r25, 0x02	; 2
    28f0:	0e 94 ca 0d 	call	0x1b94	; 0x1b94 <uart_puts_P>
    28f4:	89 81       	ldd	r24, Y+1	; 0x01
    28f6:	80 93 81 03 	sts	0x0381, r24
    28fa:	8a 81       	ldd	r24, Y+2	; 0x02
    28fc:	80 93 82 03 	sts	0x0382, r24
    2900:	8b 81       	ldd	r24, Y+3	; 0x03
    2902:	80 93 83 03 	sts	0x0383, r24
    2906:	8c 81       	ldd	r24, Y+4	; 0x04
    2908:	80 93 84 03 	sts	0x0384, r24
    290c:	8d 81       	ldd	r24, Y+5	; 0x05
    290e:	80 93 85 03 	sts	0x0385, r24
    2912:	8e 81       	ldd	r24, Y+6	; 0x06
    2914:	80 93 86 03 	sts	0x0386, r24
    2918:	8f ef       	ldi	r24, 0xFF	; 255
    291a:	9f ef       	ldi	r25, 0xFF	; 255
    291c:	90 93 b5 05 	sts	0x05B5, r25
    2920:	80 93 b4 05 	sts	0x05B4, r24
    2924:	8f ef       	ldi	r24, 0xFF	; 255
    2926:	90 e0       	ldi	r25, 0x00	; 0
    2928:	90 93 b7 05 	sts	0x05B7, r25
    292c:	80 93 b6 05 	sts	0x05B6, r24
    2930:	20 ec       	ldi	r18, 0xC0	; 192
    2932:	38 ea       	ldi	r19, 0xA8	; 168
    2934:	30 93 b9 05 	sts	0x05B9, r19
    2938:	20 93 b8 05 	sts	0x05B8, r18
    293c:	82 eb       	ldi	r24, 0xB2	; 178
    293e:	9e e0       	ldi	r25, 0x0E	; 14
    2940:	90 93 bb 05 	sts	0x05BB, r25
    2944:	80 93 ba 05 	sts	0x05BA, r24
    2948:	30 93 85 05 	sts	0x0585, r19
    294c:	20 93 84 05 	sts	0x0584, r18
    2950:	82 eb       	ldi	r24, 0xB2	; 178
    2952:	91 e0       	ldi	r25, 0x01	; 1
    2954:	90 93 87 05 	sts	0x0587, r25
    2958:	80 93 86 05 	sts	0x0586, r24
    295c:	60 96       	adiw	r28, 0x10	; 16
    295e:	0f b6       	in	r0, 0x3f	; 63
    2960:	f8 94       	cli
    2962:	de bf       	out	0x3e, r29	; 62
    2964:	0f be       	out	0x3f, r0	; 63
    2966:	cd bf       	out	0x3d, r28	; 61
    2968:	df 91       	pop	r29
    296a:	cf 91       	pop	r28
    296c:	1f 91       	pop	r17
    296e:	0f 91       	pop	r16
    2970:	ff 90       	pop	r15
    2972:	ef 90       	pop	r14
    2974:	08 95       	ret

00002976 <uip_setipid>:

static u16_t ipid;           /* Ths ipid variable is an increasing
				number that is used for the IP ID
				field. */

void uip_setipid(u16_t id) { ipid = id; }
    2976:	90 93 88 03 	sts	0x0388, r25
    297a:	80 93 87 03 	sts	0x0387, r24
    297e:	08 95       	ret

00002980 <uip_add32>:
#endif /* UIP_LOGGING == 1 */

#if ! UIP_ARCH_ADD32
void
uip_add32(u8_t *op32, u16_t op16)
{
    2980:	fc 01       	movw	r30, r24
  uip_acc32[3] = op32[3] + (op16 & 0xff);
    2982:	53 81       	ldd	r21, Z+3	; 0x03
    2984:	56 0f       	add	r21, r22
    2986:	50 93 3e 04 	sts	0x043E, r21
  uip_acc32[2] = op32[2] + (op16 >> 8);
    298a:	27 2f       	mov	r18, r23
    298c:	33 27       	eor	r19, r19
    298e:	42 81       	ldd	r20, Z+2	; 0x02
    2990:	42 0f       	add	r20, r18
    2992:	40 93 3d 04 	sts	0x043D, r20
  uip_acc32[1] = op32[1];
    2996:	a1 81       	ldd	r26, Z+1	; 0x01
    2998:	a0 93 3c 04 	sts	0x043C, r26
  uip_acc32[0] = op32[0];
    299c:	e0 81       	ld	r30, Z
    299e:	e0 93 3b 04 	sts	0x043B, r30
  
  if(uip_acc32[2] < (op16 >> 8)) {
    29a2:	84 2f       	mov	r24, r20
    29a4:	90 e0       	ldi	r25, 0x00	; 0
    29a6:	82 17       	cp	r24, r18
    29a8:	93 07       	cpc	r25, r19
    29aa:	48 f4       	brcc	.+18     	; 0x29be <uip_add32+0x3e>
    ++uip_acc32[1];
    29ac:	8a 2f       	mov	r24, r26
    29ae:	8f 5f       	subi	r24, 0xFF	; 255
    29b0:	80 93 3c 04 	sts	0x043C, r24
    if(uip_acc32[1] == 0) {
    29b4:	88 23       	and	r24, r24
    29b6:	19 f4       	brne	.+6      	; 0x29be <uip_add32+0x3e>
      ++uip_acc32[0];
    29b8:	ef 5f       	subi	r30, 0xFF	; 255
    29ba:	e0 93 3b 04 	sts	0x043B, r30
    }
  }
  
  
  if(uip_acc32[3] < (op16 & 0xff)) {
    29be:	85 2f       	mov	r24, r21
    29c0:	90 e0       	ldi	r25, 0x00	; 0
    29c2:	70 70       	andi	r23, 0x00	; 0
    29c4:	86 17       	cp	r24, r22
    29c6:	97 07       	cpc	r25, r23
    29c8:	90 f4       	brcc	.+36     	; 0x29ee <uip_add32+0x6e>
    ++uip_acc32[2];
    29ca:	84 2f       	mov	r24, r20
    29cc:	8f 5f       	subi	r24, 0xFF	; 255
    29ce:	80 93 3d 04 	sts	0x043D, r24
    if(uip_acc32[2] == 0) {
    29d2:	88 23       	and	r24, r24
    29d4:	61 f4       	brne	.+24     	; 0x29ee <uip_add32+0x6e>
      ++uip_acc32[1];
    29d6:	80 91 3c 04 	lds	r24, 0x043C
    29da:	8f 5f       	subi	r24, 0xFF	; 255
    29dc:	80 93 3c 04 	sts	0x043C, r24
      if(uip_acc32[1] == 0) {
    29e0:	88 23       	and	r24, r24
    29e2:	29 f4       	brne	.+10     	; 0x29ee <uip_add32+0x6e>
	++uip_acc32[0];
    29e4:	80 91 3b 04 	lds	r24, 0x043B
    29e8:	8f 5f       	subi	r24, 0xFF	; 255
    29ea:	80 93 3b 04 	sts	0x043B, r24
    29ee:	08 95       	ret

000029f0 <chksum>:

#if ! UIP_ARCH_CHKSUM
/*---------------------------------------------------------------------------*/
static u16_t
chksum(u16_t sum, const u8_t *data, u16_t len)
{
    29f0:	dc 01       	movw	r26, r24
  u16_t t;
  const u8_t *dataptr;
  const u8_t *last_byte;

  dataptr = data;
  last_byte = data + len - 1;
    29f2:	46 0f       	add	r20, r22
    29f4:	57 1f       	adc	r21, r23
    29f6:	41 50       	subi	r20, 0x01	; 1
    29f8:	50 40       	sbci	r21, 0x00	; 0
    29fa:	fb 01       	movw	r30, r22
    29fc:	0e c0       	rjmp	.+28     	; 0x2a1a <chksum+0x2a>
  
  while(dataptr < last_byte) {	/* At least two more bytes */
    t = (dataptr[0] << 8) + dataptr[1];
    29fe:	80 81       	ld	r24, Z
    2a00:	90 e0       	ldi	r25, 0x00	; 0
    2a02:	98 2f       	mov	r25, r24
    2a04:	88 27       	eor	r24, r24
    2a06:	21 81       	ldd	r18, Z+1	; 0x01
    2a08:	82 0f       	add	r24, r18
    2a0a:	91 1d       	adc	r25, r1
    sum += t;
    2a0c:	a8 0f       	add	r26, r24
    2a0e:	b9 1f       	adc	r27, r25
    if(sum < t) {
    2a10:	a8 17       	cp	r26, r24
    2a12:	b9 07       	cpc	r27, r25
    2a14:	08 f4       	brcc	.+2      	; 0x2a18 <chksum+0x28>
      sum++;		/* carry */
    2a16:	11 96       	adiw	r26, 0x01	; 1
    }
    dataptr += 2;
    2a18:	32 96       	adiw	r30, 0x02	; 2
  const u8_t *last_byte;

  dataptr = data;
  last_byte = data + len - 1;
  
  while(dataptr < last_byte) {	/* At least two more bytes */
    2a1a:	e4 17       	cp	r30, r20
    2a1c:	f5 07       	cpc	r31, r21
    2a1e:	78 f3       	brcs	.-34     	; 0x29fe <chksum+0xe>
      sum++;		/* carry */
    }
    dataptr += 2;
  }
  
  if(dataptr == last_byte) {
    2a20:	e4 17       	cp	r30, r20
    2a22:	f5 07       	cpc	r31, r21
    2a24:	51 f4       	brne	.+20     	; 0x2a3a <chksum+0x4a>
    t = (dataptr[0] << 8) + 0;
    2a26:	80 81       	ld	r24, Z
    2a28:	90 e0       	ldi	r25, 0x00	; 0
    2a2a:	98 2f       	mov	r25, r24
    2a2c:	88 27       	eor	r24, r24
    sum += t;
    2a2e:	a8 0f       	add	r26, r24
    2a30:	b9 1f       	adc	r27, r25
    if(sum < t) {
    2a32:	a8 17       	cp	r26, r24
    2a34:	b9 07       	cpc	r27, r25
    2a36:	08 f4       	brcc	.+2      	; 0x2a3a <chksum+0x4a>
      sum++;		/* carry */
    2a38:	11 96       	adiw	r26, 0x01	; 1
    }
  }

  /* Return sum in host byte order. */
  return sum;
}
    2a3a:	cd 01       	movw	r24, r26
    2a3c:	08 95       	ret

00002a3e <uip_ipchksum>:
}
/*---------------------------------------------------------------------------*/
#ifndef UIP_ARCH_IPCHKSUM
u16_t
uip_ipchksum(void)
{
    2a3e:	cf 93       	push	r28
    2a40:	df 93       	push	r29
  u16_t sum;

  sum = chksum(0, &uip_buf[UIP_LLH_LEN], UIP_IPH_LEN);
    2a42:	44 e1       	ldi	r20, 0x14	; 20
    2a44:	50 e0       	ldi	r21, 0x00	; 0
    2a46:	6a ec       	ldi	r22, 0xCA	; 202
    2a48:	75 e0       	ldi	r23, 0x05	; 5
    2a4a:	80 e0       	ldi	r24, 0x00	; 0
    2a4c:	90 e0       	ldi	r25, 0x00	; 0
    2a4e:	0e 94 f8 14 	call	0x29f0	; 0x29f0 <chksum>
  DEBUG_PRINTF("uip_ipchksum: sum 0x%04x\n", sum);
  return (sum == 0) ? 0xffff : htons(sum);
    2a52:	00 97       	sbiw	r24, 0x00	; 0
    2a54:	19 f4       	brne	.+6      	; 0x2a5c <uip_ipchksum+0x1e>
    2a56:	cf ef       	ldi	r28, 0xFF	; 255
    2a58:	df ef       	ldi	r29, 0xFF	; 255
    2a5a:	02 c0       	rjmp	.+4      	; 0x2a60 <uip_ipchksum+0x22>
}
/*---------------------------------------------------------------------------*/
u16_t
htons(u16_t val)
{
  return HTONS(val);
    2a5c:	c9 2f       	mov	r28, r25
    2a5e:	d8 2f       	mov	r29, r24
  u16_t sum;

  sum = chksum(0, &uip_buf[UIP_LLH_LEN], UIP_IPH_LEN);
  DEBUG_PRINTF("uip_ipchksum: sum 0x%04x\n", sum);
  return (sum == 0) ? 0xffff : htons(sum);
}
    2a60:	ce 01       	movw	r24, r28
    2a62:	df 91       	pop	r29
    2a64:	cf 91       	pop	r28
    2a66:	08 95       	ret

00002a68 <upper_layer_chksum>:
#endif
/*---------------------------------------------------------------------------*/
static u16_t
upper_layer_chksum(u8_t proto)
{
    2a68:	0f 93       	push	r16
    2a6a:	1f 93       	push	r17
    2a6c:	cf 93       	push	r28
    2a6e:	df 93       	push	r29
  u16_t sum;
  
#if UIP_CONF_IPV6
  upper_layer_len = (((u16_t)(BUF->len[0]) << 8) + BUF->len[1]);
#else /* UIP_CONF_IPV6 */
  upper_layer_len = (((u16_t)(BUF->len[0]) << 8) + BUF->len[1]) - UIP_IPH_LEN;
    2a70:	00 91 cd 05 	lds	r16, 0x05CD
    2a74:	10 e0       	ldi	r17, 0x00	; 0
    2a76:	04 51       	subi	r16, 0x14	; 20
    2a78:	10 40       	sbci	r17, 0x00	; 0
    2a7a:	20 91 cc 05 	lds	r18, 0x05CC
    2a7e:	30 e0       	ldi	r19, 0x00	; 0
    2a80:	32 2f       	mov	r19, r18
    2a82:	22 27       	eor	r18, r18
    2a84:	02 0f       	add	r16, r18
    2a86:	13 1f       	adc	r17, r19
  /* First sum pseudoheader. */
  
  /* IP protocol and length fields. This addition cannot carry. */
  sum = upper_layer_len + proto;
  /* Sum IP source and destination addresses. */
  sum = chksum(sum, (u8_t *)&BUF->srcipaddr[0], 2 * sizeof(uip_ipaddr_t));
    2a88:	48 e0       	ldi	r20, 0x08	; 8
    2a8a:	50 e0       	ldi	r21, 0x00	; 0
    2a8c:	66 ed       	ldi	r22, 0xD6	; 214
    2a8e:	75 e0       	ldi	r23, 0x05	; 5
    2a90:	98 01       	movw	r18, r16
    2a92:	28 0f       	add	r18, r24
    2a94:	31 1d       	adc	r19, r1
    2a96:	c9 01       	movw	r24, r18
    2a98:	0e 94 f8 14 	call	0x29f0	; 0x29f0 <chksum>

  /* Sum TCP header and data. */
  sum = chksum(sum, &uip_buf[UIP_IPH_LEN + UIP_LLH_LEN],
    2a9c:	a8 01       	movw	r20, r16
    2a9e:	6e ed       	ldi	r22, 0xDE	; 222
    2aa0:	75 e0       	ldi	r23, 0x05	; 5
    2aa2:	0e 94 f8 14 	call	0x29f0	; 0x29f0 <chksum>
	       upper_layer_len);
    
  return (sum == 0) ? 0xffff : htons(sum);
    2aa6:	00 97       	sbiw	r24, 0x00	; 0
    2aa8:	19 f4       	brne	.+6      	; 0x2ab0 <upper_layer_chksum+0x48>
    2aaa:	cf ef       	ldi	r28, 0xFF	; 255
    2aac:	df ef       	ldi	r29, 0xFF	; 255
    2aae:	02 c0       	rjmp	.+4      	; 0x2ab4 <upper_layer_chksum+0x4c>
}
/*---------------------------------------------------------------------------*/
u16_t
htons(u16_t val)
{
  return HTONS(val);
    2ab0:	c9 2f       	mov	r28, r25
    2ab2:	d8 2f       	mov	r29, r24
  /* Sum TCP header and data. */
  sum = chksum(sum, &uip_buf[UIP_IPH_LEN + UIP_LLH_LEN],
	       upper_layer_len);
    
  return (sum == 0) ? 0xffff : htons(sum);
}
    2ab4:	ce 01       	movw	r24, r28
    2ab6:	df 91       	pop	r29
    2ab8:	cf 91       	pop	r28
    2aba:	1f 91       	pop	r17
    2abc:	0f 91       	pop	r16
    2abe:	08 95       	ret

00002ac0 <uip_tcpchksum>:
}
#endif /* UIP_CONF_IPV6 */
/*---------------------------------------------------------------------------*/
u16_t
uip_tcpchksum(void)
{
    2ac0:	86 e0       	ldi	r24, 0x06	; 6
    2ac2:	0e 94 34 15 	call	0x2a68	; 0x2a68 <upper_layer_chksum>
    2ac6:	08 95       	ret

00002ac8 <uip_udpchksum>:
}
/*---------------------------------------------------------------------------*/
#if UIP_UDP_CHECKSUMS
u16_t
uip_udpchksum(void)
{
    2ac8:	81 e1       	ldi	r24, 0x11	; 17
    2aca:	0e 94 34 15 	call	0x2a68	; 0x2a68 <upper_layer_chksum>
    2ace:	08 95       	ret

00002ad0 <uip_init>:
#endif /* UIP_UDP_CHECKSUMS */
#endif /* UIP_ARCH_CHKSUM */
/*---------------------------------------------------------------------------*/
void
uip_init(void)
{
    2ad0:	80 e0       	ldi	r24, 0x00	; 0
    2ad2:	09 c0       	rjmp	.+18     	; 0x2ae6 <uip_init+0x16>
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    uip_listenports[c] = 0;
    2ad4:	e8 2f       	mov	r30, r24
    2ad6:	f0 e0       	ldi	r31, 0x00	; 0
    2ad8:	ee 0f       	add	r30, r30
    2ada:	ff 1f       	adc	r31, r31
    2adc:	e0 58       	subi	r30, 0x80	; 128
    2ade:	fa 4f       	sbci	r31, 0xFA	; 250
    2ae0:	11 82       	std	Z+1, r1	; 0x01
    2ae2:	10 82       	st	Z, r1
    2ae4:	8f 5f       	subi	r24, 0xFF	; 255
#endif /* UIP_ARCH_CHKSUM */
/*---------------------------------------------------------------------------*/
void
uip_init(void)
{
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    2ae6:	82 30       	cpi	r24, 0x02	; 2
    2ae8:	a8 f3       	brcs	.-22     	; 0x2ad4 <uip_init+0x4>
    2aea:	40 e0       	ldi	r20, 0x00	; 0
    2aec:	0f c0       	rjmp	.+30     	; 0x2b0c <uip_init+0x3c>
    uip_listenports[c] = 0;
  }
  for(c = 0; c < UIP_CONNS; ++c) {
    uip_conns[c].tcpstateflags = UIP_CLOSED;
    2aee:	24 2f       	mov	r18, r20
    2af0:	30 e0       	ldi	r19, 0x00	; 0
    2af2:	8e e9       	ldi	r24, 0x9E	; 158
    2af4:	90 e0       	ldi	r25, 0x00	; 0
    2af6:	28 9f       	mul	r18, r24
    2af8:	f0 01       	movw	r30, r0
    2afa:	29 9f       	mul	r18, r25
    2afc:	f0 0d       	add	r31, r0
    2afe:	38 9f       	mul	r19, r24
    2b00:	f0 0d       	add	r31, r0
    2b02:	11 24       	eor	r1, r1
    2b04:	ec 5b       	subi	r30, 0xBC	; 188
    2b06:	fb 4f       	sbci	r31, 0xFB	; 251
    2b08:	11 8e       	std	Z+25, r1	; 0x19
    2b0a:	4f 5f       	subi	r20, 0xFF	; 255
uip_init(void)
{
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    uip_listenports[c] = 0;
  }
  for(c = 0; c < UIP_CONNS; ++c) {
    2b0c:	42 30       	cpi	r20, 0x02	; 2
    2b0e:	78 f3       	brcs	.-34     	; 0x2aee <uip_init+0x1e>
    2b10:	40 93 8f 03 	sts	0x038F, r20
    uip_conns[c].tcpstateflags = UIP_CLOSED;
  }
#if UIP_ACTIVE_OPEN
  lastport = 1024;
    2b14:	80 e0       	ldi	r24, 0x00	; 0
    2b16:	94 e0       	ldi	r25, 0x04	; 4
    2b18:	90 93 8e 03 	sts	0x038E, r25
    2b1c:	80 93 8d 03 	sts	0x038D, r24
    2b20:	08 95       	ret

00002b22 <uip_unlisten>:
}
#endif /* UIP_UDP */
/*---------------------------------------------------------------------------*/
void
uip_unlisten(u16_t port)
{
    2b22:	ac 01       	movw	r20, r24
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    2b24:	10 92 8f 03 	sts	0x038F, r1
    2b28:	20 e0       	ldi	r18, 0x00	; 0
    2b2a:	13 c0       	rjmp	.+38     	; 0x2b52 <uip_unlisten+0x30>
    if(uip_listenports[c] == port) {
    2b2c:	e2 2f       	mov	r30, r18
    2b2e:	f0 e0       	ldi	r31, 0x00	; 0
    2b30:	32 2f       	mov	r19, r18
    2b32:	3f 5f       	subi	r19, 0xFF	; 255
    2b34:	ee 0f       	add	r30, r30
    2b36:	ff 1f       	adc	r31, r31
    2b38:	e0 58       	subi	r30, 0x80	; 128
    2b3a:	fa 4f       	sbci	r31, 0xFA	; 250
    2b3c:	80 81       	ld	r24, Z
    2b3e:	91 81       	ldd	r25, Z+1	; 0x01
    2b40:	84 17       	cp	r24, r20
    2b42:	95 07       	cpc	r25, r21
    2b44:	29 f4       	brne	.+10     	; 0x2b50 <uip_unlisten+0x2e>
    2b46:	20 93 8f 03 	sts	0x038F, r18
      uip_listenports[c] = 0;
    2b4a:	11 82       	std	Z+1, r1	; 0x01
    2b4c:	10 82       	st	Z, r1
    2b4e:	08 95       	ret
      return;
    2b50:	23 2f       	mov	r18, r19
#endif /* UIP_UDP */
/*---------------------------------------------------------------------------*/
void
uip_unlisten(u16_t port)
{
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    2b52:	22 30       	cpi	r18, 0x02	; 2
    2b54:	58 f3       	brcs	.-42     	; 0x2b2c <uip_unlisten+0xa>
    2b56:	20 93 8f 03 	sts	0x038F, r18
    2b5a:	08 95       	ret

00002b5c <uip_listen>:
  }
}
/*---------------------------------------------------------------------------*/
void
uip_listen(u16_t port)
{
    2b5c:	ac 01       	movw	r20, r24
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    2b5e:	10 92 8f 03 	sts	0x038F, r1
    2b62:	20 e0       	ldi	r18, 0x00	; 0
    2b64:	12 c0       	rjmp	.+36     	; 0x2b8a <uip_listen+0x2e>
    if(uip_listenports[c] == 0) {
    2b66:	e2 2f       	mov	r30, r18
    2b68:	f0 e0       	ldi	r31, 0x00	; 0
    2b6a:	32 2f       	mov	r19, r18
    2b6c:	3f 5f       	subi	r19, 0xFF	; 255
    2b6e:	ee 0f       	add	r30, r30
    2b70:	ff 1f       	adc	r31, r31
    2b72:	e0 58       	subi	r30, 0x80	; 128
    2b74:	fa 4f       	sbci	r31, 0xFA	; 250
    2b76:	80 81       	ld	r24, Z
    2b78:	91 81       	ldd	r25, Z+1	; 0x01
    2b7a:	89 2b       	or	r24, r25
    2b7c:	29 f4       	brne	.+10     	; 0x2b88 <uip_listen+0x2c>
    2b7e:	20 93 8f 03 	sts	0x038F, r18
      uip_listenports[c] = port;
    2b82:	51 83       	std	Z+1, r21	; 0x01
    2b84:	40 83       	st	Z, r20
    2b86:	08 95       	ret
      return;
    2b88:	23 2f       	mov	r18, r19
}
/*---------------------------------------------------------------------------*/
void
uip_listen(u16_t port)
{
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    2b8a:	22 30       	cpi	r18, 0x02	; 2
    2b8c:	60 f3       	brcs	.-40     	; 0x2b66 <uip_listen+0xa>
    2b8e:	20 93 8f 03 	sts	0x038F, r18
    2b92:	08 95       	ret

00002b94 <uip_add_rcv_nxt>:
}
#endif /* UIP_REASSEMBLY */
/*---------------------------------------------------------------------------*/
static void
uip_add_rcv_nxt(u16_t n)
{
    2b94:	bc 01       	movw	r22, r24
  uip_add32(uip_conn->rcv_nxt, n);
    2b96:	80 91 42 04 	lds	r24, 0x0442
    2b9a:	90 91 43 04 	lds	r25, 0x0443
    2b9e:	08 96       	adiw	r24, 0x08	; 8
    2ba0:	0e 94 c0 14 	call	0x2980	; 0x2980 <uip_add32>
  uip_conn->rcv_nxt[0] = uip_acc32[0];
    2ba4:	e0 91 42 04 	lds	r30, 0x0442
    2ba8:	f0 91 43 04 	lds	r31, 0x0443
    2bac:	80 91 3b 04 	lds	r24, 0x043B
    2bb0:	80 87       	std	Z+8, r24	; 0x08
  uip_conn->rcv_nxt[1] = uip_acc32[1];
    2bb2:	e0 91 42 04 	lds	r30, 0x0442
    2bb6:	f0 91 43 04 	lds	r31, 0x0443
    2bba:	80 91 3c 04 	lds	r24, 0x043C
    2bbe:	81 87       	std	Z+9, r24	; 0x09
  uip_conn->rcv_nxt[2] = uip_acc32[2];
    2bc0:	e0 91 42 04 	lds	r30, 0x0442
    2bc4:	f0 91 43 04 	lds	r31, 0x0443
    2bc8:	80 91 3d 04 	lds	r24, 0x043D
    2bcc:	82 87       	std	Z+10, r24	; 0x0a
  uip_conn->rcv_nxt[3] = uip_acc32[3];
    2bce:	e0 91 42 04 	lds	r30, 0x0442
    2bd2:	f0 91 43 04 	lds	r31, 0x0443
    2bd6:	80 91 3e 04 	lds	r24, 0x043E
    2bda:	83 87       	std	Z+11, r24	; 0x0b
    2bdc:	08 95       	ret

00002bde <htons>:
  return;
}
/*---------------------------------------------------------------------------*/
u16_t
htons(u16_t val)
{
    2bde:	29 2f       	mov	r18, r25
    2be0:	38 2f       	mov	r19, r24
  return HTONS(val);
}
    2be2:	c9 01       	movw	r24, r18
    2be4:	08 95       	ret

00002be6 <uip_send>:
}

/*---------------------------------------------------------------------------*/
void
uip_send(const void *data, int len)
{
    2be6:	9c 01       	movw	r18, r24
    2be8:	ab 01       	movw	r20, r22
  if(len > 0) {
    2bea:	16 16       	cp	r1, r22
    2bec:	17 06       	cpc	r1, r23
    2bee:	74 f4       	brge	.+28     	; 0x2c0c <uip_send+0x26>
    uip_slen = len;
    2bf0:	70 93 9b 0b 	sts	0x0B9B, r23
    2bf4:	60 93 9a 0b 	sts	0x0B9A, r22
    if(data != uip_sappdata) {
    2bf8:	80 91 39 04 	lds	r24, 0x0439
    2bfc:	90 91 3a 04 	lds	r25, 0x043A
    2c00:	28 17       	cp	r18, r24
    2c02:	39 07       	cpc	r19, r25
    2c04:	19 f0       	breq	.+6      	; 0x2c0c <uip_send+0x26>
      memcpy(uip_sappdata, (data), uip_slen);
    2c06:	b9 01       	movw	r22, r18
    2c08:	0e 94 82 2c 	call	0x5904	; 0x5904 <memcpy>
    2c0c:	08 95       	ret

00002c0e <uip_send_P>:
  return HTONS(val);
}
/*---------------------------------------------------------------------------*/
void
uip_send_P(const void *data, int len)
{
    2c0e:	ab 01       	movw	r20, r22
  if(len > 0) {
    2c10:	16 16       	cp	r1, r22
    2c12:	17 06       	cpc	r1, r23
    2c14:	5c f4       	brge	.+22     	; 0x2c2c <uip_send_P+0x1e>
    uip_slen = len;
    2c16:	70 93 9b 0b 	sts	0x0B9B, r23
    2c1a:	60 93 9a 0b 	sts	0x0B9A, r22
    //if(data != uip_sappdata) {
      memcpy_P(uip_sappdata, (data), uip_slen);
    2c1e:	bc 01       	movw	r22, r24
    2c20:	80 91 39 04 	lds	r24, 0x0439
    2c24:	90 91 3a 04 	lds	r25, 0x043A
    2c28:	0e 94 38 2c 	call	0x5870	; 0x5870 <memcpy_P>
    2c2c:	08 95       	ret

00002c2e <uip_process>:
  uip_conn->rcv_nxt[3] = uip_acc32[3];
}
/*---------------------------------------------------------------------------*/
void
uip_process(u8_t flag)
{
    2c2e:	0f 93       	push	r16
    2c30:	1f 93       	push	r17
    2c32:	cf 93       	push	r28
    2c34:	df 93       	push	r29
  register struct uip_conn *uip_connr = uip_conn;
    2c36:	c0 91 42 04 	lds	r28, 0x0442
    2c3a:	d0 91 43 04 	lds	r29, 0x0443
  if(flag == UIP_UDP_SEND_CONN) {
    goto udp_send;
  }
#endif /* UIP_UDP */
  
  uip_sappdata = uip_appdata = &uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN];
    2c3e:	22 ef       	ldi	r18, 0xF2	; 242
    2c40:	35 e0       	ldi	r19, 0x05	; 5
    2c42:	30 93 41 04 	sts	0x0441, r19
    2c46:	20 93 40 04 	sts	0x0440, r18
    2c4a:	30 93 3a 04 	sts	0x043A, r19
    2c4e:	20 93 39 04 	sts	0x0439, r18

  /* Check if we were invoked because of a poll request for a
     particular connection. */
  if(flag == UIP_POLL_REQUEST) {
    2c52:	83 30       	cpi	r24, 0x03	; 3
    2c54:	59 f4       	brne	.+22     	; 0x2c6c <uip_process+0x3e>
    if((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_ESTABLISHED &&
    2c56:	89 8d       	ldd	r24, Y+25	; 0x19
    2c58:	8f 70       	andi	r24, 0x0F	; 15
    2c5a:	83 30       	cpi	r24, 0x03	; 3
    2c5c:	09 f0       	breq	.+2      	; 0x2c60 <uip_process+0x32>
    2c5e:	3d c7       	rjmp	.+3706   	; 0x3ada <uip_process+0xeac>
    2c60:	88 89       	ldd	r24, Y+16	; 0x10
    2c62:	99 89       	ldd	r25, Y+17	; 0x11
    2c64:	89 2b       	or	r24, r25
    2c66:	09 f0       	breq	.+2      	; 0x2c6a <uip_process+0x3c>
    2c68:	38 c7       	rjmp	.+3696   	; 0x3ada <uip_process+0xeac>
    2c6a:	92 c0       	rjmp	.+292    	; 0x2d90 <uip_process+0x162>
	goto appsend;
    }
    goto drop;
    
    /* Check if we were invoked because of the perodic timer fireing. */
  } else if(flag == UIP_TIMER) {
    2c6c:	82 30       	cpi	r24, 0x02	; 2
    2c6e:	09 f0       	breq	.+2      	; 0x2c72 <uip_process+0x44>
    2c70:	93 c0       	rjmp	.+294    	; 0x2d98 <uip_process+0x16a>
    if(uip_reasstmr != 0) {
      --uip_reasstmr;
    }
#endif /* UIP_REASSEMBLY */
    /* Increase the initial sequence number. */
    if(++iss[3] == 0) {
    2c72:	80 91 8c 03 	lds	r24, 0x038C
    2c76:	8f 5f       	subi	r24, 0xFF	; 255
    2c78:	80 93 8c 03 	sts	0x038C, r24
    2c7c:	88 23       	and	r24, r24
    2c7e:	99 f4       	brne	.+38     	; 0x2ca6 <uip_process+0x78>
      if(++iss[2] == 0) {
    2c80:	80 91 8b 03 	lds	r24, 0x038B
    2c84:	8f 5f       	subi	r24, 0xFF	; 255
    2c86:	80 93 8b 03 	sts	0x038B, r24
    2c8a:	88 23       	and	r24, r24
    2c8c:	61 f4       	brne	.+24     	; 0x2ca6 <uip_process+0x78>
	if(++iss[1] == 0) {
    2c8e:	80 91 8a 03 	lds	r24, 0x038A
    2c92:	8f 5f       	subi	r24, 0xFF	; 255
    2c94:	80 93 8a 03 	sts	0x038A, r24
    2c98:	88 23       	and	r24, r24
    2c9a:	29 f4       	brne	.+10     	; 0x2ca6 <uip_process+0x78>
	  ++iss[0];
    2c9c:	80 91 89 03 	lds	r24, 0x0389
    2ca0:	8f 5f       	subi	r24, 0xFF	; 255
    2ca2:	80 93 89 03 	sts	0x0389, r24
	}
      }
    }

    /* Reset the length variables. */
    uip_len = 0;
    2ca6:	10 92 38 04 	sts	0x0438, r1
    2caa:	10 92 37 04 	sts	0x0437, r1
    uip_slen = 0;
    2cae:	10 92 9b 0b 	sts	0x0B9B, r1
    2cb2:	10 92 9a 0b 	sts	0x0B9A, r1

    /* Check if the connection is in a state in which we simply wait
       for the connection to time out. If so, we increase the
       connection's timer and remove the connection if it times
       out. */
    if(uip_connr->tcpstateflags == UIP_TIME_WAIT ||
    2cb6:	29 8d       	ldd	r18, Y+25	; 0x19
    2cb8:	27 30       	cpi	r18, 0x07	; 7
    2cba:	11 f0       	breq	.+4      	; 0x2cc0 <uip_process+0x92>
    2cbc:	25 30       	cpi	r18, 0x05	; 5
    2cbe:	41 f4       	brne	.+16     	; 0x2cd0 <uip_process+0xa2>
       uip_connr->tcpstateflags == UIP_FIN_WAIT_2) {
      ++(uip_connr->timer);
    2cc0:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2cc2:	8f 5f       	subi	r24, 0xFF	; 255
    2cc4:	8a 8f       	std	Y+26, r24	; 0x1a
      if(uip_connr->timer == UIP_TIME_WAIT_TIMEOUT) {
    2cc6:	88 37       	cpi	r24, 0x78	; 120
    2cc8:	09 f0       	breq	.+2      	; 0x2ccc <uip_process+0x9e>
    2cca:	07 c7       	rjmp	.+3598   	; 0x3ada <uip_process+0xeac>
	uip_connr->tcpstateflags = UIP_CLOSED;
    2ccc:	19 8e       	std	Y+25, r1	; 0x19
    2cce:	05 c7       	rjmp	.+3594   	; 0x3ada <uip_process+0xeac>
      }
    } else if(uip_connr->tcpstateflags != UIP_CLOSED) {
    2cd0:	22 23       	and	r18, r18
    2cd2:	09 f4       	brne	.+2      	; 0x2cd6 <uip_process+0xa8>
    2cd4:	02 c7       	rjmp	.+3588   	; 0x3ada <uip_process+0xeac>
      /* If the connection has outstanding data, we increase the
	 connection's timer and see if it has reached the RTO value
	 in which case we retransmit. */
      if(uip_outstanding(uip_connr)) {
    2cd6:	88 89       	ldd	r24, Y+16	; 0x10
    2cd8:	99 89       	ldd	r25, Y+17	; 0x11
    2cda:	89 2b       	or	r24, r25
    2cdc:	09 f4       	brne	.+2      	; 0x2ce0 <uip_process+0xb2>
    2cde:	54 c0       	rjmp	.+168    	; 0x2d88 <uip_process+0x15a>
	if(uip_connr->timer-- == 0) {
    2ce0:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2ce2:	81 50       	subi	r24, 0x01	; 1
    2ce4:	8a 8f       	std	Y+26, r24	; 0x1a
    2ce6:	8f 3f       	cpi	r24, 0xFF	; 255
    2ce8:	09 f0       	breq	.+2      	; 0x2cec <uip_process+0xbe>
    2cea:	f7 c6       	rjmp	.+3566   	; 0x3ada <uip_process+0xeac>
	  if(uip_connr->nrtx == UIP_MAXRTX ||
    2cec:	3b 8d       	ldd	r19, Y+27	; 0x1b
    2cee:	38 30       	cpi	r19, 0x08	; 8
    2cf0:	29 f0       	breq	.+10     	; 0x2cfc <uip_process+0xce>
    2cf2:	21 50       	subi	r18, 0x01	; 1
    2cf4:	22 30       	cpi	r18, 0x02	; 2
    2cf6:	48 f4       	brcc	.+18     	; 0x2d0a <uip_process+0xdc>
    2cf8:	35 30       	cpi	r19, 0x05	; 5
    2cfa:	39 f4       	brne	.+14     	; 0x2d0a <uip_process+0xdc>
	     ((uip_connr->tcpstateflags == UIP_SYN_SENT ||
	       uip_connr->tcpstateflags == UIP_SYN_RCVD) &&
	      uip_connr->nrtx == UIP_MAXSYNRTX)) {
	    uip_connr->tcpstateflags = UIP_CLOSED;
    2cfc:	19 8e       	std	Y+25, r1	; 0x19

	    /* We call UIP_APPCALL() with uip_flags set to
	       UIP_TIMEDOUT to inform the application that the
	       connection has timed out. */
	    uip_flags = UIP_TIMEDOUT;
    2cfe:	80 e8       	ldi	r24, 0x80	; 128
    2d00:	80 93 3f 04 	sts	0x043F, r24
	    UIP_APPCALL();
    2d04:	0e 94 c6 27 	call	0x4f8c	; 0x4f8c <httpd_appcall>
    2d08:	86 c5       	rjmp	.+2828   	; 0x3816 <uip_process+0xbe8>
	    BUF->flags = TCP_RST | TCP_ACK;
	    goto tcp_send_nodata;
	  }

	  /* Exponential backoff. */
	  uip_connr->timer = UIP_RTO << (uip_connr->nrtx > 4?
    2d0a:	35 30       	cpi	r19, 0x05	; 5
    2d0c:	10 f0       	brcs	.+4      	; 0x2d12 <uip_process+0xe4>
    2d0e:	80 e3       	ldi	r24, 0x30	; 48
    2d10:	07 c0       	rjmp	.+14     	; 0x2d20 <uip_process+0xf2>
    2d12:	83 e0       	ldi	r24, 0x03	; 3
    2d14:	90 e0       	ldi	r25, 0x00	; 0
    2d16:	02 c0       	rjmp	.+4      	; 0x2d1c <uip_process+0xee>
    2d18:	88 0f       	add	r24, r24
    2d1a:	99 1f       	adc	r25, r25
    2d1c:	3a 95       	dec	r19
    2d1e:	e2 f7       	brpl	.-8      	; 0x2d18 <uip_process+0xea>
    2d20:	8a 8f       	std	Y+26, r24	; 0x1a
					 4:
					 uip_connr->nrtx);
	  ++(uip_connr->nrtx);
    2d22:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2d24:	8f 5f       	subi	r24, 0xFF	; 255
    2d26:	8b 8f       	std	Y+27, r24	; 0x1b
	     depending on which state we are in. In ESTABLISHED, we
	     call upon the application so that it may prepare the
	     data for the retransmit. In SYN_RCVD, we resend the
	     SYNACK that we sent earlier and in LAST_ACK we have to
	     retransmit our FINACK. */
	  UIP_STAT(++uip_stat.tcp.rexmit);
    2d28:	80 91 ae 05 	lds	r24, 0x05AE
    2d2c:	90 91 af 05 	lds	r25, 0x05AF
    2d30:	01 96       	adiw	r24, 0x01	; 1
    2d32:	90 93 af 05 	sts	0x05AF, r25
    2d36:	80 93 ae 05 	sts	0x05AE, r24
	  switch(uip_connr->tcpstateflags & UIP_TS_MASK) {
    2d3a:	89 8d       	ldd	r24, Y+25	; 0x19
    2d3c:	90 e0       	ldi	r25, 0x00	; 0
    2d3e:	8f 70       	andi	r24, 0x0F	; 15
    2d40:	90 70       	andi	r25, 0x00	; 0
    2d42:	83 30       	cpi	r24, 0x03	; 3
    2d44:	91 05       	cpc	r25, r1
    2d46:	d1 f0       	breq	.+52     	; 0x2d7c <uip_process+0x14e>
    2d48:	84 30       	cpi	r24, 0x04	; 4
    2d4a:	91 05       	cpc	r25, r1
    2d4c:	44 f4       	brge	.+16     	; 0x2d5e <uip_process+0x130>
    2d4e:	81 30       	cpi	r24, 0x01	; 1
    2d50:	91 05       	cpc	r25, r1
    2d52:	09 f4       	brne	.+2      	; 0x2d56 <uip_process+0x128>
    2d54:	3e c3       	rjmp	.+1660   	; 0x33d2 <uip_process+0x7a4>
    2d56:	02 97       	sbiw	r24, 0x02	; 2
    2d58:	09 f0       	breq	.+2      	; 0x2d5c <uip_process+0x12e>
    2d5a:	bf c6       	rjmp	.+3454   	; 0x3ada <uip_process+0xeac>
    2d5c:	0c c0       	rjmp	.+24     	; 0x2d76 <uip_process+0x148>
    2d5e:	86 30       	cpi	r24, 0x06	; 6
    2d60:	91 05       	cpc	r25, r1
    2d62:	09 f4       	brne	.+2      	; 0x2d66 <uip_process+0x138>
    2d64:	ec c4       	rjmp	.+2520   	; 0x373e <uip_process+0xb10>
    2d66:	88 30       	cpi	r24, 0x08	; 8
    2d68:	91 05       	cpc	r25, r1
    2d6a:	09 f4       	brne	.+2      	; 0x2d6e <uip_process+0x140>
    2d6c:	e8 c4       	rjmp	.+2512   	; 0x373e <uip_process+0xb10>
    2d6e:	04 97       	sbiw	r24, 0x04	; 4
    2d70:	09 f0       	breq	.+2      	; 0x2d74 <uip_process+0x146>
    2d72:	b3 c6       	rjmp	.+3430   	; 0x3ada <uip_process+0xeac>
    2d74:	e4 c4       	rjmp	.+2504   	; 0x373e <uip_process+0xb10>
	    goto tcp_send_synack;
	    
#if UIP_ACTIVE_OPEN
	  case UIP_SYN_SENT:
	    /* In the SYN_SENT state, we retransmit out SYN. */
	    BUF->flags = 0;
    2d76:	10 92 eb 05 	sts	0x05EB, r1
    2d7a:	2e c3       	rjmp	.+1628   	; 0x33d8 <uip_process+0x7aa>
	  case UIP_ESTABLISHED:
	    /* In the ESTABLISHED state, we call upon the application
               to do the actual retransmit after which we jump into
               the code for sending out the packet (the apprexmit
               label). */
	    uip_flags = UIP_REXMIT;
    2d7c:	84 e0       	ldi	r24, 0x04	; 4
    2d7e:	80 93 3f 04 	sts	0x043F, r24
	    UIP_APPCALL();
    2d82:	0e 94 c6 27 	call	0x4f8c	; 0x4f8c <httpd_appcall>
    2d86:	7c c5       	rjmp	.+2808   	; 0x3880 <uip_process+0xc52>
	    /* In all these states we should retransmit a FINACK. */
	    goto tcp_send_finack;
	    
	  }
	}
      } else if((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_ESTABLISHED) {
    2d88:	2f 70       	andi	r18, 0x0F	; 15
    2d8a:	23 30       	cpi	r18, 0x03	; 3
    2d8c:	09 f0       	breq	.+2      	; 0x2d90 <uip_process+0x162>
    2d8e:	a5 c6       	rjmp	.+3402   	; 0x3ada <uip_process+0xeac>
	/* If there was no need for a retransmission, we poll the
           application for new data. */
	uip_flags = UIP_POLL;
    2d90:	88 e0       	ldi	r24, 0x08	; 8
    2d92:	80 93 3f 04 	sts	0x043F, r24
    2d96:	33 c5       	rjmp	.+2662   	; 0x37fe <uip_process+0xbd0>
    }
  }
#endif

  /* This is where the input processing starts. */
  UIP_STAT(++uip_stat.ip.recv);
    2d98:	80 91 8a 05 	lds	r24, 0x058A
    2d9c:	90 91 8b 05 	lds	r25, 0x058B
    2da0:	01 96       	adiw	r24, 0x01	; 1
    2da2:	90 93 8b 05 	sts	0x058B, r25
    2da6:	80 93 8a 05 	sts	0x058A, r24
    UIP_LOG("ipv6: invalid version.");
    goto drop;
  }
#else /* UIP_CONF_IPV6 */
  /* Check validity of the IP header. */
  if(BUF->vhl != 0x45)  { /* IP version and header length. */
    2daa:	89 01       	movw	r16, r18
    2dac:	08 52       	subi	r16, 0x28	; 40
    2dae:	10 40       	sbci	r17, 0x00	; 0
    2db0:	80 91 ca 05 	lds	r24, 0x05CA
    2db4:	85 34       	cpi	r24, 0x45	; 69
    2db6:	a9 f0       	breq	.+42     	; 0x2de2 <uip_process+0x1b4>
    UIP_STAT(++uip_stat.ip.drop);
    2db8:	80 91 88 05 	lds	r24, 0x0588
    2dbc:	90 91 89 05 	lds	r25, 0x0589
    2dc0:	01 96       	adiw	r24, 0x01	; 1
    2dc2:	90 93 89 05 	sts	0x0589, r25
    2dc6:	80 93 88 05 	sts	0x0588, r24
    UIP_STAT(++uip_stat.ip.vhlerr);
    2dca:	80 91 8e 05 	lds	r24, 0x058E
    2dce:	90 91 8f 05 	lds	r25, 0x058F
    2dd2:	01 96       	adiw	r24, 0x01	; 1
    2dd4:	90 93 8f 05 	sts	0x058F, r25
    2dd8:	80 93 8e 05 	sts	0x058E, r24
    UIP_LOG("ip: invalid version or header length.");
    2ddc:	81 e0       	ldi	r24, 0x01	; 1
    2dde:	91 e0       	ldi	r25, 0x01	; 1
    2de0:	1e c0       	rjmp	.+60     	; 0x2e1e <uip_process+0x1f0>
     that the packet has been corrupted in transit. If the size of
     uip_len is larger than the size reported in the IP packet header,
     the packet has been padded and we set uip_len to the correct
     value.. */

  if((BUF->len[0] << 8) + BUF->len[1] <= uip_len) {
    2de2:	80 91 cc 05 	lds	r24, 0x05CC
    2de6:	90 e0       	ldi	r25, 0x00	; 0
    2de8:	38 2f       	mov	r19, r24
    2dea:	22 27       	eor	r18, r18
    2dec:	80 91 cd 05 	lds	r24, 0x05CD
    2df0:	28 0f       	add	r18, r24
    2df2:	31 1d       	adc	r19, r1
    2df4:	80 91 37 04 	lds	r24, 0x0437
    2df8:	90 91 38 04 	lds	r25, 0x0438
    2dfc:	82 17       	cp	r24, r18
    2dfe:	93 07       	cpc	r25, r19
    2e00:	60 f0       	brcs	.+24     	; 0x2e1a <uip_process+0x1ec>
    uip_len = (BUF->len[0] << 8) + BUF->len[1];
    2e02:	30 93 38 04 	sts	0x0438, r19
    2e06:	20 93 37 04 	sts	0x0437, r18
    goto drop;
  }

#if !UIP_CONF_IPV6
  /* Check the fragment flag. */
  if((BUF->ipoffset[0] & 0x3f) != 0 ||
    2e0a:	80 91 d0 05 	lds	r24, 0x05D0
    2e0e:	90 e0       	ldi	r25, 0x00	; 0
    2e10:	8f 73       	andi	r24, 0x3F	; 63
    2e12:	90 70       	andi	r25, 0x00	; 0
    2e14:	89 2b       	or	r24, r25
    2e16:	31 f0       	breq	.+12     	; 0x2e24 <uip_process+0x1f6>
    2e18:	09 c0       	rjmp	.+18     	; 0x2e2c <uip_process+0x1fe>
		      contains the length of the entire packet. But
		      for IPv6 we need to add the size of the IPv6
		      header (40 bytes). */
#endif /* UIP_CONF_IPV6 */
  } else {
    UIP_LOG("ip: packet shorter than reported in IP header.");
    2e1a:	87 e2       	ldi	r24, 0x27	; 39
    2e1c:	91 e0       	ldi	r25, 0x01	; 1
    2e1e:	0e 94 3f 0e 	call	0x1c7e	; 0x1c7e <uip_log>
    2e22:	5b c6       	rjmp	.+3254   	; 0x3ada <uip_process+0xeac>
    goto drop;
  }

#if !UIP_CONF_IPV6
  /* Check the fragment flag. */
  if((BUF->ipoffset[0] & 0x3f) != 0 ||
    2e24:	80 91 d1 05 	lds	r24, 0x05D1
    2e28:	88 23       	and	r24, r24
    2e2a:	a9 f0       	breq	.+42     	; 0x2e56 <uip_process+0x228>
    uip_len = uip_reass();
    if(uip_len == 0) {
      goto drop;
    }
#else /* UIP_REASSEMBLY */
    UIP_STAT(++uip_stat.ip.drop);
    2e2c:	80 91 88 05 	lds	r24, 0x0588
    2e30:	90 91 89 05 	lds	r25, 0x0589
    2e34:	01 96       	adiw	r24, 0x01	; 1
    2e36:	90 93 89 05 	sts	0x0589, r25
    2e3a:	80 93 88 05 	sts	0x0588, r24
    UIP_STAT(++uip_stat.ip.fragerr);
    2e3e:	80 91 94 05 	lds	r24, 0x0594
    2e42:	90 91 95 05 	lds	r25, 0x0595
    2e46:	01 96       	adiw	r24, 0x01	; 1
    2e48:	90 93 95 05 	sts	0x0595, r25
    2e4c:	80 93 94 05 	sts	0x0594, r24
    UIP_LOG("ip: fragment dropped.");
    2e50:	86 e5       	ldi	r24, 0x56	; 86
    2e52:	91 e0       	ldi	r25, 0x01	; 1
    2e54:	e4 cf       	rjmp	.-56     	; 0x2e1e <uip_process+0x1f0>
    goto drop;
#endif /* UIP_REASSEMBLY */
  }
#endif /* UIP_CONF_IPV6 */

  if(uip_ipaddr_cmp(uip_hostaddr, all_zeroes_addr)) {
    2e56:	20 91 b8 05 	lds	r18, 0x05B8
    2e5a:	30 91 b9 05 	lds	r19, 0x05B9
    2e5e:	21 15       	cp	r18, r1
    2e60:	31 05       	cpc	r19, r1
    2e62:	31 f4       	brne	.+12     	; 0x2e70 <uip_process+0x242>
    2e64:	80 91 ba 05 	lds	r24, 0x05BA
    2e68:	90 91 bb 05 	lds	r25, 0x05BB
    2e6c:	89 2b       	or	r24, r25
    2e6e:	e1 f0       	breq	.+56     	; 0x2ea8 <uip_process+0x27a>
    }
#endif /* UIP_BROADCAST */
    
    /* Check if the packet is destined for our IP address. */
#if !UIP_CONF_IPV6
    if(!uip_ipaddr_cmp(BUF->destipaddr, uip_hostaddr)) {
    2e70:	80 91 da 05 	lds	r24, 0x05DA
    2e74:	90 91 db 05 	lds	r25, 0x05DB
    2e78:	82 17       	cp	r24, r18
    2e7a:	93 07       	cpc	r25, r19
    2e7c:	59 f4       	brne	.+22     	; 0x2e94 <uip_process+0x266>
    2e7e:	20 91 dc 05 	lds	r18, 0x05DC
    2e82:	30 91 dd 05 	lds	r19, 0x05DD
    2e86:	80 91 ba 05 	lds	r24, 0x05BA
    2e8a:	90 91 bb 05 	lds	r25, 0x05BB
    2e8e:	28 17       	cp	r18, r24
    2e90:	39 07       	cpc	r19, r25
    2e92:	51 f0       	breq	.+20     	; 0x2ea8 <uip_process+0x27a>
      UIP_STAT(++uip_stat.ip.drop);
    2e94:	80 91 88 05 	lds	r24, 0x0588
    2e98:	90 91 89 05 	lds	r25, 0x0589
    2e9c:	01 96       	adiw	r24, 0x01	; 1
    2e9e:	90 93 89 05 	sts	0x0589, r25
    2ea2:	80 93 88 05 	sts	0x0588, r24
    2ea6:	19 c6       	rjmp	.+3122   	; 0x3ada <uip_process+0xeac>
    }
#endif /* UIP_CONF_IPV6 */
  }

#if !UIP_CONF_IPV6
  if(uip_ipchksum() != 0xffff) { /* Compute and check the IP header
    2ea8:	0e 94 1f 15 	call	0x2a3e	; 0x2a3e <uip_ipchksum>
    2eac:	8f 5f       	subi	r24, 0xFF	; 255
    2eae:	9f 4f       	sbci	r25, 0xFF	; 255
    2eb0:	a9 f0       	breq	.+42     	; 0x2edc <uip_process+0x2ae>
				    checksum. */
    UIP_STAT(++uip_stat.ip.drop);
    2eb2:	80 91 88 05 	lds	r24, 0x0588
    2eb6:	90 91 89 05 	lds	r25, 0x0589
    2eba:	01 96       	adiw	r24, 0x01	; 1
    2ebc:	90 93 89 05 	sts	0x0589, r25
    2ec0:	80 93 88 05 	sts	0x0588, r24
    UIP_STAT(++uip_stat.ip.chkerr);
    2ec4:	80 91 96 05 	lds	r24, 0x0596
    2ec8:	90 91 97 05 	lds	r25, 0x0597
    2ecc:	01 96       	adiw	r24, 0x01	; 1
    2ece:	90 93 97 05 	sts	0x0597, r25
    2ed2:	80 93 96 05 	sts	0x0596, r24
    UIP_LOG("ip: bad checksum.");
    2ed6:	8c e6       	ldi	r24, 0x6C	; 108
    2ed8:	91 e0       	ldi	r25, 0x01	; 1
    2eda:	a1 cf       	rjmp	.-190    	; 0x2e1e <uip_process+0x1f0>
    goto drop;
  }
#endif /* UIP_CONF_IPV6 */

  if(BUF->proto == UIP_PROTO_TCP) { /* Check for TCP packet. If so,
    2edc:	80 91 d3 05 	lds	r24, 0x05D3
    2ee0:	86 30       	cpi	r24, 0x06	; 6
    2ee2:	09 f4       	brne	.+2      	; 0x2ee6 <uip_process+0x2b8>
    2ee4:	74 c0       	rjmp	.+232    	; 0x2fce <uip_process+0x3a0>
  }
#endif /* UIP_UDP */

#if !UIP_CONF_IPV6
  /* ICMPv4 processing code follows. */
  if(BUF->proto != UIP_PROTO_ICMP) { /* We only allow ICMP packets from
    2ee6:	81 30       	cpi	r24, 0x01	; 1
    2ee8:	a9 f0       	breq	.+42     	; 0x2f14 <uip_process+0x2e6>
					here. */
    UIP_STAT(++uip_stat.ip.drop);
    2eea:	80 91 88 05 	lds	r24, 0x0588
    2eee:	90 91 89 05 	lds	r25, 0x0589
    2ef2:	01 96       	adiw	r24, 0x01	; 1
    2ef4:	90 93 89 05 	sts	0x0589, r25
    2ef8:	80 93 88 05 	sts	0x0588, r24
    UIP_STAT(++uip_stat.ip.protoerr);
    2efc:	80 91 98 05 	lds	r24, 0x0598
    2f00:	90 91 99 05 	lds	r25, 0x0599
    2f04:	01 96       	adiw	r24, 0x01	; 1
    2f06:	90 93 99 05 	sts	0x0599, r25
    2f0a:	80 93 98 05 	sts	0x0598, r24
    UIP_LOG("ip: neither tcp nor icmp.");
    2f0e:	8e e7       	ldi	r24, 0x7E	; 126
    2f10:	91 e0       	ldi	r25, 0x01	; 1
    2f12:	85 cf       	rjmp	.-246    	; 0x2e1e <uip_process+0x1f0>
  }

#if UIP_PINGADDRCONF
 icmp_input:
#endif /* UIP_PINGADDRCONF */
  UIP_STAT(++uip_stat.icmp.recv);
    2f14:	80 91 9c 05 	lds	r24, 0x059C
    2f18:	90 91 9d 05 	lds	r25, 0x059D
    2f1c:	01 96       	adiw	r24, 0x01	; 1
    2f1e:	90 93 9d 05 	sts	0x059D, r25
    2f22:	80 93 9c 05 	sts	0x059C, r24

  /* ICMP echo (i.e., ping) processing. This is simple, we only change
     the ICMP type from ECHO to ECHO_REPLY and adjust the ICMP
     checksum before we return the packet. */
  if(ICMPBUF->type != ICMP_ECHO) {
    2f26:	80 91 de 05 	lds	r24, 0x05DE
    2f2a:	88 30       	cpi	r24, 0x08	; 8
    2f2c:	a9 f0       	breq	.+42     	; 0x2f58 <uip_process+0x32a>
    UIP_STAT(++uip_stat.icmp.drop);
    2f2e:	80 91 9a 05 	lds	r24, 0x059A
    2f32:	90 91 9b 05 	lds	r25, 0x059B
    2f36:	01 96       	adiw	r24, 0x01	; 1
    2f38:	90 93 9b 05 	sts	0x059B, r25
    2f3c:	80 93 9a 05 	sts	0x059A, r24
    UIP_STAT(++uip_stat.icmp.typeerr);
    2f40:	80 91 a0 05 	lds	r24, 0x05A0
    2f44:	90 91 a1 05 	lds	r25, 0x05A1
    2f48:	01 96       	adiw	r24, 0x01	; 1
    2f4a:	90 93 a1 05 	sts	0x05A1, r25
    2f4e:	80 93 a0 05 	sts	0x05A0, r24
    UIP_LOG("icmp: not icmp echo.");
    2f52:	88 e9       	ldi	r24, 0x98	; 152
    2f54:	91 e0       	ldi	r25, 0x01	; 1
    2f56:	63 cf       	rjmp	.-314    	; 0x2e1e <uip_process+0x1f0>
    uip_hostaddr[0] = BUF->destipaddr[0];
    uip_hostaddr[1] = BUF->destipaddr[1];
  }
#endif /* UIP_PINGADDRCONF */

  ICMPBUF->type = ICMP_ECHO_REPLY;
    2f58:	10 92 de 05 	sts	0x05DE, r1

  if(ICMPBUF->icmpchksum >= HTONS(0xffff - (ICMP_ECHO << 8))) {
    2f5c:	80 91 e0 05 	lds	r24, 0x05E0
    2f60:	90 91 e1 05 	lds	r25, 0x05E1
    2f64:	ef ef       	ldi	r30, 0xFF	; 255
    2f66:	87 3f       	cpi	r24, 0xF7	; 247
    2f68:	9e 07       	cpc	r25, r30
    2f6a:	10 f0       	brcs	.+4      	; 0x2f70 <uip_process+0x342>
    ICMPBUF->icmpchksum += HTONS(ICMP_ECHO << 8) + 1;
    2f6c:	09 96       	adiw	r24, 0x09	; 9
    2f6e:	01 c0       	rjmp	.+2      	; 0x2f72 <uip_process+0x344>
  } else {
    ICMPBUF->icmpchksum += HTONS(ICMP_ECHO << 8);
    2f70:	08 96       	adiw	r24, 0x08	; 8
    2f72:	90 93 e1 05 	sts	0x05E1, r25
    2f76:	80 93 e0 05 	sts	0x05E0, r24
  }

  /* Swap IP addresses. */
  uip_ipaddr_copy(BUF->destipaddr, BUF->srcipaddr);
    2f7a:	80 91 d6 05 	lds	r24, 0x05D6
    2f7e:	90 91 d7 05 	lds	r25, 0x05D7
    2f82:	90 93 db 05 	sts	0x05DB, r25
    2f86:	80 93 da 05 	sts	0x05DA, r24
    2f8a:	80 91 d8 05 	lds	r24, 0x05D8
    2f8e:	90 91 d9 05 	lds	r25, 0x05D9
    2f92:	90 93 dd 05 	sts	0x05DD, r25
    2f96:	80 93 dc 05 	sts	0x05DC, r24
  uip_ipaddr_copy(BUF->srcipaddr, uip_hostaddr);
    2f9a:	80 91 b8 05 	lds	r24, 0x05B8
    2f9e:	90 91 b9 05 	lds	r25, 0x05B9
    2fa2:	90 93 d7 05 	sts	0x05D7, r25
    2fa6:	80 93 d6 05 	sts	0x05D6, r24
    2faa:	80 91 ba 05 	lds	r24, 0x05BA
    2fae:	90 91 bb 05 	lds	r25, 0x05BB
    2fb2:	90 93 d9 05 	sts	0x05D9, r25
    2fb6:	80 93 d8 05 	sts	0x05D8, r24

  UIP_STAT(++uip_stat.icmp.sent);
    2fba:	80 91 9e 05 	lds	r24, 0x059E
    2fbe:	90 91 9f 05 	lds	r25, 0x059F
    2fc2:	01 96       	adiw	r24, 0x01	; 1
    2fc4:	90 93 9f 05 	sts	0x059F, r25
    2fc8:	80 93 9e 05 	sts	0x059E, r24
    2fcc:	7c c5       	rjmp	.+2808   	; 0x3ac6 <uip_process+0xe98>
  goto ip_send_nolen;
#endif /* UIP_UDP */
  
  /* TCP input processing. */
 tcp_input:
  UIP_STAT(++uip_stat.tcp.recv);
    2fce:	80 91 a4 05 	lds	r24, 0x05A4
    2fd2:	90 91 a5 05 	lds	r25, 0x05A5
    2fd6:	01 96       	adiw	r24, 0x01	; 1
    2fd8:	90 93 a5 05 	sts	0x05A5, r25
    2fdc:	80 93 a4 05 	sts	0x05A4, r24

  /* Start of TCP input header processing code. */
  
  if(uip_tcpchksum() != 0xffff) {   /* Compute and check the TCP
    2fe0:	0e 94 60 15 	call	0x2ac0	; 0x2ac0 <uip_tcpchksum>
    2fe4:	8f 5f       	subi	r24, 0xFF	; 255
    2fe6:	9f 4f       	sbci	r25, 0xFF	; 255
    2fe8:	a9 f0       	breq	.+42     	; 0x3014 <uip_process+0x3e6>
				       checksum. */
    UIP_STAT(++uip_stat.tcp.drop);
    2fea:	80 91 a2 05 	lds	r24, 0x05A2
    2fee:	90 91 a3 05 	lds	r25, 0x05A3
    2ff2:	01 96       	adiw	r24, 0x01	; 1
    2ff4:	90 93 a3 05 	sts	0x05A3, r25
    2ff8:	80 93 a2 05 	sts	0x05A2, r24
    UIP_STAT(++uip_stat.tcp.chkerr);
    2ffc:	80 91 a8 05 	lds	r24, 0x05A8
    3000:	90 91 a9 05 	lds	r25, 0x05A9
    3004:	01 96       	adiw	r24, 0x01	; 1
    3006:	90 93 a9 05 	sts	0x05A9, r25
    300a:	80 93 a8 05 	sts	0x05A8, r24
    UIP_LOG("tcp: bad checksum.");
    300e:	8d ea       	ldi	r24, 0xAD	; 173
    3010:	91 e0       	ldi	r25, 0x01	; 1
    3012:	05 cf       	rjmp	.-502    	; 0x2e1e <uip_process+0x1f0>
  
  /* Demultiplex this segment. */
  /* First check any active connections. */
  for(uip_connr = &uip_conns[0]; uip_connr <= &uip_conns[UIP_CONNS - 1];
      ++uip_connr) {
    if(uip_connr->tcpstateflags != UIP_CLOSED &&
    3014:	80 91 5d 04 	lds	r24, 0x045D
    3018:	88 23       	and	r24, r24
    301a:	79 f1       	breq	.+94     	; 0x307a <uip_process+0x44c>
    301c:	20 91 e0 05 	lds	r18, 0x05E0
    3020:	30 91 e1 05 	lds	r19, 0x05E1
    3024:	80 91 48 04 	lds	r24, 0x0448
    3028:	90 91 49 04 	lds	r25, 0x0449
    302c:	28 17       	cp	r18, r24
    302e:	39 07       	cpc	r19, r25
    3030:	21 f5       	brne	.+72     	; 0x307a <uip_process+0x44c>
    3032:	20 91 de 05 	lds	r18, 0x05DE
    3036:	30 91 df 05 	lds	r19, 0x05DF
    303a:	80 91 4a 04 	lds	r24, 0x044A
    303e:	90 91 4b 04 	lds	r25, 0x044B
    3042:	28 17       	cp	r18, r24
    3044:	39 07       	cpc	r19, r25
    3046:	c9 f4       	brne	.+50     	; 0x307a <uip_process+0x44c>
    3048:	20 91 d6 05 	lds	r18, 0x05D6
    304c:	30 91 d7 05 	lds	r19, 0x05D7
    3050:	80 91 44 04 	lds	r24, 0x0444
    3054:	90 91 45 04 	lds	r25, 0x0445
    3058:	28 17       	cp	r18, r24
    305a:	39 07       	cpc	r19, r25
    305c:	71 f4       	brne	.+28     	; 0x307a <uip_process+0x44c>
    305e:	20 91 d8 05 	lds	r18, 0x05D8
    3062:	30 91 d9 05 	lds	r19, 0x05D9
    3066:	80 91 46 04 	lds	r24, 0x0446
    306a:	90 91 47 04 	lds	r25, 0x0447
    306e:	28 17       	cp	r18, r24
    3070:	39 07       	cpc	r19, r25
    3072:	19 f4       	brne	.+6      	; 0x307a <uip_process+0x44c>
    3074:	c4 e4       	ldi	r28, 0x44	; 68
    3076:	d4 e0       	ldi	r29, 0x04	; 4
    3078:	ca c1       	rjmp	.+916    	; 0x340e <uip_process+0x7e0>
    307a:	80 91 fb 04 	lds	r24, 0x04FB
    307e:	88 23       	and	r24, r24
    3080:	69 f1       	breq	.+90     	; 0x30dc <uip_process+0x4ae>
    3082:	20 91 e0 05 	lds	r18, 0x05E0
    3086:	30 91 e1 05 	lds	r19, 0x05E1
    308a:	80 91 e6 04 	lds	r24, 0x04E6
    308e:	90 91 e7 04 	lds	r25, 0x04E7
    3092:	28 17       	cp	r18, r24
    3094:	39 07       	cpc	r19, r25
    3096:	11 f5       	brne	.+68     	; 0x30dc <uip_process+0x4ae>
    3098:	20 91 de 05 	lds	r18, 0x05DE
    309c:	30 91 df 05 	lds	r19, 0x05DF
    30a0:	80 91 e8 04 	lds	r24, 0x04E8
    30a4:	90 91 e9 04 	lds	r25, 0x04E9
    30a8:	28 17       	cp	r18, r24
    30aa:	39 07       	cpc	r19, r25
    30ac:	b9 f4       	brne	.+46     	; 0x30dc <uip_process+0x4ae>
    30ae:	20 91 d6 05 	lds	r18, 0x05D6
    30b2:	30 91 d7 05 	lds	r19, 0x05D7
    30b6:	80 91 e2 04 	lds	r24, 0x04E2
    30ba:	90 91 e3 04 	lds	r25, 0x04E3
    30be:	28 17       	cp	r18, r24
    30c0:	39 07       	cpc	r19, r25
    30c2:	61 f4       	brne	.+24     	; 0x30dc <uip_process+0x4ae>
    30c4:	20 91 d8 05 	lds	r18, 0x05D8
    30c8:	30 91 d9 05 	lds	r19, 0x05D9
    30cc:	80 91 e4 04 	lds	r24, 0x04E4
    30d0:	90 91 e5 04 	lds	r25, 0x04E5
    30d4:	28 17       	cp	r18, r24
    30d6:	39 07       	cpc	r19, r25
    30d8:	09 f4       	brne	.+2      	; 0x30dc <uip_process+0x4ae>
    30da:	97 c1       	rjmp	.+814    	; 0x340a <uip_process+0x7dc>

  /* If we didn't find and active connection that expected the packet,
     either this packet is an old duplicate, or this is a SYN packet
     destined for a connection in LISTEN. If the SYN flag isn't set,
     it is an old packet and we send a RST. */
  if((BUF->flags & TCP_CTL) != TCP_SYN) {
    30dc:	80 91 eb 05 	lds	r24, 0x05EB
    30e0:	8f 73       	andi	r24, 0x3F	; 63
    30e2:	82 30       	cpi	r24, 0x02	; 2
    30e4:	31 f5       	brne	.+76     	; 0x3132 <uip_process+0x504>
    goto reset;
  }
  
  tmp16 = BUF->destport;
    30e6:	40 91 e0 05 	lds	r20, 0x05E0
    30ea:	50 91 e1 05 	lds	r21, 0x05E1
    30ee:	50 93 92 03 	sts	0x0392, r21
    30f2:	40 93 91 03 	sts	0x0391, r20
  /* Next, check listening connections. */
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    30f6:	10 92 8f 03 	sts	0x038F, r1
    30fa:	20 e0       	ldi	r18, 0x00	; 0
    30fc:	0d c0       	rjmp	.+26     	; 0x3118 <uip_process+0x4ea>
    if(tmp16 == uip_listenports[c])
    30fe:	e2 2f       	mov	r30, r18
    3100:	f0 e0       	ldi	r31, 0x00	; 0
    3102:	ee 0f       	add	r30, r30
    3104:	ff 1f       	adc	r31, r31
    3106:	e0 58       	subi	r30, 0x80	; 128
    3108:	fa 4f       	sbci	r31, 0xFA	; 250
    310a:	80 81       	ld	r24, Z
    310c:	91 81       	ldd	r25, Z+1	; 0x01
    310e:	2f 5f       	subi	r18, 0xFF	; 255
    3110:	48 17       	cp	r20, r24
    3112:	59 07       	cpc	r21, r25
    3114:	09 f4       	brne	.+2      	; 0x3118 <uip_process+0x4ea>
    3116:	80 c0       	rjmp	.+256    	; 0x3218 <uip_process+0x5ea>
    goto reset;
  }
  
  tmp16 = BUF->destport;
  /* Next, check listening connections. */
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    3118:	22 30       	cpi	r18, 0x02	; 2
    311a:	88 f3       	brcs	.-30     	; 0x30fe <uip_process+0x4d0>
    311c:	20 93 8f 03 	sts	0x038F, r18
    if(tmp16 == uip_listenports[c])
      goto found_listen;
  }
  
  /* No matching connection found, so we send a RST packet. */
  UIP_STAT(++uip_stat.tcp.synrst);
    3120:	80 91 b2 05 	lds	r24, 0x05B2
    3124:	90 91 b3 05 	lds	r25, 0x05B3
    3128:	01 96       	adiw	r24, 0x01	; 1
    312a:	90 93 b3 05 	sts	0x05B3, r25
    312e:	80 93 b2 05 	sts	0x05B2, r24
 reset:

  /* We do not send resets in response to resets. */
  if(BUF->flags & TCP_RST) {
    3132:	80 91 eb 05 	lds	r24, 0x05EB
    3136:	82 fd       	sbrc	r24, 2
    3138:	d0 c4       	rjmp	.+2464   	; 0x3ada <uip_process+0xeac>
    goto drop;
  }

  UIP_STAT(++uip_stat.tcp.rst);
    313a:	80 91 ac 05 	lds	r24, 0x05AC
    313e:	90 91 ad 05 	lds	r25, 0x05AD
    3142:	01 96       	adiw	r24, 0x01	; 1
    3144:	90 93 ad 05 	sts	0x05AD, r25
    3148:	80 93 ac 05 	sts	0x05AC, r24
  
  BUF->flags = TCP_RST | TCP_ACK;
    314c:	84 e1       	ldi	r24, 0x14	; 20
    314e:	f8 01       	movw	r30, r16
    3150:	81 a3       	std	Z+33, r24	; 0x21
  uip_len = UIP_IPTCPH_LEN;
    3152:	88 e2       	ldi	r24, 0x28	; 40
    3154:	90 e0       	ldi	r25, 0x00	; 0
    3156:	90 93 38 04 	sts	0x0438, r25
    315a:	80 93 37 04 	sts	0x0437, r24
  BUF->tcpoffset = 5 << 4;
    315e:	80 e5       	ldi	r24, 0x50	; 80
    3160:	80 a3       	std	Z+32, r24	; 0x20

  /* Flip the seqno and ackno fields in the TCP header. */
  c = BUF->seqno[3];
    3162:	90 91 e5 05 	lds	r25, 0x05E5
  BUF->seqno[3] = BUF->ackno[3];
    3166:	80 91 e9 05 	lds	r24, 0x05E9
    316a:	83 8f       	std	Z+27, r24	; 0x1b
  BUF->ackno[3] = c;
  
  c = BUF->seqno[2];
    316c:	30 91 e4 05 	lds	r19, 0x05E4
  BUF->seqno[2] = BUF->ackno[2];
    3170:	80 91 e8 05 	lds	r24, 0x05E8
    3174:	82 8f       	std	Z+26, r24	; 0x1a
  BUF->ackno[2] = c;
    3176:	36 8f       	std	Z+30, r19	; 0x1e
  
  c = BUF->seqno[1];
    3178:	40 91 e3 05 	lds	r20, 0x05E3
  BUF->seqno[1] = BUF->ackno[1];
    317c:	80 91 e7 05 	lds	r24, 0x05E7
    3180:	81 8f       	std	Z+25, r24	; 0x19
  BUF->ackno[1] = c;
    3182:	45 8f       	std	Z+29, r20	; 0x1d
  
  c = BUF->seqno[0];
    3184:	20 91 e2 05 	lds	r18, 0x05E2
    3188:	20 93 8f 03 	sts	0x038F, r18
  BUF->seqno[0] = BUF->ackno[0];
    318c:	80 91 e6 05 	lds	r24, 0x05E6
    3190:	80 8f       	std	Z+24, r24	; 0x18
  BUF->ackno[0] = c;
    3192:	24 8f       	std	Z+28, r18	; 0x1c

  /* We also have to increase the sequence number we are
     acknowledging. If the least significant byte overflowed, we need
     to propagate the carry to the other bytes as well. */
  if(++BUF->ackno[3] == 0) {
    3194:	9f 5f       	subi	r25, 0xFF	; 255
    3196:	97 8f       	std	Z+31, r25	; 0x1f
    3198:	99 23       	and	r25, r25
    319a:	61 f4       	brne	.+24     	; 0x31b4 <uip_process+0x586>
    if(++BUF->ackno[2] == 0) {
    319c:	83 2f       	mov	r24, r19
    319e:	8f 5f       	subi	r24, 0xFF	; 255
    31a0:	86 8f       	std	Z+30, r24	; 0x1e
    31a2:	88 23       	and	r24, r24
    31a4:	39 f4       	brne	.+14     	; 0x31b4 <uip_process+0x586>
      if(++BUF->ackno[1] == 0) {
    31a6:	84 2f       	mov	r24, r20
    31a8:	8f 5f       	subi	r24, 0xFF	; 255
    31aa:	85 8f       	std	Z+29, r24	; 0x1d
    31ac:	88 23       	and	r24, r24
    31ae:	11 f4       	brne	.+4      	; 0x31b4 <uip_process+0x586>
	++BUF->ackno[0];
    31b0:	2f 5f       	subi	r18, 0xFF	; 255
    31b2:	24 8f       	std	Z+28, r18	; 0x1c
      }
    }
  }
 
  /* Swap port numbers. */
  tmp16 = BUF->srcport;
    31b4:	20 91 de 05 	lds	r18, 0x05DE
    31b8:	30 91 df 05 	lds	r19, 0x05DF
    31bc:	30 93 92 03 	sts	0x0392, r19
    31c0:	20 93 91 03 	sts	0x0391, r18
  BUF->srcport = BUF->destport;
    31c4:	80 91 e0 05 	lds	r24, 0x05E0
    31c8:	90 91 e1 05 	lds	r25, 0x05E1
    31cc:	f8 01       	movw	r30, r16
    31ce:	95 8b       	std	Z+21, r25	; 0x15
    31d0:	84 8b       	std	Z+20, r24	; 0x14
  BUF->destport = tmp16;
    31d2:	37 8b       	std	Z+23, r19	; 0x17
    31d4:	26 8b       	std	Z+22, r18	; 0x16
  
  /* Swap IP addresses. */
  uip_ipaddr_copy(BUF->destipaddr, BUF->srcipaddr);
    31d6:	80 91 d6 05 	lds	r24, 0x05D6
    31da:	90 91 d7 05 	lds	r25, 0x05D7
    31de:	90 93 db 05 	sts	0x05DB, r25
    31e2:	80 93 da 05 	sts	0x05DA, r24
    31e6:	80 91 d8 05 	lds	r24, 0x05D8
    31ea:	90 91 d9 05 	lds	r25, 0x05D9
    31ee:	90 93 dd 05 	sts	0x05DD, r25
    31f2:	80 93 dc 05 	sts	0x05DC, r24
  uip_ipaddr_copy(BUF->srcipaddr, uip_hostaddr);
    31f6:	80 91 b8 05 	lds	r24, 0x05B8
    31fa:	90 91 b9 05 	lds	r25, 0x05B9
    31fe:	90 93 d7 05 	sts	0x05D7, r25
    3202:	80 93 d6 05 	sts	0x05D6, r24
    3206:	80 91 ba 05 	lds	r24, 0x05BA
    320a:	90 91 bb 05 	lds	r25, 0x05BB
    320e:	90 93 d9 05 	sts	0x05D9, r25
    3212:	80 93 d8 05 	sts	0x05D8, r24
    3216:	0b c4       	rjmp	.+2070   	; 0x3a2e <uip_process+0xe00>
     unused ones have the tcpstate set to CLOSED. Also, connections in
     TIME_WAIT are kept track of and we'll use the oldest one if no
     CLOSED connections are found. Thanks to Eddie C. Dost for a very
     nice algorithm for the TIME_WAIT search. */
  uip_connr = 0;
  for(c = 0; c < UIP_CONNS; ++c) {
    3218:	10 92 8f 03 	sts	0x038F, r1
    321c:	c0 e0       	ldi	r28, 0x00	; 0
    321e:	d0 e0       	ldi	r29, 0x00	; 0
    3220:	40 e0       	ldi	r20, 0x00	; 0
    3222:	28 c0       	rjmp	.+80     	; 0x3274 <uip_process+0x646>
    if(uip_conns[c].tcpstateflags == UIP_CLOSED) {
    3224:	24 2f       	mov	r18, r20
    3226:	30 e0       	ldi	r19, 0x00	; 0
    3228:	8e e9       	ldi	r24, 0x9E	; 158
    322a:	90 e0       	ldi	r25, 0x00	; 0
    322c:	28 9f       	mul	r18, r24
    322e:	f0 01       	movw	r30, r0
    3230:	29 9f       	mul	r18, r25
    3232:	f0 0d       	add	r31, r0
    3234:	38 9f       	mul	r19, r24
    3236:	f0 0d       	add	r31, r0
    3238:	11 24       	eor	r1, r1
    323a:	ec 5b       	subi	r30, 0xBC	; 188
    323c:	fb 4f       	sbci	r31, 0xFB	; 251
    323e:	81 8d       	ldd	r24, Z+25	; 0x19
    3240:	88 23       	and	r24, r24
    3242:	49 f4       	brne	.+18     	; 0x3256 <uip_process+0x628>
    3244:	40 93 8f 03 	sts	0x038F, r20
      uip_connr = &uip_conns[c];
    3248:	8e e9       	ldi	r24, 0x9E	; 158
    324a:	48 9f       	mul	r20, r24
    324c:	e0 01       	movw	r28, r0
    324e:	11 24       	eor	r1, r1
    3250:	cc 5b       	subi	r28, 0xBC	; 188
    3252:	db 4f       	sbci	r29, 0xFB	; 251
    3254:	13 c0       	rjmp	.+38     	; 0x327c <uip_process+0x64e>
      break;
    }
    if(uip_conns[c].tcpstateflags == UIP_TIME_WAIT) {
    3256:	87 30       	cpi	r24, 0x07	; 7
    3258:	61 f4       	brne	.+24     	; 0x3272 <uip_process+0x644>
      if(uip_connr == 0 ||
    325a:	20 97       	sbiw	r28, 0x00	; 0
    325c:	21 f0       	breq	.+8      	; 0x3266 <uip_process+0x638>
    325e:	92 8d       	ldd	r25, Z+26	; 0x1a
    3260:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3262:	89 17       	cp	r24, r25
    3264:	30 f4       	brcc	.+12     	; 0x3272 <uip_process+0x644>
	 uip_conns[c].timer > uip_connr->timer) {
	uip_connr = &uip_conns[c];
    3266:	8e e9       	ldi	r24, 0x9E	; 158
    3268:	48 9f       	mul	r20, r24
    326a:	e0 01       	movw	r28, r0
    326c:	11 24       	eor	r1, r1
    326e:	cc 5b       	subi	r28, 0xBC	; 188
    3270:	db 4f       	sbci	r29, 0xFB	; 251
    3272:	4f 5f       	subi	r20, 0xFF	; 255
     unused ones have the tcpstate set to CLOSED. Also, connections in
     TIME_WAIT are kept track of and we'll use the oldest one if no
     CLOSED connections are found. Thanks to Eddie C. Dost for a very
     nice algorithm for the TIME_WAIT search. */
  uip_connr = 0;
  for(c = 0; c < UIP_CONNS; ++c) {
    3274:	42 30       	cpi	r20, 0x02	; 2
    3276:	b0 f2       	brcs	.-84     	; 0x3224 <uip_process+0x5f6>
    3278:	40 93 8f 03 	sts	0x038F, r20
	uip_connr = &uip_conns[c];
      }
    }
  }

  if(uip_connr == 0) {
    327c:	20 97       	sbiw	r28, 0x00	; 0
    327e:	61 f4       	brne	.+24     	; 0x3298 <uip_process+0x66a>
    /* All connections are used already, we drop packet and hope that
       the remote end will retransmit the packet at a time when we
       have more spare connections. */
    UIP_STAT(++uip_stat.tcp.syndrop);
    3280:	80 91 b0 05 	lds	r24, 0x05B0
    3284:	90 91 b1 05 	lds	r25, 0x05B1
    3288:	01 96       	adiw	r24, 0x01	; 1
    328a:	90 93 b1 05 	sts	0x05B1, r25
    328e:	80 93 b0 05 	sts	0x05B0, r24
    UIP_LOG("tcp: found no unused connections.");
    3292:	80 ec       	ldi	r24, 0xC0	; 192
    3294:	91 e0       	ldi	r25, 0x01	; 1
    3296:	c3 cd       	rjmp	.-1146   	; 0x2e1e <uip_process+0x1f0>
    goto drop;
  }
  uip_conn = uip_connr;
    3298:	d0 93 43 04 	sts	0x0443, r29
    329c:	c0 93 42 04 	sts	0x0442, r28
  
  /* Fill in the necessary fields for the new connection. */
  uip_connr->rto = uip_connr->timer = UIP_RTO;
    32a0:	83 e0       	ldi	r24, 0x03	; 3
    32a2:	8a 8f       	std	Y+26, r24	; 0x1a
    32a4:	88 8f       	std	Y+24, r24	; 0x18
  uip_connr->sa = 0;
    32a6:	1e 8a       	std	Y+22, r1	; 0x16
  uip_connr->sv = 4;
    32a8:	84 e0       	ldi	r24, 0x04	; 4
    32aa:	8f 8b       	std	Y+23, r24	; 0x17
  uip_connr->nrtx = 0;
    32ac:	1b 8e       	std	Y+27, r1	; 0x1b
  uip_connr->lport = BUF->destport;
    32ae:	80 91 e0 05 	lds	r24, 0x05E0
    32b2:	90 91 e1 05 	lds	r25, 0x05E1
    32b6:	9d 83       	std	Y+5, r25	; 0x05
    32b8:	8c 83       	std	Y+4, r24	; 0x04
  uip_connr->rport = BUF->srcport;
    32ba:	80 91 de 05 	lds	r24, 0x05DE
    32be:	90 91 df 05 	lds	r25, 0x05DF
    32c2:	9f 83       	std	Y+7, r25	; 0x07
    32c4:	8e 83       	std	Y+6, r24	; 0x06
  uip_ipaddr_copy(uip_connr->ripaddr, BUF->srcipaddr);
    32c6:	80 91 d6 05 	lds	r24, 0x05D6
    32ca:	90 91 d7 05 	lds	r25, 0x05D7
    32ce:	99 83       	std	Y+1, r25	; 0x01
    32d0:	88 83       	st	Y, r24
    32d2:	80 91 d8 05 	lds	r24, 0x05D8
    32d6:	90 91 d9 05 	lds	r25, 0x05D9
    32da:	9b 83       	std	Y+3, r25	; 0x03
    32dc:	8a 83       	std	Y+2, r24	; 0x02
  uip_connr->tcpstateflags = UIP_SYN_RCVD;
    32de:	81 e0       	ldi	r24, 0x01	; 1
    32e0:	89 8f       	std	Y+25, r24	; 0x19

  uip_connr->snd_nxt[0] = iss[0];
    32e2:	80 91 89 03 	lds	r24, 0x0389
    32e6:	8c 87       	std	Y+12, r24	; 0x0c
  uip_connr->snd_nxt[1] = iss[1];
    32e8:	80 91 8a 03 	lds	r24, 0x038A
    32ec:	8d 87       	std	Y+13, r24	; 0x0d
  uip_connr->snd_nxt[2] = iss[2];
    32ee:	80 91 8b 03 	lds	r24, 0x038B
    32f2:	8e 87       	std	Y+14, r24	; 0x0e
  uip_connr->snd_nxt[3] = iss[3];
    32f4:	80 91 8c 03 	lds	r24, 0x038C
    32f8:	8f 87       	std	Y+15, r24	; 0x0f
  uip_connr->len = 1;
    32fa:	81 e0       	ldi	r24, 0x01	; 1
    32fc:	90 e0       	ldi	r25, 0x00	; 0
    32fe:	99 8b       	std	Y+17, r25	; 0x11
    3300:	88 8b       	std	Y+16, r24	; 0x10

  /* rcv_nxt should be the seqno from the incoming packet + 1. */
  uip_connr->rcv_nxt[3] = BUF->seqno[3];
    3302:	80 91 e5 05 	lds	r24, 0x05E5
    3306:	8b 87       	std	Y+11, r24	; 0x0b
  uip_connr->rcv_nxt[2] = BUF->seqno[2];
    3308:	80 91 e4 05 	lds	r24, 0x05E4
    330c:	8a 87       	std	Y+10, r24	; 0x0a
  uip_connr->rcv_nxt[1] = BUF->seqno[1];
    330e:	80 91 e3 05 	lds	r24, 0x05E3
    3312:	89 87       	std	Y+9, r24	; 0x09
  uip_connr->rcv_nxt[0] = BUF->seqno[0];
    3314:	80 91 e2 05 	lds	r24, 0x05E2
    3318:	88 87       	std	Y+8, r24	; 0x08
  uip_add_rcv_nxt(1);
    331a:	81 e0       	ldi	r24, 0x01	; 1
    331c:	90 e0       	ldi	r25, 0x00	; 0
    331e:	0e 94 ca 15 	call	0x2b94	; 0x2b94 <uip_add_rcv_nxt>

  /* Parse the TCP MSS option, if present. */
  if((BUF->tcpoffset & 0xf0) > 0x50) {
    3322:	20 91 ea 05 	lds	r18, 0x05EA
    3326:	82 2f       	mov	r24, r18
    3328:	90 e0       	ldi	r25, 0x00	; 0
    332a:	80 7f       	andi	r24, 0xF0	; 240
    332c:	90 70       	andi	r25, 0x00	; 0
    332e:	81 35       	cpi	r24, 0x51	; 81
    3330:	91 05       	cpc	r25, r1
    3332:	0c f4       	brge	.+2      	; 0x3336 <uip_process+0x708>
    3334:	4e c0       	rjmp	.+156    	; 0x33d2 <uip_process+0x7a4>
    for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
    3336:	10 92 8f 03 	sts	0x038F, r1
    333a:	90 91 90 03 	lds	r25, 0x0390
    333e:	40 e0       	ldi	r20, 0x00	; 0
    3340:	22 95       	swap	r18
    3342:	2f 70       	andi	r18, 0x0F	; 15
    3344:	30 e0       	ldi	r19, 0x00	; 0
    3346:	25 50       	subi	r18, 0x05	; 5
    3348:	30 40       	sbci	r19, 0x00	; 0
    334a:	22 0f       	add	r18, r18
    334c:	33 1f       	adc	r19, r19
    334e:	22 0f       	add	r18, r18
    3350:	33 1f       	adc	r19, r19
    3352:	36 c0       	rjmp	.+108    	; 0x33c0 <uip_process+0x792>
      opt = uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + c];
    3354:	db 01       	movw	r26, r22
    3356:	a4 54       	subi	r26, 0x44	; 68
    3358:	ba 4f       	sbci	r27, 0xFA	; 250
    335a:	fd 01       	movw	r30, r26
    335c:	96 a9       	ldd	r25, Z+54	; 0x36
      if(opt == TCP_OPT_END) {
    335e:	99 23       	and	r25, r25
    3360:	19 f4       	brne	.+6      	; 0x3368 <uip_process+0x73a>
    3362:	10 92 90 03 	sts	0x0390, r1
    3366:	33 c0       	rjmp	.+102    	; 0x33ce <uip_process+0x7a0>
	/* End of options. */
	break;
      } else if(opt == TCP_OPT_NOOP) {
    3368:	91 30       	cpi	r25, 0x01	; 1
    336a:	11 f4       	brne	.+4      	; 0x3370 <uip_process+0x742>
	++c;
    336c:	4f 5f       	subi	r20, 0xFF	; 255
    336e:	28 c0       	rjmp	.+80     	; 0x33c0 <uip_process+0x792>
	/* NOP option. */
      } else if(opt == TCP_OPT_MSS &&
    3370:	92 30       	cpi	r25, 0x02	; 2
    3372:	f9 f4       	brne	.+62     	; 0x33b2 <uip_process+0x784>
    3374:	fd 01       	movw	r30, r26
    3376:	87 a9       	ldd	r24, Z+55	; 0x37
    3378:	84 30       	cpi	r24, 0x04	; 4
    337a:	d9 f4       	brne	.+54     	; 0x33b2 <uip_process+0x784>
    337c:	90 93 90 03 	sts	0x0390, r25
    3380:	40 93 8f 03 	sts	0x038F, r20
		uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
	/* An MSS option with the right option length. */
	tmp16 = ((u16_t)uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
    3384:	20 ad       	ldd	r18, Z+56	; 0x38
    3386:	30 e0       	ldi	r19, 0x00	; 0
    3388:	32 2f       	mov	r19, r18
    338a:	22 27       	eor	r18, r18
    338c:	81 ad       	ldd	r24, Z+57	; 0x39
    338e:	90 e0       	ldi	r25, 0x00	; 0
    3390:	28 2b       	or	r18, r24
    3392:	39 2b       	or	r19, r25
    3394:	30 93 92 03 	sts	0x0392, r19
    3398:	20 93 91 03 	sts	0x0391, r18
	  (u16_t)uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + 3 + c];
	uip_connr->initialmss = uip_connr->mss =
    339c:	f5 e0       	ldi	r31, 0x05	; 5
    339e:	27 3a       	cpi	r18, 0xA7	; 167
    33a0:	3f 07       	cpc	r19, r31
    33a2:	10 f0       	brcs	.+4      	; 0x33a8 <uip_process+0x77a>
    33a4:	26 ea       	ldi	r18, 0xA6	; 166
    33a6:	35 e0       	ldi	r19, 0x05	; 5
    33a8:	3b 8b       	std	Y+19, r19	; 0x13
    33aa:	2a 8b       	std	Y+18, r18	; 0x12
    33ac:	3d 8b       	std	Y+21, r19	; 0x15
    33ae:	2c 8b       	std	Y+20, r18	; 0x14
    33b0:	10 c0       	rjmp	.+32     	; 0x33d2 <uip_process+0x7a4>
	/* And we are done processing options. */
	break;
      } else {
	/* All other options have a length field, so that we easily
	   can skip past them. */
	if(uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0) {
    33b2:	64 54       	subi	r22, 0x44	; 68
    33b4:	7a 4f       	sbci	r23, 0xFA	; 250
    33b6:	fb 01       	movw	r30, r22
    33b8:	87 a9       	ldd	r24, Z+55	; 0x37
    33ba:	88 23       	and	r24, r24
    33bc:	31 f0       	breq	.+12     	; 0x33ca <uip_process+0x79c>
	  /* If the length field is zero, the options are malformed
	     and we don't process them further. */
	  break;
	}
	c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
    33be:	48 0f       	add	r20, r24
  uip_connr->rcv_nxt[0] = BUF->seqno[0];
  uip_add_rcv_nxt(1);

  /* Parse the TCP MSS option, if present. */
  if((BUF->tcpoffset & 0xf0) > 0x50) {
    for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
    33c0:	64 2f       	mov	r22, r20
    33c2:	70 e0       	ldi	r23, 0x00	; 0
    33c4:	62 17       	cp	r22, r18
    33c6:	73 07       	cpc	r23, r19
    33c8:	2c f2       	brlt	.-118    	; 0x3354 <uip_process+0x726>
    33ca:	90 93 90 03 	sts	0x0390, r25
    33ce:	40 93 8f 03 	sts	0x038F, r20
  }
  
  /* Our response will be a SYNACK. */
#if UIP_ACTIVE_OPEN
 tcp_send_synack:
  BUF->flags = TCP_ACK;
    33d2:	80 e1       	ldi	r24, 0x10	; 16
    33d4:	80 93 eb 05 	sts	0x05EB, r24
  
 tcp_send_syn:
  BUF->flags |= TCP_SYN;
    33d8:	80 91 eb 05 	lds	r24, 0x05EB
    33dc:	82 60       	ori	r24, 0x02	; 2
    33de:	80 93 eb 05 	sts	0x05EB, r24
  BUF->flags = TCP_SYN | TCP_ACK;
#endif /* UIP_ACTIVE_OPEN */
  
  /* We send out the TCP Maximum Segment Size option with our
     SYNACK. */
  BUF->optdata[0] = TCP_OPT_MSS;
    33e2:	82 e0       	ldi	r24, 0x02	; 2
    33e4:	80 93 f2 05 	sts	0x05F2, r24
  BUF->optdata[1] = TCP_OPT_MSS_LEN;
    33e8:	84 e0       	ldi	r24, 0x04	; 4
    33ea:	80 93 f3 05 	sts	0x05F3, r24
  BUF->optdata[2] = (UIP_TCP_MSS) / 256;
    33ee:	85 e0       	ldi	r24, 0x05	; 5
    33f0:	80 93 f4 05 	sts	0x05F4, r24
  BUF->optdata[3] = (UIP_TCP_MSS) & 255;
    33f4:	86 ea       	ldi	r24, 0xA6	; 166
    33f6:	80 93 f5 05 	sts	0x05F5, r24
  uip_len = UIP_IPTCPH_LEN + TCP_OPT_MSS_LEN;
    33fa:	8c e2       	ldi	r24, 0x2C	; 44
    33fc:	90 e0       	ldi	r25, 0x00	; 0
    33fe:	90 93 38 04 	sts	0x0438, r25
    3402:	80 93 37 04 	sts	0x0437, r24
  BUF->tcpoffset = ((UIP_TCPH_LEN + TCP_OPT_MSS_LEN) / 4) << 4;
    3406:	80 e6       	ldi	r24, 0x60	; 96
    3408:	bf c2       	rjmp	.+1406   	; 0x3988 <uip_process+0xd5a>
  goto tcp_send;
    340a:	c2 ee       	ldi	r28, 0xE2	; 226
    340c:	d4 e0       	ldi	r29, 0x04	; 4

  /* This label will be jumped to if we found an active connection. */
 found:
  uip_conn = uip_connr;
    340e:	d0 93 43 04 	sts	0x0443, r29
    3412:	c0 93 42 04 	sts	0x0442, r28
  uip_flags = 0;
    3416:	10 92 3f 04 	sts	0x043F, r1
  /* We do a very naive form of TCP reset processing; we just accept
     any RST and kill our connection. We should in fact check if the
     sequence number of this reset is wihtin our advertised window
     before we accept the reset. */
  if(BUF->flags & TCP_RST) {
    341a:	80 91 eb 05 	lds	r24, 0x05EB
    341e:	48 2f       	mov	r20, r24
    3420:	50 e0       	ldi	r21, 0x00	; 0
    3422:	82 ff       	sbrs	r24, 2
    3424:	07 c0       	rjmp	.+14     	; 0x3434 <uip_process+0x806>
    uip_connr->tcpstateflags = UIP_CLOSED;
    3426:	19 8e       	std	Y+25, r1	; 0x19
    UIP_LOG("tcp: got reset, aborting connection.");
    3428:	82 ee       	ldi	r24, 0xE2	; 226
    342a:	91 e0       	ldi	r25, 0x01	; 1
    342c:	0e 94 3f 0e 	call	0x1c7e	; 0x1c7e <uip_log>
    uip_flags = UIP_ABORT;
    3430:	80 e2       	ldi	r24, 0x20	; 32
    3432:	53 c2       	rjmp	.+1190   	; 0x38da <uip_process+0xcac>
    UIP_APPCALL();
    goto drop;
  }
  /* Calculated the length of the data, if the application has sent
     any data to us. */
  c = (BUF->tcpoffset >> 4) << 2;
    3434:	80 91 ea 05 	lds	r24, 0x05EA
    3438:	82 95       	swap	r24
    343a:	8f 70       	andi	r24, 0x0F	; 15
    343c:	88 0f       	add	r24, r24
    343e:	88 0f       	add	r24, r24
    3440:	80 93 8f 03 	sts	0x038F, r24
  /* uip_len will contain the length of the actual TCP data. This is
     calculated by subtracing the length of the TCP header (in
     c) and the length of the IP header (20 bytes). */
  uip_len = uip_len - c - UIP_IPH_LEN;
    3444:	20 91 37 04 	lds	r18, 0x0437
    3448:	30 91 38 04 	lds	r19, 0x0438
    344c:	28 1b       	sub	r18, r24
    344e:	31 09       	sbc	r19, r1
    3450:	24 51       	subi	r18, 0x14	; 20
    3452:	30 40       	sbci	r19, 0x00	; 0
    3454:	30 93 38 04 	sts	0x0438, r19
    3458:	20 93 37 04 	sts	0x0437, r18

  /* First, check if the sequence number of the incoming packet is
     what we're expecting next. If not, we send out an ACK with the
     correct numbers in. */
  if(!(((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_SENT) &&
    345c:	89 8d       	ldd	r24, Y+25	; 0x19
    345e:	8f 70       	andi	r24, 0x0F	; 15
    3460:	82 30       	cpi	r24, 0x02	; 2
    3462:	29 f4       	brne	.+10     	; 0x346e <uip_process+0x840>
    3464:	ca 01       	movw	r24, r20
    3466:	8f 73       	andi	r24, 0x3F	; 63
    3468:	90 70       	andi	r25, 0x00	; 0
    346a:	42 97       	sbiw	r24, 0x12	; 18
    346c:	f1 f0       	breq	.+60     	; 0x34aa <uip_process+0x87c>
       ((BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK)))) {
    if((uip_len > 0 || ((BUF->flags & (TCP_SYN | TCP_FIN)) != 0)) &&
    346e:	23 2b       	or	r18, r19
    3470:	21 f4       	brne	.+8      	; 0x347a <uip_process+0x84c>
    3472:	43 70       	andi	r20, 0x03	; 3
    3474:	50 70       	andi	r21, 0x00	; 0
    3476:	45 2b       	or	r20, r21
    3478:	c1 f0       	breq	.+48     	; 0x34aa <uip_process+0x87c>
    347a:	90 91 e2 05 	lds	r25, 0x05E2
    347e:	88 85       	ldd	r24, Y+8	; 0x08
    3480:	98 17       	cp	r25, r24
    3482:	09 f0       	breq	.+2      	; 0x3486 <uip_process+0x858>
    3484:	77 c2       	rjmp	.+1262   	; 0x3974 <uip_process+0xd46>
    3486:	90 91 e3 05 	lds	r25, 0x05E3
    348a:	89 85       	ldd	r24, Y+9	; 0x09
    348c:	98 17       	cp	r25, r24
    348e:	09 f0       	breq	.+2      	; 0x3492 <uip_process+0x864>
    3490:	71 c2       	rjmp	.+1250   	; 0x3974 <uip_process+0xd46>
    3492:	90 91 e4 05 	lds	r25, 0x05E4
    3496:	8a 85       	ldd	r24, Y+10	; 0x0a
    3498:	98 17       	cp	r25, r24
    349a:	09 f0       	breq	.+2      	; 0x349e <uip_process+0x870>
    349c:	6b c2       	rjmp	.+1238   	; 0x3974 <uip_process+0xd46>
    349e:	90 91 e5 05 	lds	r25, 0x05E5
    34a2:	8b 85       	ldd	r24, Y+11	; 0x0b
    34a4:	98 17       	cp	r25, r24
    34a6:	09 f0       	breq	.+2      	; 0x34aa <uip_process+0x87c>
    34a8:	65 c2       	rjmp	.+1226   	; 0x3974 <uip_process+0xd46>

  /* Next, check if the incoming segment acknowledges any outstanding
     data. If so, we update the sequence number, reset the length of
     the outstanding data, calculate RTT estimations, and reset the
     retransmission timer. */
  if((BUF->flags & TCP_ACK) && uip_outstanding(uip_connr)) {
    34aa:	80 91 eb 05 	lds	r24, 0x05EB
    34ae:	84 ff       	sbrs	r24, 4
    34b0:	51 c0       	rjmp	.+162    	; 0x3554 <uip_process+0x926>
    34b2:	68 89       	ldd	r22, Y+16	; 0x10
    34b4:	79 89       	ldd	r23, Y+17	; 0x11
    34b6:	61 15       	cp	r22, r1
    34b8:	71 05       	cpc	r23, r1
    34ba:	09 f4       	brne	.+2      	; 0x34be <uip_process+0x890>
    34bc:	4b c0       	rjmp	.+150    	; 0x3554 <uip_process+0x926>
    uip_add32(uip_connr->snd_nxt, uip_connr->len);
    34be:	ce 01       	movw	r24, r28
    34c0:	0c 96       	adiw	r24, 0x0c	; 12
    34c2:	0e 94 c0 14 	call	0x2980	; 0x2980 <uip_add32>

    if(BUF->ackno[0] == uip_acc32[0] &&
    34c6:	20 91 e6 05 	lds	r18, 0x05E6
    34ca:	80 91 3b 04 	lds	r24, 0x043B
    34ce:	28 17       	cp	r18, r24
    34d0:	09 f0       	breq	.+2      	; 0x34d4 <uip_process+0x8a6>
    34d2:	40 c0       	rjmp	.+128    	; 0x3554 <uip_process+0x926>
    34d4:	90 91 e7 05 	lds	r25, 0x05E7
    34d8:	80 91 3c 04 	lds	r24, 0x043C
    34dc:	98 17       	cp	r25, r24
    34de:	d1 f5       	brne	.+116    	; 0x3554 <uip_process+0x926>
    34e0:	90 91 e8 05 	lds	r25, 0x05E8
    34e4:	80 91 3d 04 	lds	r24, 0x043D
    34e8:	98 17       	cp	r25, r24
    34ea:	a1 f5       	brne	.+104    	; 0x3554 <uip_process+0x926>
    34ec:	90 91 e9 05 	lds	r25, 0x05E9
    34f0:	80 91 3e 04 	lds	r24, 0x043E
    34f4:	98 17       	cp	r25, r24
    34f6:	71 f5       	brne	.+92     	; 0x3554 <uip_process+0x926>
       BUF->ackno[1] == uip_acc32[1] &&
       BUF->ackno[2] == uip_acc32[2] &&
       BUF->ackno[3] == uip_acc32[3]) {
      /* Update sequence number. */
      uip_connr->snd_nxt[0] = uip_acc32[0];
    34f8:	2c 87       	std	Y+12, r18	; 0x0c
      uip_connr->snd_nxt[1] = uip_acc32[1];
    34fa:	80 91 3c 04 	lds	r24, 0x043C
    34fe:	8d 87       	std	Y+13, r24	; 0x0d
      uip_connr->snd_nxt[2] = uip_acc32[2];
    3500:	80 91 3d 04 	lds	r24, 0x043D
    3504:	8e 87       	std	Y+14, r24	; 0x0e
      uip_connr->snd_nxt[3] = uip_acc32[3];
    3506:	80 91 3e 04 	lds	r24, 0x043E
    350a:	8f 87       	std	Y+15, r24	; 0x0f
	

      /* Do RTT estimation, unless we have done retransmissions. */
      if(uip_connr->nrtx == 0) {
    350c:	8b 8d       	ldd	r24, Y+27	; 0x1b
    350e:	88 23       	and	r24, r24
    3510:	d1 f4       	brne	.+52     	; 0x3546 <uip_process+0x918>
	signed char m;
	m = uip_connr->rto - uip_connr->timer;
	/* This is taken directly from VJs original code in his paper */
	m = m - (uip_connr->sa >> 3);
    3512:	2e 89       	ldd	r18, Y+22	; 0x16
    3514:	98 8d       	ldd	r25, Y+24	; 0x18
    3516:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3518:	98 1b       	sub	r25, r24
    351a:	82 2f       	mov	r24, r18
    351c:	86 95       	lsr	r24
    351e:	86 95       	lsr	r24
    3520:	86 95       	lsr	r24
    3522:	98 1b       	sub	r25, r24
	uip_connr->sa += m;
    3524:	39 2f       	mov	r19, r25
    3526:	32 0f       	add	r19, r18
    3528:	3e 8b       	std	Y+22, r19	; 0x16
	if(m < 0) {
	  m = -m;
	}
	m = m - (uip_connr->sv >> 2);
    352a:	8f 89       	ldd	r24, Y+23	; 0x17
	uip_connr->sv += m;
    352c:	28 2f       	mov	r18, r24
    352e:	26 95       	lsr	r18
    3530:	26 95       	lsr	r18
    3532:	82 1b       	sub	r24, r18
    3534:	97 fd       	sbrc	r25, 7
    3536:	91 95       	neg	r25
    3538:	89 0f       	add	r24, r25
    353a:	8f 8b       	std	Y+23, r24	; 0x17
	uip_connr->rto = (uip_connr->sa >> 3) + uip_connr->sv;
    353c:	36 95       	lsr	r19
    353e:	36 95       	lsr	r19
    3540:	36 95       	lsr	r19
    3542:	83 0f       	add	r24, r19
    3544:	88 8f       	std	Y+24, r24	; 0x18

      }
      /* Set the acknowledged flag. */
      uip_flags = UIP_ACKDATA;
    3546:	81 e0       	ldi	r24, 0x01	; 1
    3548:	80 93 3f 04 	sts	0x043F, r24
      /* Reset the retransmission timer. */
      uip_connr->timer = uip_connr->rto;
    354c:	88 8d       	ldd	r24, Y+24	; 0x18
    354e:	8a 8f       	std	Y+26, r24	; 0x1a

      /* Reset length of outstanding data. */
      uip_connr->len = 0;
    3550:	19 8a       	std	Y+17, r1	; 0x11
    3552:	18 8a       	std	Y+16, r1	; 0x10
    }
    
  }

  /* Do different things depending on in what state the connection is. */
  switch(uip_connr->tcpstateflags & UIP_TS_MASK) {
    3554:	89 8d       	ldd	r24, Y+25	; 0x19
    3556:	28 2f       	mov	r18, r24
    3558:	30 e0       	ldi	r19, 0x00	; 0
    355a:	c9 01       	movw	r24, r18
    355c:	8f 70       	andi	r24, 0x0F	; 15
    355e:	90 70       	andi	r25, 0x00	; 0
    3560:	84 30       	cpi	r24, 0x04	; 4
    3562:	91 05       	cpc	r25, r1
    3564:	09 f4       	brne	.+2      	; 0x3568 <uip_process+0x93a>
    3566:	be c1       	rjmp	.+892    	; 0x38e4 <uip_process+0xcb6>
    3568:	85 30       	cpi	r24, 0x05	; 5
    356a:	91 05       	cpc	r25, r1
    356c:	5c f4       	brge	.+22     	; 0x3584 <uip_process+0x956>
    356e:	82 30       	cpi	r24, 0x02	; 2
    3570:	91 05       	cpc	r25, r1
    3572:	91 f1       	breq	.+100    	; 0x35d8 <uip_process+0x9aa>
    3574:	83 30       	cpi	r24, 0x03	; 3
    3576:	91 05       	cpc	r25, r1
    3578:	0c f0       	brlt	.+2      	; 0x357c <uip_process+0x94e>
    357a:	b7 c0       	rjmp	.+366    	; 0x36ea <uip_process+0xabc>
    357c:	01 97       	sbiw	r24, 0x01	; 1
    357e:	09 f0       	breq	.+2      	; 0x3582 <uip_process+0x954>
    3580:	ac c2       	rjmp	.+1368   	; 0x3ada <uip_process+0xeac>
    3582:	10 c0       	rjmp	.+32     	; 0x35a4 <uip_process+0x976>
    3584:	86 30       	cpi	r24, 0x06	; 6
    3586:	91 05       	cpc	r25, r1
    3588:	09 f4       	brne	.+2      	; 0x358c <uip_process+0x95e>
    358a:	ec c1       	rjmp	.+984    	; 0x3964 <uip_process+0xd36>
    358c:	86 30       	cpi	r24, 0x06	; 6
    358e:	91 05       	cpc	r25, r1
    3590:	0c f4       	brge	.+2      	; 0x3594 <uip_process+0x966>
    3592:	c8 c1       	rjmp	.+912    	; 0x3924 <uip_process+0xcf6>
    3594:	87 30       	cpi	r24, 0x07	; 7
    3596:	91 05       	cpc	r25, r1
    3598:	09 f4       	brne	.+2      	; 0x359c <uip_process+0x96e>
    359a:	ec c1       	rjmp	.+984    	; 0x3974 <uip_process+0xd46>
    359c:	08 97       	sbiw	r24, 0x08	; 8
    359e:	09 f0       	breq	.+2      	; 0x35a2 <uip_process+0x974>
    35a0:	9c c2       	rjmp	.+1336   	; 0x3ada <uip_process+0xeac>
    35a2:	95 c1       	rjmp	.+810    	; 0x38ce <uip_process+0xca0>
  case UIP_SYN_RCVD:
    /* In SYN_RCVD we have sent out a SYNACK in response to a SYN, and
       we are waiting for an ACK that acknowledges the data we sent
       out the last time. Therefore, we want to have the UIP_ACKDATA
       flag set. If so, we enter the ESTABLISHED state. */
    if(uip_flags & UIP_ACKDATA) {
    35a4:	80 91 3f 04 	lds	r24, 0x043F
    35a8:	80 ff       	sbrs	r24, 0
    35aa:	97 c2       	rjmp	.+1326   	; 0x3ada <uip_process+0xeac>
      uip_connr->tcpstateflags = UIP_ESTABLISHED;
    35ac:	83 e0       	ldi	r24, 0x03	; 3
    35ae:	89 8f       	std	Y+25, r24	; 0x19
      uip_flags = UIP_CONNECTED;
    35b0:	80 e4       	ldi	r24, 0x40	; 64
    35b2:	80 93 3f 04 	sts	0x043F, r24
      uip_connr->len = 0;
    35b6:	19 8a       	std	Y+17, r1	; 0x11
    35b8:	18 8a       	std	Y+16, r1	; 0x10
      if(uip_len > 0) {
    35ba:	20 91 37 04 	lds	r18, 0x0437
    35be:	30 91 38 04 	lds	r19, 0x0438
    35c2:	21 15       	cp	r18, r1
    35c4:	31 05       	cpc	r19, r1
    35c6:	09 f4       	brne	.+2      	; 0x35ca <uip_process+0x99c>
    35c8:	16 c1       	rjmp	.+556    	; 0x37f6 <uip_process+0xbc8>
        uip_flags |= UIP_NEWDATA;
    35ca:	82 e4       	ldi	r24, 0x42	; 66
    35cc:	80 93 3f 04 	sts	0x043F, r24
        uip_add_rcv_nxt(uip_len);
    35d0:	c9 01       	movw	r24, r18
    35d2:	0e 94 ca 15 	call	0x2b94	; 0x2b94 <uip_add_rcv_nxt>
    35d6:	0f c1       	rjmp	.+542    	; 0x37f6 <uip_process+0xbc8>
  case UIP_SYN_SENT:
    /* In SYN_SENT, we wait for a SYNACK that is sent in response to
       our SYN. The rcv_nxt is set to sequence number in the SYNACK
       plus one, and we send an ACK. We move into the ESTABLISHED
       state. */
    if((uip_flags & UIP_ACKDATA) &&
    35d8:	80 91 3f 04 	lds	r24, 0x043F
    35dc:	80 ff       	sbrs	r24, 0
    35de:	7a c0       	rjmp	.+244    	; 0x36d4 <uip_process+0xaa6>
    35e0:	80 91 eb 05 	lds	r24, 0x05EB
    35e4:	8f 73       	andi	r24, 0x3F	; 63
    35e6:	82 31       	cpi	r24, 0x12	; 18
    35e8:	09 f0       	breq	.+2      	; 0x35ec <uip_process+0x9be>
    35ea:	74 c0       	rjmp	.+232    	; 0x36d4 <uip_process+0xaa6>
       (BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK)) {

      /* Parse the TCP MSS option, if present. */
      if((BUF->tcpoffset & 0xf0) > 0x50) {
    35ec:	20 91 ea 05 	lds	r18, 0x05EA
    35f0:	82 2f       	mov	r24, r18
    35f2:	90 e0       	ldi	r25, 0x00	; 0
    35f4:	80 7f       	andi	r24, 0xF0	; 240
    35f6:	90 70       	andi	r25, 0x00	; 0
    35f8:	81 35       	cpi	r24, 0x51	; 81
    35fa:	91 05       	cpc	r25, r1
    35fc:	0c f4       	brge	.+2      	; 0x3600 <uip_process+0x9d2>
    35fe:	4e c0       	rjmp	.+156    	; 0x369c <uip_process+0xa6e>
	for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
    3600:	10 92 8f 03 	sts	0x038F, r1
    3604:	90 91 90 03 	lds	r25, 0x0390
    3608:	40 e0       	ldi	r20, 0x00	; 0
    360a:	22 95       	swap	r18
    360c:	2f 70       	andi	r18, 0x0F	; 15
    360e:	30 e0       	ldi	r19, 0x00	; 0
    3610:	25 50       	subi	r18, 0x05	; 5
    3612:	30 40       	sbci	r19, 0x00	; 0
    3614:	22 0f       	add	r18, r18
    3616:	33 1f       	adc	r19, r19
    3618:	22 0f       	add	r18, r18
    361a:	33 1f       	adc	r19, r19
    361c:	36 c0       	rjmp	.+108    	; 0x368a <uip_process+0xa5c>
	  opt = uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + c];
    361e:	db 01       	movw	r26, r22
    3620:	a4 54       	subi	r26, 0x44	; 68
    3622:	ba 4f       	sbci	r27, 0xFA	; 250
    3624:	fd 01       	movw	r30, r26
    3626:	96 a9       	ldd	r25, Z+54	; 0x36
	  if(opt == TCP_OPT_END) {
    3628:	99 23       	and	r25, r25
    362a:	19 f4       	brne	.+6      	; 0x3632 <uip_process+0xa04>
    362c:	10 92 90 03 	sts	0x0390, r1
    3630:	33 c0       	rjmp	.+102    	; 0x3698 <uip_process+0xa6a>
	    /* End of options. */
	    break;
	  } else if(opt == TCP_OPT_NOOP) {
    3632:	91 30       	cpi	r25, 0x01	; 1
    3634:	11 f4       	brne	.+4      	; 0x363a <uip_process+0xa0c>
	    ++c;
    3636:	4f 5f       	subi	r20, 0xFF	; 255
    3638:	28 c0       	rjmp	.+80     	; 0x368a <uip_process+0xa5c>
	    /* NOP option. */
	  } else if(opt == TCP_OPT_MSS &&
    363a:	92 30       	cpi	r25, 0x02	; 2
    363c:	f9 f4       	brne	.+62     	; 0x367c <uip_process+0xa4e>
    363e:	fd 01       	movw	r30, r26
    3640:	87 a9       	ldd	r24, Z+55	; 0x37
    3642:	84 30       	cpi	r24, 0x04	; 4
    3644:	d9 f4       	brne	.+54     	; 0x367c <uip_process+0xa4e>
    3646:	90 93 90 03 	sts	0x0390, r25
    364a:	40 93 8f 03 	sts	0x038F, r20
		    uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
	    /* An MSS option with the right option length. */
	    tmp16 = (uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
    364e:	20 ad       	ldd	r18, Z+56	; 0x38
    3650:	30 e0       	ldi	r19, 0x00	; 0
    3652:	32 2f       	mov	r19, r18
    3654:	22 27       	eor	r18, r18
    3656:	81 ad       	ldd	r24, Z+57	; 0x39
    3658:	90 e0       	ldi	r25, 0x00	; 0
    365a:	28 2b       	or	r18, r24
    365c:	39 2b       	or	r19, r25
    365e:	30 93 92 03 	sts	0x0392, r19
    3662:	20 93 91 03 	sts	0x0391, r18
	      uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 3 + c];
	    uip_connr->initialmss =
    3666:	f5 e0       	ldi	r31, 0x05	; 5
    3668:	27 3a       	cpi	r18, 0xA7	; 167
    366a:	3f 07       	cpc	r19, r31
    366c:	10 f0       	brcs	.+4      	; 0x3672 <uip_process+0xa44>
    366e:	26 ea       	ldi	r18, 0xA6	; 166
    3670:	35 e0       	ldi	r19, 0x05	; 5
    3672:	3b 8b       	std	Y+19, r19	; 0x13
    3674:	2a 8b       	std	Y+18, r18	; 0x12
    3676:	3d 8b       	std	Y+21, r19	; 0x15
    3678:	2c 8b       	std	Y+20, r18	; 0x14
    367a:	10 c0       	rjmp	.+32     	; 0x369c <uip_process+0xa6e>
	    /* And we are done processing options. */
	    break;
	  } else {
	    /* All other options have a length field, so that we easily
	       can skip past them. */
	    if(uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0) {
    367c:	64 54       	subi	r22, 0x44	; 68
    367e:	7a 4f       	sbci	r23, 0xFA	; 250
    3680:	fb 01       	movw	r30, r22
    3682:	87 a9       	ldd	r24, Z+55	; 0x37
    3684:	88 23       	and	r24, r24
    3686:	31 f0       	breq	.+12     	; 0x3694 <uip_process+0xa66>
	      /* If the length field is zero, the options are malformed
		 and we don't process them further. */
	      break;
	    }
	    c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
    3688:	48 0f       	add	r20, r24
    if((uip_flags & UIP_ACKDATA) &&
       (BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK)) {

      /* Parse the TCP MSS option, if present. */
      if((BUF->tcpoffset & 0xf0) > 0x50) {
	for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
    368a:	64 2f       	mov	r22, r20
    368c:	70 e0       	ldi	r23, 0x00	; 0
    368e:	62 17       	cp	r22, r18
    3690:	73 07       	cpc	r23, r19
    3692:	2c f2       	brlt	.-118    	; 0x361e <uip_process+0x9f0>
    3694:	90 93 90 03 	sts	0x0390, r25
    3698:	40 93 8f 03 	sts	0x038F, r20
	    }
	    c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
	  }
	}
      }
      uip_connr->tcpstateflags = UIP_ESTABLISHED;
    369c:	83 e0       	ldi	r24, 0x03	; 3
    369e:	89 8f       	std	Y+25, r24	; 0x19
      uip_connr->rcv_nxt[0] = BUF->seqno[0];
    36a0:	80 91 e2 05 	lds	r24, 0x05E2
    36a4:	88 87       	std	Y+8, r24	; 0x08
      uip_connr->rcv_nxt[1] = BUF->seqno[1];
    36a6:	80 91 e3 05 	lds	r24, 0x05E3
    36aa:	89 87       	std	Y+9, r24	; 0x09
      uip_connr->rcv_nxt[2] = BUF->seqno[2];
    36ac:	80 91 e4 05 	lds	r24, 0x05E4
    36b0:	8a 87       	std	Y+10, r24	; 0x0a
      uip_connr->rcv_nxt[3] = BUF->seqno[3];
    36b2:	80 91 e5 05 	lds	r24, 0x05E5
    36b6:	8b 87       	std	Y+11, r24	; 0x0b
      uip_add_rcv_nxt(1);
    36b8:	81 e0       	ldi	r24, 0x01	; 1
    36ba:	90 e0       	ldi	r25, 0x00	; 0
    36bc:	0e 94 ca 15 	call	0x2b94	; 0x2b94 <uip_add_rcv_nxt>
      uip_flags = UIP_CONNECTED | UIP_NEWDATA;
    36c0:	82 e4       	ldi	r24, 0x42	; 66
    36c2:	80 93 3f 04 	sts	0x043F, r24
      uip_connr->len = 0;
    36c6:	19 8a       	std	Y+17, r1	; 0x11
    36c8:	18 8a       	std	Y+16, r1	; 0x10
      uip_len = 0;
    36ca:	10 92 38 04 	sts	0x0438, r1
    36ce:	10 92 37 04 	sts	0x0437, r1
    36d2:	91 c0       	rjmp	.+290    	; 0x37f6 <uip_process+0xbc8>
      uip_slen = 0;
      UIP_APPCALL();
      goto appsend;
    }
    /* Inform the application that the connection failed */
    uip_flags = UIP_ABORT;
    36d4:	80 e2       	ldi	r24, 0x20	; 32
    36d6:	80 93 3f 04 	sts	0x043F, r24
    UIP_APPCALL();
    36da:	0e 94 c6 27 	call	0x4f8c	; 0x4f8c <httpd_appcall>
    /* The connection is closed after we send the RST */
    uip_conn->tcpstateflags = UIP_CLOSED;
    36de:	e0 91 42 04 	lds	r30, 0x0442
    36e2:	f0 91 43 04 	lds	r31, 0x0443
    36e6:	11 8e       	std	Z+25, r1	; 0x19
    36e8:	24 cd       	rjmp	.-1464   	; 0x3132 <uip_process+0x504>
    If the incoming packet is a FIN, we should close the connection on
    this side as well, and we send out a FIN and enter the LAST_ACK
    state. We require that there is no outstanding data; otherwise the
    sequence numbers will be screwed up. */

    if(BUF->flags & TCP_FIN && !(uip_connr->tcpstateflags & UIP_STOPPED)) {
    36ea:	80 91 eb 05 	lds	r24, 0x05EB
    36ee:	80 ff       	sbrs	r24, 0
    36f0:	2a c0       	rjmp	.+84     	; 0x3746 <uip_process+0xb18>
    36f2:	24 fd       	sbrc	r18, 4
    36f4:	28 c0       	rjmp	.+80     	; 0x3746 <uip_process+0xb18>
      if(uip_outstanding(uip_connr)) {
    36f6:	88 89       	ldd	r24, Y+16	; 0x10
    36f8:	99 89       	ldd	r25, Y+17	; 0x11
    36fa:	89 2b       	or	r24, r25
    36fc:	09 f0       	breq	.+2      	; 0x3700 <uip_process+0xad2>
    36fe:	ed c1       	rjmp	.+986    	; 0x3ada <uip_process+0xeac>
	goto drop;
      }
      uip_add_rcv_nxt(1 + uip_len);
    3700:	80 91 37 04 	lds	r24, 0x0437
    3704:	90 91 38 04 	lds	r25, 0x0438
    3708:	01 96       	adiw	r24, 0x01	; 1
    370a:	0e 94 ca 15 	call	0x2b94	; 0x2b94 <uip_add_rcv_nxt>
      uip_flags |= UIP_CLOSE;
    370e:	20 91 3f 04 	lds	r18, 0x043F
    3712:	82 2f       	mov	r24, r18
    3714:	80 61       	ori	r24, 0x10	; 16
    3716:	80 93 3f 04 	sts	0x043F, r24
      if(uip_len > 0) {
    371a:	80 91 37 04 	lds	r24, 0x0437
    371e:	90 91 38 04 	lds	r25, 0x0438
    3722:	89 2b       	or	r24, r25
    3724:	19 f0       	breq	.+6      	; 0x372c <uip_process+0xafe>
	uip_flags |= UIP_NEWDATA;
    3726:	22 61       	ori	r18, 0x12	; 18
    3728:	20 93 3f 04 	sts	0x043F, r18
      }
      UIP_APPCALL();
    372c:	0e 94 c6 27 	call	0x4f8c	; 0x4f8c <httpd_appcall>
      uip_connr->len = 1;
    3730:	81 e0       	ldi	r24, 0x01	; 1
    3732:	90 e0       	ldi	r25, 0x00	; 0
    3734:	99 8b       	std	Y+17, r25	; 0x11
    3736:	88 8b       	std	Y+16, r24	; 0x10
      uip_connr->tcpstateflags = UIP_LAST_ACK;
    3738:	88 e0       	ldi	r24, 0x08	; 8
    373a:	89 8f       	std	Y+25, r24	; 0x19
      uip_connr->nrtx = 0;
    373c:	1b 8e       	std	Y+27, r1	; 0x1b
    tcp_send_finack:
      BUF->flags = TCP_FIN | TCP_ACK;
    373e:	81 e1       	ldi	r24, 0x11	; 17
    3740:	80 93 eb 05 	sts	0x05EB, r24
    3744:	1a c1       	rjmp	.+564    	; 0x397a <uip_process+0xd4c>
      goto tcp_send_nodata;
    }

    /* Check the URG flag. If this is set, the segment carries urgent
       data that we must pass to the application. */
    if((BUF->flags & TCP_URG) != 0) {
    3746:	85 ff       	sbrs	r24, 5
    3748:	1e c0       	rjmp	.+60     	; 0x3786 <uip_process+0xb58>
      uip_urgdata = uip_appdata;
      uip_appdata += uip_urglen;
    } else {
      uip_urglen = 0;
#else /* UIP_URGDATA > 0 */
      uip_appdata = ((char *)uip_appdata) + ((BUF->urgp[0] << 8) | BUF->urgp[1]);
    374a:	20 91 f0 05 	lds	r18, 0x05F0
    374e:	30 e0       	ldi	r19, 0x00	; 0
    3750:	32 2f       	mov	r19, r18
    3752:	22 27       	eor	r18, r18
    3754:	80 91 f1 05 	lds	r24, 0x05F1
    3758:	90 e0       	ldi	r25, 0x00	; 0
    375a:	28 2b       	or	r18, r24
    375c:	39 2b       	or	r19, r25
    375e:	80 91 40 04 	lds	r24, 0x0440
    3762:	90 91 41 04 	lds	r25, 0x0441
    3766:	82 0f       	add	r24, r18
    3768:	93 1f       	adc	r25, r19
    376a:	90 93 41 04 	sts	0x0441, r25
    376e:	80 93 40 04 	sts	0x0440, r24
      uip_len -= (BUF->urgp[0] << 8) | BUF->urgp[1];
    3772:	80 91 37 04 	lds	r24, 0x0437
    3776:	90 91 38 04 	lds	r25, 0x0438
    377a:	82 1b       	sub	r24, r18
    377c:	93 0b       	sbc	r25, r19
    377e:	90 93 38 04 	sts	0x0438, r25
    3782:	80 93 37 04 	sts	0x0437, r24
    /* If uip_len > 0 we have TCP data in the packet, and we flag this
       by setting the UIP_NEWDATA flag and update the sequence number
       we acknowledge. If the application has stopped the dataflow
       using uip_stop(), we must not accept any data packets from the
       remote host. */
    if(uip_len > 0 && !(uip_connr->tcpstateflags & UIP_STOPPED)) {
    3786:	20 91 37 04 	lds	r18, 0x0437
    378a:	30 91 38 04 	lds	r19, 0x0438
    378e:	21 15       	cp	r18, r1
    3790:	31 05       	cpc	r19, r1
    3792:	59 f0       	breq	.+22     	; 0x37aa <uip_process+0xb7c>
    3794:	89 8d       	ldd	r24, Y+25	; 0x19
    3796:	84 fd       	sbrc	r24, 4
    3798:	08 c0       	rjmp	.+16     	; 0x37aa <uip_process+0xb7c>
      uip_flags |= UIP_NEWDATA;
    379a:	80 91 3f 04 	lds	r24, 0x043F
    379e:	82 60       	ori	r24, 0x02	; 2
    37a0:	80 93 3f 04 	sts	0x043F, r24
      uip_add_rcv_nxt(uip_len);
    37a4:	c9 01       	movw	r24, r18
    37a6:	0e 94 ca 15 	call	0x2b94	; 0x2b94 <uip_add_rcv_nxt>
       the initial MSS so that the application will send an entire MSS
       of data. This data will not be acknowledged by the receiver,
       and the application will retransmit it. This is called the
       "persistent timer" and uses the retransmission mechanim.
    */
    tmp16 = ((u16_t)BUF->wnd[0] << 8) + (u16_t)BUF->wnd[1];
    37aa:	80 91 ec 05 	lds	r24, 0x05EC
    37ae:	90 e0       	ldi	r25, 0x00	; 0
    37b0:	38 2f       	mov	r19, r24
    37b2:	22 27       	eor	r18, r18
    37b4:	80 91 ed 05 	lds	r24, 0x05ED
    37b8:	28 0f       	add	r18, r24
    37ba:	31 1d       	adc	r19, r1
    37bc:	30 93 92 03 	sts	0x0392, r19
    37c0:	20 93 91 03 	sts	0x0391, r18
    if(tmp16 > uip_connr->initialmss ||
    37c4:	8c 89       	ldd	r24, Y+20	; 0x14
    37c6:	9d 89       	ldd	r25, Y+21	; 0x15
    37c8:	82 17       	cp	r24, r18
    37ca:	93 07       	cpc	r25, r19
    37cc:	10 f0       	brcs	.+4      	; 0x37d2 <uip_process+0xba4>
    37ce:	23 2b       	or	r18, r19
    37d0:	21 f4       	brne	.+8      	; 0x37da <uip_process+0xbac>
       tmp16 == 0) {
      tmp16 = uip_connr->initialmss;
    37d2:	90 93 92 03 	sts	0x0392, r25
    37d6:	80 93 91 03 	sts	0x0391, r24
    }
    uip_connr->mss = tmp16;
    37da:	80 91 91 03 	lds	r24, 0x0391
    37de:	90 91 92 03 	lds	r25, 0x0392
    37e2:	9b 8b       	std	Y+19, r25	; 0x13
    37e4:	8a 8b       	std	Y+18, r24	; 0x12

       If the application wishes to send any data, this data should be
       put into the uip_appdata and the length of the data should be
       put into uip_len. If the application don't have any data to
       send, uip_len must be set to 0. */
    if(uip_flags & (UIP_NEWDATA | UIP_ACKDATA)) {
    37e6:	80 91 3f 04 	lds	r24, 0x043F
    37ea:	90 e0       	ldi	r25, 0x00	; 0
    37ec:	83 70       	andi	r24, 0x03	; 3
    37ee:	90 70       	andi	r25, 0x00	; 0
    37f0:	89 2b       	or	r24, r25
    37f2:	09 f4       	brne	.+2      	; 0x37f6 <uip_process+0xbc8>
    37f4:	72 c1       	rjmp	.+740    	; 0x3ada <uip_process+0xeac>
      uip_slen = 0;
    37f6:	10 92 9b 0b 	sts	0x0B9B, r1
    37fa:	10 92 9a 0b 	sts	0x0B9A, r1
      UIP_APPCALL();
    37fe:	0e 94 c6 27 	call	0x4f8c	; 0x4f8c <httpd_appcall>

    appsend:
      
      if(uip_flags & UIP_ABORT) {
    3802:	80 91 3f 04 	lds	r24, 0x043F
    3806:	28 2f       	mov	r18, r24
    3808:	85 ff       	sbrs	r24, 5
    380a:	07 c0       	rjmp	.+14     	; 0x381a <uip_process+0xbec>
	uip_slen = 0;
    380c:	10 92 9b 0b 	sts	0x0B9B, r1
    3810:	10 92 9a 0b 	sts	0x0B9A, r1
	uip_connr->tcpstateflags = UIP_CLOSED;
    3814:	19 8e       	std	Y+25, r1	; 0x19
	BUF->flags = TCP_RST | TCP_ACK;
    3816:	84 e1       	ldi	r24, 0x14	; 20
    3818:	93 cf       	rjmp	.-218    	; 0x3740 <uip_process+0xb12>
	goto tcp_send_nodata;
      }

      if(uip_flags & UIP_CLOSE) {
    381a:	84 ff       	sbrs	r24, 4
    381c:	0a c0       	rjmp	.+20     	; 0x3832 <uip_process+0xc04>
	uip_slen = 0;
    381e:	10 92 9b 0b 	sts	0x0B9B, r1
    3822:	10 92 9a 0b 	sts	0x0B9A, r1
	uip_connr->len = 1;
    3826:	81 e0       	ldi	r24, 0x01	; 1
    3828:	90 e0       	ldi	r25, 0x00	; 0
    382a:	99 8b       	std	Y+17, r25	; 0x11
    382c:	88 8b       	std	Y+16, r24	; 0x10
	uip_connr->tcpstateflags = UIP_FIN_WAIT_1;
    382e:	84 e0       	ldi	r24, 0x04	; 4
    3830:	84 cf       	rjmp	.-248    	; 0x373a <uip_process+0xb0c>
	BUF->flags = TCP_FIN | TCP_ACK;
	goto tcp_send_nodata;
      }

      /* If uip_slen > 0, the application has data to be sent. */
      if(uip_slen > 0) {
    3832:	80 91 9a 0b 	lds	r24, 0x0B9A
    3836:	90 91 9b 0b 	lds	r25, 0x0B9B
    383a:	89 2b       	or	r24, r25
    383c:	01 f1       	breq	.+64     	; 0x387e <uip_process+0xc50>

	/* If the connection has acknowledged data, the contents of
	   the ->len variable should be discarded. */
	if((uip_flags & UIP_ACKDATA) != 0) {
    383e:	20 ff       	sbrs	r18, 0
    3840:	02 c0       	rjmp	.+4      	; 0x3846 <uip_process+0xc18>
	  uip_connr->len = 0;
    3842:	19 8a       	std	Y+17, r1	; 0x11
    3844:	18 8a       	std	Y+16, r1	; 0x10
	}

	/* If the ->len variable is non-zero the connection has
	   already data in transit and cannot send anymore right
	   now. */
	if(uip_connr->len == 0) {
    3846:	88 89       	ldd	r24, Y+16	; 0x10
    3848:	99 89       	ldd	r25, Y+17	; 0x11
    384a:	00 97       	sbiw	r24, 0x00	; 0
    384c:	a1 f4       	brne	.+40     	; 0x3876 <uip_process+0xc48>

	  /* The application cannot send more than what is allowed by
	     the mss (the minumum of the MSS and the available
	     window). */
	  if(uip_slen > uip_connr->mss) {
    384e:	2a 89       	ldd	r18, Y+18	; 0x12
    3850:	3b 89       	ldd	r19, Y+19	; 0x13
    3852:	80 91 9a 0b 	lds	r24, 0x0B9A
    3856:	90 91 9b 0b 	lds	r25, 0x0B9B
    385a:	28 17       	cp	r18, r24
    385c:	39 07       	cpc	r19, r25
    385e:	20 f4       	brcc	.+8      	; 0x3868 <uip_process+0xc3a>
	    uip_slen = uip_connr->mss;
    3860:	30 93 9b 0b 	sts	0x0B9B, r19
    3864:	20 93 9a 0b 	sts	0x0B9A, r18
	  }

	  /* Remember how much data we send out now so that we know
	     when everything has been acknowledged. */
	  uip_connr->len = uip_slen;
    3868:	80 91 9a 0b 	lds	r24, 0x0B9A
    386c:	90 91 9b 0b 	lds	r25, 0x0B9B
    3870:	99 8b       	std	Y+17, r25	; 0x11
    3872:	88 8b       	std	Y+16, r24	; 0x10
    3874:	04 c0       	rjmp	.+8      	; 0x387e <uip_process+0xc50>
	} else {

	  /* If the application already had unacknowledged data, we
	     make sure that the application does not send (i.e.,
	     retransmit) out more than it previously sent out. */
	  uip_slen = uip_connr->len;
    3876:	90 93 9b 0b 	sts	0x0B9B, r25
    387a:	80 93 9a 0b 	sts	0x0B9A, r24
	}
      }
      uip_connr->nrtx = 0;
    387e:	1b 8e       	std	Y+27, r1	; 0x1b
    apprexmit:
      uip_appdata = uip_sappdata;
    3880:	80 91 39 04 	lds	r24, 0x0439
    3884:	90 91 3a 04 	lds	r25, 0x043A
    3888:	90 93 41 04 	sts	0x0441, r25
    388c:	80 93 40 04 	sts	0x0440, r24
      
      /* If the application has data to be sent, or if the incoming
         packet had new data in it, we must send out a packet. */
      if(uip_slen > 0 && uip_connr->len > 0) {
    3890:	80 91 9a 0b 	lds	r24, 0x0B9A
    3894:	90 91 9b 0b 	lds	r25, 0x0B9B
    3898:	89 2b       	or	r24, r25
    389a:	59 f0       	breq	.+22     	; 0x38b2 <uip_process+0xc84>
    389c:	88 89       	ldd	r24, Y+16	; 0x10
    389e:	99 89       	ldd	r25, Y+17	; 0x11
    38a0:	00 97       	sbiw	r24, 0x00	; 0
    38a2:	39 f0       	breq	.+14     	; 0x38b2 <uip_process+0xc84>
	/* Add the length of the IP and TCP headers. */
	uip_len = uip_connr->len + UIP_TCPIP_HLEN;
    38a4:	88 96       	adiw	r24, 0x28	; 40
    38a6:	90 93 38 04 	sts	0x0438, r25
    38aa:	80 93 37 04 	sts	0x0437, r24
	/* We always set the ACK flag in response packets. */
	BUF->flags = TCP_ACK | TCP_PSH;
    38ae:	88 e1       	ldi	r24, 0x18	; 24
    38b0:	0b c0       	rjmp	.+22     	; 0x38c8 <uip_process+0xc9a>
	/* Send the packet. */
	goto tcp_send_noopts;
      }
      /* If there is no data to send, just send out a pure ACK if
	 there is newdata. */
      if(uip_flags & UIP_NEWDATA) {
    38b2:	80 91 3f 04 	lds	r24, 0x043F
    38b6:	81 ff       	sbrs	r24, 1
    38b8:	10 c1       	rjmp	.+544    	; 0x3ada <uip_process+0xeac>
	uip_len = UIP_TCPIP_HLEN;
    38ba:	88 e2       	ldi	r24, 0x28	; 40
    38bc:	90 e0       	ldi	r25, 0x00	; 0
    38be:	90 93 38 04 	sts	0x0438, r25
    38c2:	80 93 37 04 	sts	0x0437, r24
	BUF->flags = TCP_ACK;
    38c6:	80 e1       	ldi	r24, 0x10	; 16
    38c8:	80 93 eb 05 	sts	0x05EB, r24
    38cc:	5c c0       	rjmp	.+184    	; 0x3986 <uip_process+0xd58>
    }
    goto drop;
  case UIP_LAST_ACK:
    /* We can close this connection if the peer has acknowledged our
       FIN. This is indicated by the UIP_ACKDATA flag. */
    if(uip_flags & UIP_ACKDATA) {
    38ce:	80 91 3f 04 	lds	r24, 0x043F
    38d2:	80 ff       	sbrs	r24, 0
    38d4:	02 c1       	rjmp	.+516    	; 0x3ada <uip_process+0xeac>
      uip_connr->tcpstateflags = UIP_CLOSED;
    38d6:	19 8e       	std	Y+25, r1	; 0x19
      uip_flags = UIP_CLOSE;
    38d8:	80 e1       	ldi	r24, 0x10	; 16
    38da:	80 93 3f 04 	sts	0x043F, r24
      UIP_APPCALL();
    38de:	0e 94 c6 27 	call	0x4f8c	; 0x4f8c <httpd_appcall>
    38e2:	fb c0       	rjmp	.+502    	; 0x3ada <uip_process+0xeac>
    
  case UIP_FIN_WAIT_1:
    /* The application has closed the connection, but the remote host
       hasn't closed its end yet. Thus we do nothing but wait for a
       FIN from the other side. */
    if(uip_len > 0) {
    38e4:	80 91 37 04 	lds	r24, 0x0437
    38e8:	90 91 38 04 	lds	r25, 0x0438
    38ec:	00 97       	sbiw	r24, 0x00	; 0
    38ee:	11 f0       	breq	.+4      	; 0x38f4 <uip_process+0xcc6>
      uip_add_rcv_nxt(uip_len);
    38f0:	0e 94 ca 15 	call	0x2b94	; 0x2b94 <uip_add_rcv_nxt>
    }
    if(BUF->flags & TCP_FIN) {
    38f4:	80 91 eb 05 	lds	r24, 0x05EB
    38f8:	90 91 3f 04 	lds	r25, 0x043F
    38fc:	80 ff       	sbrs	r24, 0
    38fe:	0b c0       	rjmp	.+22     	; 0x3916 <uip_process+0xce8>
      if(uip_flags & UIP_ACKDATA) {
    3900:	90 ff       	sbrs	r25, 0
    3902:	06 c0       	rjmp	.+12     	; 0x3910 <uip_process+0xce2>
	uip_connr->tcpstateflags = UIP_TIME_WAIT;
    3904:	87 e0       	ldi	r24, 0x07	; 7
    3906:	89 8f       	std	Y+25, r24	; 0x19
	uip_connr->timer = 0;
    3908:	1a 8e       	std	Y+26, r1	; 0x1a
	uip_connr->len = 0;
    390a:	19 8a       	std	Y+17, r1	; 0x11
    390c:	18 8a       	std	Y+16, r1	; 0x10
    390e:	19 c0       	rjmp	.+50     	; 0x3942 <uip_process+0xd14>
      } else {
	uip_connr->tcpstateflags = UIP_CLOSING;
    3910:	86 e0       	ldi	r24, 0x06	; 6
    3912:	89 8f       	std	Y+25, r24	; 0x19
    3914:	16 c0       	rjmp	.+44     	; 0x3942 <uip_process+0xd14>
      }
      uip_add_rcv_nxt(1);
      uip_flags = UIP_CLOSE;
      UIP_APPCALL();
      goto tcp_send_ack;
    } else if(uip_flags & UIP_ACKDATA) {
    3916:	90 ff       	sbrs	r25, 0
    3918:	1e c0       	rjmp	.+60     	; 0x3956 <uip_process+0xd28>
      uip_connr->tcpstateflags = UIP_FIN_WAIT_2;
    391a:	85 e0       	ldi	r24, 0x05	; 5
    391c:	89 8f       	std	Y+25, r24	; 0x19
      uip_connr->len = 0;
    391e:	19 8a       	std	Y+17, r1	; 0x11
    3920:	18 8a       	std	Y+16, r1	; 0x10
    3922:	db c0       	rjmp	.+438    	; 0x3ada <uip_process+0xeac>
      goto tcp_send_ack;
    }
    goto drop;
      
  case UIP_FIN_WAIT_2:
    if(uip_len > 0) {
    3924:	80 91 37 04 	lds	r24, 0x0437
    3928:	90 91 38 04 	lds	r25, 0x0438
    392c:	00 97       	sbiw	r24, 0x00	; 0
    392e:	11 f0       	breq	.+4      	; 0x3934 <uip_process+0xd06>
      uip_add_rcv_nxt(uip_len);
    3930:	0e 94 ca 15 	call	0x2b94	; 0x2b94 <uip_add_rcv_nxt>
    }
    if(BUF->flags & TCP_FIN) {
    3934:	80 91 eb 05 	lds	r24, 0x05EB
    3938:	80 ff       	sbrs	r24, 0
    393a:	0d c0       	rjmp	.+26     	; 0x3956 <uip_process+0xd28>
      uip_connr->tcpstateflags = UIP_TIME_WAIT;
    393c:	87 e0       	ldi	r24, 0x07	; 7
    393e:	89 8f       	std	Y+25, r24	; 0x19
      uip_connr->timer = 0;
    3940:	1a 8e       	std	Y+26, r1	; 0x1a
      uip_add_rcv_nxt(1);
    3942:	81 e0       	ldi	r24, 0x01	; 1
    3944:	90 e0       	ldi	r25, 0x00	; 0
    3946:	0e 94 ca 15 	call	0x2b94	; 0x2b94 <uip_add_rcv_nxt>
      uip_flags = UIP_CLOSE;
    394a:	80 e1       	ldi	r24, 0x10	; 16
    394c:	80 93 3f 04 	sts	0x043F, r24
      UIP_APPCALL();
    3950:	0e 94 c6 27 	call	0x4f8c	; 0x4f8c <httpd_appcall>
    3954:	0f c0       	rjmp	.+30     	; 0x3974 <uip_process+0xd46>
      goto tcp_send_ack;
    }
    if(uip_len > 0) {
    3956:	80 91 37 04 	lds	r24, 0x0437
    395a:	90 91 38 04 	lds	r25, 0x0438
    395e:	89 2b       	or	r24, r25
    3960:	49 f4       	brne	.+18     	; 0x3974 <uip_process+0xd46>
    3962:	bb c0       	rjmp	.+374    	; 0x3ada <uip_process+0xeac>

  case UIP_TIME_WAIT:
    goto tcp_send_ack;
    
  case UIP_CLOSING:
    if(uip_flags & UIP_ACKDATA) {
    3964:	80 91 3f 04 	lds	r24, 0x043F
    3968:	80 ff       	sbrs	r24, 0
    396a:	b7 c0       	rjmp	.+366    	; 0x3ada <uip_process+0xeac>
      uip_connr->tcpstateflags = UIP_TIME_WAIT;
    396c:	87 e0       	ldi	r24, 0x07	; 7
    396e:	89 8f       	std	Y+25, r24	; 0x19
      uip_connr->timer = 0;
    3970:	1a 8e       	std	Y+26, r1	; 0x1a
    3972:	b3 c0       	rjmp	.+358    	; 0x3ada <uip_process+0xeac>
  

  /* We jump here when we are ready to send the packet, and just want
     to set the appropriate TCP sequence numbers in the TCP header. */
 tcp_send_ack:
  BUF->flags = TCP_ACK;
    3974:	80 e1       	ldi	r24, 0x10	; 16
    3976:	f8 01       	movw	r30, r16
    3978:	81 a3       	std	Z+33, r24	; 0x21
 tcp_send_nodata:
  uip_len = UIP_IPTCPH_LEN;
    397a:	88 e2       	ldi	r24, 0x28	; 40
    397c:	90 e0       	ldi	r25, 0x00	; 0
    397e:	90 93 38 04 	sts	0x0438, r25
    3982:	80 93 37 04 	sts	0x0437, r24
 tcp_send_noopts:
  BUF->tcpoffset = (UIP_TCPH_LEN / 4) << 4;
    3986:	80 e5       	ldi	r24, 0x50	; 80
    3988:	80 93 ea 05 	sts	0x05EA, r24
 tcp_send:
  /* We're done with the input processing. We are now ready to send a
     reply. Our job is to fill in all the fields of the TCP and IP
     headers before calculating the checksum and finally send the
     packet. */
  BUF->ackno[0] = uip_connr->rcv_nxt[0];
    398c:	88 85       	ldd	r24, Y+8	; 0x08
    398e:	80 93 e6 05 	sts	0x05E6, r24
  BUF->ackno[1] = uip_connr->rcv_nxt[1];
    3992:	89 85       	ldd	r24, Y+9	; 0x09
    3994:	80 93 e7 05 	sts	0x05E7, r24
  BUF->ackno[2] = uip_connr->rcv_nxt[2];
    3998:	8a 85       	ldd	r24, Y+10	; 0x0a
    399a:	80 93 e8 05 	sts	0x05E8, r24
  BUF->ackno[3] = uip_connr->rcv_nxt[3];
    399e:	8b 85       	ldd	r24, Y+11	; 0x0b
    39a0:	80 93 e9 05 	sts	0x05E9, r24
  
  BUF->seqno[0] = uip_connr->snd_nxt[0];
    39a4:	8c 85       	ldd	r24, Y+12	; 0x0c
    39a6:	80 93 e2 05 	sts	0x05E2, r24
  BUF->seqno[1] = uip_connr->snd_nxt[1];
    39aa:	8d 85       	ldd	r24, Y+13	; 0x0d
    39ac:	80 93 e3 05 	sts	0x05E3, r24
  BUF->seqno[2] = uip_connr->snd_nxt[2];
    39b0:	8e 85       	ldd	r24, Y+14	; 0x0e
    39b2:	80 93 e4 05 	sts	0x05E4, r24
  BUF->seqno[3] = uip_connr->snd_nxt[3];
    39b6:	8f 85       	ldd	r24, Y+15	; 0x0f
    39b8:	80 93 e5 05 	sts	0x05E5, r24

  BUF->proto = UIP_PROTO_TCP;
    39bc:	86 e0       	ldi	r24, 0x06	; 6
    39be:	80 93 d3 05 	sts	0x05D3, r24
  
  BUF->srcport  = uip_connr->lport;
    39c2:	8c 81       	ldd	r24, Y+4	; 0x04
    39c4:	9d 81       	ldd	r25, Y+5	; 0x05
    39c6:	90 93 df 05 	sts	0x05DF, r25
    39ca:	80 93 de 05 	sts	0x05DE, r24
  BUF->destport = uip_connr->rport;
    39ce:	8e 81       	ldd	r24, Y+6	; 0x06
    39d0:	9f 81       	ldd	r25, Y+7	; 0x07
    39d2:	90 93 e1 05 	sts	0x05E1, r25
    39d6:	80 93 e0 05 	sts	0x05E0, r24

  uip_ipaddr_copy(BUF->srcipaddr, uip_hostaddr);
    39da:	80 91 b8 05 	lds	r24, 0x05B8
    39de:	90 91 b9 05 	lds	r25, 0x05B9
    39e2:	90 93 d7 05 	sts	0x05D7, r25
    39e6:	80 93 d6 05 	sts	0x05D6, r24
    39ea:	80 91 ba 05 	lds	r24, 0x05BA
    39ee:	90 91 bb 05 	lds	r25, 0x05BB
    39f2:	90 93 d9 05 	sts	0x05D9, r25
    39f6:	80 93 d8 05 	sts	0x05D8, r24
  uip_ipaddr_copy(BUF->destipaddr, uip_connr->ripaddr);
    39fa:	88 81       	ld	r24, Y
    39fc:	99 81       	ldd	r25, Y+1	; 0x01
    39fe:	90 93 db 05 	sts	0x05DB, r25
    3a02:	80 93 da 05 	sts	0x05DA, r24
    3a06:	8a 81       	ldd	r24, Y+2	; 0x02
    3a08:	9b 81       	ldd	r25, Y+3	; 0x03
    3a0a:	90 93 dd 05 	sts	0x05DD, r25
    3a0e:	80 93 dc 05 	sts	0x05DC, r24

  if(uip_connr->tcpstateflags & UIP_STOPPED) {
    3a12:	89 8d       	ldd	r24, Y+25	; 0x19
    3a14:	84 ff       	sbrs	r24, 4
    3a16:	05 c0       	rjmp	.+10     	; 0x3a22 <uip_process+0xdf4>
    /* If the connection has issued uip_stop(), we advertise a zero
       window so that the remote host will stop sending data. */
    BUF->wnd[0] = BUF->wnd[1] = 0;
    3a18:	10 92 ed 05 	sts	0x05ED, r1
    3a1c:	10 92 ec 05 	sts	0x05EC, r1
    3a20:	06 c0       	rjmp	.+12     	; 0x3a2e <uip_process+0xe00>
  } else {
    BUF->wnd[0] = ((UIP_RECEIVE_WINDOW) >> 8);
    3a22:	85 e0       	ldi	r24, 0x05	; 5
    3a24:	80 93 ec 05 	sts	0x05EC, r24
    BUF->wnd[1] = ((UIP_RECEIVE_WINDOW) & 0xff);
    3a28:	86 ea       	ldi	r24, 0xA6	; 166
    3a2a:	80 93 ed 05 	sts	0x05ED, r24
  }

 tcp_send_noconn:
  BUF->ttl = UIP_TTL;
    3a2e:	80 e4       	ldi	r24, 0x40	; 64
    3a30:	80 93 d2 05 	sts	0x05D2, r24
  /* For IPv6, the IP length field does not include the IPv6 IP header
     length. */
  BUF->len[0] = ((uip_len - UIP_IPH_LEN) >> 8);
  BUF->len[1] = ((uip_len - UIP_IPH_LEN) & 0xff);
#else /* UIP_CONF_IPV6 */
  BUF->len[0] = (uip_len >> 8);
    3a34:	80 91 37 04 	lds	r24, 0x0437
    3a38:	90 91 38 04 	lds	r25, 0x0438
    3a3c:	89 2f       	mov	r24, r25
    3a3e:	99 27       	eor	r25, r25
    3a40:	80 93 cc 05 	sts	0x05CC, r24
  BUF->len[1] = (uip_len & 0xff);
    3a44:	80 91 37 04 	lds	r24, 0x0437
    3a48:	80 93 cd 05 	sts	0x05CD, r24
#endif /* UIP_CONF_IPV6 */

  BUF->urgp[0] = BUF->urgp[1] = 0;
    3a4c:	10 92 f1 05 	sts	0x05F1, r1
    3a50:	10 92 f0 05 	sts	0x05F0, r1
  
  /* Calculate TCP checksum. */
  BUF->tcpchksum = 0;
    3a54:	10 92 ef 05 	sts	0x05EF, r1
    3a58:	10 92 ee 05 	sts	0x05EE, r1
  BUF->tcpchksum = ~(uip_tcpchksum());
    3a5c:	0e 94 60 15 	call	0x2ac0	; 0x2ac0 <uip_tcpchksum>
    3a60:	80 95       	com	r24
    3a62:	90 95       	com	r25
    3a64:	90 93 ef 05 	sts	0x05EF, r25
    3a68:	80 93 ee 05 	sts	0x05EE, r24
#if UIP_CONF_IPV6
  BUF->vtc = 0x60;
  BUF->tcflow = 0x00;
  BUF->flow = 0x00;
#else /* UIP_CONF_IPV6 */
  BUF->vhl = 0x45;
    3a6c:	85 e4       	ldi	r24, 0x45	; 69
    3a6e:	80 93 ca 05 	sts	0x05CA, r24
  BUF->tos = 0;
    3a72:	10 92 cb 05 	sts	0x05CB, r1
  BUF->ipoffset[0] = BUF->ipoffset[1] = 0;
    3a76:	10 92 d1 05 	sts	0x05D1, r1
    3a7a:	10 92 d0 05 	sts	0x05D0, r1
  ++ipid;
    3a7e:	80 91 87 03 	lds	r24, 0x0387
    3a82:	90 91 88 03 	lds	r25, 0x0388
    3a86:	01 96       	adiw	r24, 0x01	; 1
    3a88:	90 93 88 03 	sts	0x0388, r25
    3a8c:	80 93 87 03 	sts	0x0387, r24
  BUF->ipid[0] = ipid >> 8;
    3a90:	29 2f       	mov	r18, r25
    3a92:	33 27       	eor	r19, r19
    3a94:	20 93 ce 05 	sts	0x05CE, r18
  BUF->ipid[1] = ipid & 0xff;
    3a98:	80 93 cf 05 	sts	0x05CF, r24
  /* Calculate IP checksum. */
  BUF->ipchksum = 0;
    3a9c:	10 92 d5 05 	sts	0x05D5, r1
    3aa0:	10 92 d4 05 	sts	0x05D4, r1
  BUF->ipchksum = ~(uip_ipchksum());
    3aa4:	0e 94 1f 15 	call	0x2a3e	; 0x2a3e <uip_ipchksum>
    3aa8:	80 95       	com	r24
    3aaa:	90 95       	com	r25
    3aac:	90 93 d5 05 	sts	0x05D5, r25
    3ab0:	80 93 d4 05 	sts	0x05D4, r24
  DEBUG_PRINTF("uip ip_send_nolen: chkecum 0x%04x\n", uip_ipchksum());
#endif /* UIP_CONF_IPV6 */
   
  UIP_STAT(++uip_stat.tcp.sent);
    3ab4:	80 91 a6 05 	lds	r24, 0x05A6
    3ab8:	90 91 a7 05 	lds	r25, 0x05A7
    3abc:	01 96       	adiw	r24, 0x01	; 1
    3abe:	90 93 a7 05 	sts	0x05A7, r25
    3ac2:	80 93 a6 05 	sts	0x05A6, r24
 send:
  DEBUG_PRINTF("Sending packet with length %d (%d)\n", uip_len,
	       (BUF->len[0] << 8) | BUF->len[1]);
  
  UIP_STAT(++uip_stat.ip.sent);
    3ac6:	80 91 8c 05 	lds	r24, 0x058C
    3aca:	90 91 8d 05 	lds	r25, 0x058D
    3ace:	01 96       	adiw	r24, 0x01	; 1
    3ad0:	90 93 8d 05 	sts	0x058D, r25
    3ad4:	80 93 8c 05 	sts	0x058C, r24
    3ad8:	04 c0       	rjmp	.+8      	; 0x3ae2 <uip_process+0xeb4>
  /* Return and let the caller do the actual transmission. */
  uip_flags = 0;
  return;
 drop:
  uip_len = 0;
    3ada:	10 92 38 04 	sts	0x0438, r1
    3ade:	10 92 37 04 	sts	0x0437, r1
  uip_flags = 0;
    3ae2:	10 92 3f 04 	sts	0x043F, r1
    3ae6:	df 91       	pop	r29
    3ae8:	cf 91       	pop	r28
    3aea:	1f 91       	pop	r17
    3aec:	0f 91       	pop	r16
    3aee:	08 95       	ret

00003af0 <uip_chksum>:
  return sum;
}
/*---------------------------------------------------------------------------*/
u16_t
uip_chksum(u16_t *data, u16_t len)
{
    3af0:	0f 93       	push	r16
    3af2:	1f 93       	push	r17
    3af4:	ab 01       	movw	r20, r22
  return htons(chksum(0, (u8_t *)data, len));
    3af6:	bc 01       	movw	r22, r24
    3af8:	80 e0       	ldi	r24, 0x00	; 0
    3afa:	90 e0       	ldi	r25, 0x00	; 0
    3afc:	0e 94 f8 14 	call	0x29f0	; 0x29f0 <chksum>
    3b00:	09 2f       	mov	r16, r25
    3b02:	18 2f       	mov	r17, r24
}
    3b04:	c8 01       	movw	r24, r16
    3b06:	1f 91       	pop	r17
    3b08:	0f 91       	pop	r16
    3b0a:	08 95       	ret

00003b0c <uip_connect>:
}
/*---------------------------------------------------------------------------*/
#if UIP_ACTIVE_OPEN
struct uip_conn *
uip_connect(uip_ipaddr_t *ripaddr, u16_t rport)
{
    3b0c:	ef 92       	push	r14
    3b0e:	ff 92       	push	r15
    3b10:	0f 93       	push	r16
    3b12:	1f 93       	push	r17
    3b14:	cf 93       	push	r28
    3b16:	df 93       	push	r29
    3b18:	8c 01       	movw	r16, r24
    3b1a:	20 91 8d 03 	lds	r18, 0x038D
    3b1e:	30 91 8e 03 	lds	r19, 0x038E
  register struct uip_conn *conn, *cconn;
  
  /* Find an unused local port. */
 again:
  ++lastport;
    3b22:	2f 5f       	subi	r18, 0xFF	; 255
    3b24:	3f 4f       	sbci	r19, 0xFF	; 255

  if(lastport >= 32000) {
    3b26:	8d e7       	ldi	r24, 0x7D	; 125
    3b28:	20 30       	cpi	r18, 0x00	; 0
    3b2a:	38 07       	cpc	r19, r24
    3b2c:	10 f0       	brcs	.+4      	; 0x3b32 <uip_connect+0x26>
    3b2e:	20 e0       	ldi	r18, 0x00	; 0
    3b30:	30 e1       	ldi	r19, 0x10	; 16
}
/*---------------------------------------------------------------------------*/
u16_t
htons(u16_t val)
{
  return HTONS(val);
    3b32:	a3 2f       	mov	r26, r19
    3b34:	b2 2f       	mov	r27, r18
    3b36:	40 e0       	ldi	r20, 0x00	; 0
    3b38:	50 e0       	ldi	r21, 0x00	; 0
    3b3a:	10 c0       	rjmp	.+32     	; 0x3b5c <uip_connect+0x50>
  }

  /* Check if this port is already in use, and if so try to find
     another one. */
  for(c = 0; c < UIP_CONNS; ++c) {
    conn = &uip_conns[c];
    3b3c:	8e e9       	ldi	r24, 0x9E	; 158
    3b3e:	98 9f       	mul	r25, r24
    3b40:	f0 01       	movw	r30, r0
    3b42:	11 24       	eor	r1, r1
    3b44:	ec 5b       	subi	r30, 0xBC	; 188
    3b46:	fb 4f       	sbci	r31, 0xFB	; 251
    if(conn->tcpstateflags != UIP_CLOSED &&
    3b48:	81 8d       	ldd	r24, Z+25	; 0x19
    3b4a:	88 23       	and	r24, r24
    3b4c:	29 f0       	breq	.+10     	; 0x3b58 <uip_connect+0x4c>
    3b4e:	84 81       	ldd	r24, Z+4	; 0x04
    3b50:	95 81       	ldd	r25, Z+5	; 0x05
    3b52:	8a 17       	cp	r24, r26
    3b54:	9b 07       	cpc	r25, r27
    3b56:	29 f3       	breq	.-54     	; 0x3b22 <uip_connect+0x16>
       conn->lport == htons(lastport)) {
      goto again;
    3b58:	4f 5f       	subi	r20, 0xFF	; 255
    3b5a:	5f 4f       	sbci	r21, 0xFF	; 255
    3b5c:	94 2f       	mov	r25, r20
    lastport = 4096;
  }

  /* Check if this port is already in use, and if so try to find
     another one. */
  for(c = 0; c < UIP_CONNS; ++c) {
    3b5e:	42 30       	cpi	r20, 0x02	; 2
    3b60:	51 05       	cpc	r21, r1
    3b62:	61 f7       	brne	.-40     	; 0x3b3c <uip_connect+0x30>
    3b64:	30 93 8e 03 	sts	0x038E, r19
    3b68:	20 93 8d 03 	sts	0x038D, r18
      goto again;
    }
  }

  conn = 0;
  for(c = 0; c < UIP_CONNS; ++c) {
    3b6c:	10 92 8f 03 	sts	0x038F, r1
    3b70:	e0 e0       	ldi	r30, 0x00	; 0
    3b72:	f0 e0       	ldi	r31, 0x00	; 0
    3b74:	40 e0       	ldi	r20, 0x00	; 0
    3b76:	19 c0       	rjmp	.+50     	; 0x3baa <uip_connect+0x9e>
    cconn = &uip_conns[c];
    3b78:	8e e9       	ldi	r24, 0x9E	; 158
    3b7a:	48 9f       	mul	r20, r24
    3b7c:	d0 01       	movw	r26, r0
    3b7e:	11 24       	eor	r1, r1
    3b80:	ac 5b       	subi	r26, 0xBC	; 188
    3b82:	bb 4f       	sbci	r27, 0xFB	; 251
    if(cconn->tcpstateflags == UIP_CLOSED) {
    3b84:	ed 01       	movw	r28, r26
    3b86:	89 8d       	ldd	r24, Y+25	; 0x19
    3b88:	88 23       	and	r24, r24
    3b8a:	21 f4       	brne	.+8      	; 0x3b94 <uip_connect+0x88>
    3b8c:	40 93 8f 03 	sts	0x038F, r20
    3b90:	fd 01       	movw	r30, r26
    3b92:	0f c0       	rjmp	.+30     	; 0x3bb2 <uip_connect+0xa6>
      conn = cconn;
      break;
    }
    if(cconn->tcpstateflags == UIP_TIME_WAIT) {
    3b94:	87 30       	cpi	r24, 0x07	; 7
    3b96:	41 f4       	brne	.+16     	; 0x3ba8 <uip_connect+0x9c>
      if(conn == 0 ||
    3b98:	30 97       	sbiw	r30, 0x00	; 0
    3b9a:	29 f0       	breq	.+10     	; 0x3ba6 <uip_connect+0x9a>
    3b9c:	ed 01       	movw	r28, r26
    3b9e:	9a 8d       	ldd	r25, Y+26	; 0x1a
    3ba0:	82 8d       	ldd	r24, Z+26	; 0x1a
    3ba2:	89 17       	cp	r24, r25
    3ba4:	08 f4       	brcc	.+2      	; 0x3ba8 <uip_connect+0x9c>
    3ba6:	fd 01       	movw	r30, r26
    3ba8:	4f 5f       	subi	r20, 0xFF	; 255
      goto again;
    }
  }

  conn = 0;
  for(c = 0; c < UIP_CONNS; ++c) {
    3baa:	42 30       	cpi	r20, 0x02	; 2
    3bac:	28 f3       	brcs	.-54     	; 0x3b78 <uip_connect+0x6c>
    3bae:	40 93 8f 03 	sts	0x038F, r20
	conn = cconn;
      }
    }
  }

  if(conn == 0) {
    3bb2:	30 97       	sbiw	r30, 0x00	; 0
    3bb4:	81 f1       	breq	.+96     	; 0x3c16 <uip_connect+0x10a>
    return 0;
  }
  
  conn->tcpstateflags = UIP_SYN_SENT;
    3bb6:	82 e0       	ldi	r24, 0x02	; 2
    3bb8:	81 8f       	std	Z+25, r24	; 0x19

  conn->snd_nxt[0] = iss[0];
    3bba:	80 91 89 03 	lds	r24, 0x0389
    3bbe:	84 87       	std	Z+12, r24	; 0x0c
  conn->snd_nxt[1] = iss[1];
    3bc0:	80 91 8a 03 	lds	r24, 0x038A
    3bc4:	85 87       	std	Z+13, r24	; 0x0d
  conn->snd_nxt[2] = iss[2];
    3bc6:	80 91 8b 03 	lds	r24, 0x038B
    3bca:	86 87       	std	Z+14, r24	; 0x0e
  conn->snd_nxt[3] = iss[3];
    3bcc:	80 91 8c 03 	lds	r24, 0x038C
    3bd0:	87 87       	std	Z+15, r24	; 0x0f

  conn->initialmss = conn->mss = UIP_TCP_MSS;
    3bd2:	86 ea       	ldi	r24, 0xA6	; 166
    3bd4:	95 e0       	ldi	r25, 0x05	; 5
    3bd6:	93 8b       	std	Z+19, r25	; 0x13
    3bd8:	82 8b       	std	Z+18, r24	; 0x12
    3bda:	95 8b       	std	Z+21, r25	; 0x15
    3bdc:	84 8b       	std	Z+20, r24	; 0x14
  
  conn->len = 1;   /* TCP length of the SYN is one. */
    3bde:	81 e0       	ldi	r24, 0x01	; 1
    3be0:	90 e0       	ldi	r25, 0x00	; 0
    3be2:	91 8b       	std	Z+17, r25	; 0x11
    3be4:	80 8b       	std	Z+16, r24	; 0x10
  conn->nrtx = 0;
    3be6:	13 8e       	std	Z+27, r1	; 0x1b
  conn->timer = 1; /* Send the SYN next time around. */
    3be8:	81 e0       	ldi	r24, 0x01	; 1
    3bea:	82 8f       	std	Z+26, r24	; 0x1a
  conn->rto = UIP_RTO;
    3bec:	83 e0       	ldi	r24, 0x03	; 3
    3bee:	80 8f       	std	Z+24, r24	; 0x18
  conn->sa = 0;
    3bf0:	16 8a       	std	Z+22, r1	; 0x16
  conn->sv = 16;   /* Initial value of the RTT variance. */
    3bf2:	80 e1       	ldi	r24, 0x10	; 16
    3bf4:	87 8b       	std	Z+23, r24	; 0x17
  conn->lport = htons(lastport);
    3bf6:	e3 2e       	mov	r14, r19
    3bf8:	f2 2e       	mov	r15, r18
    3bfa:	f5 82       	std	Z+5, r15	; 0x05
    3bfc:	e4 82       	std	Z+4, r14	; 0x04
  conn->rport = rport;
    3bfe:	77 83       	std	Z+7, r23	; 0x07
    3c00:	66 83       	std	Z+6, r22	; 0x06
  uip_ipaddr_copy(&conn->ripaddr, ripaddr);
    3c02:	d8 01       	movw	r26, r16
    3c04:	8d 91       	ld	r24, X+
    3c06:	9c 91       	ld	r25, X
    3c08:	91 83       	std	Z+1, r25	; 0x01
    3c0a:	80 83       	st	Z, r24
    3c0c:	e8 01       	movw	r28, r16
    3c0e:	8a 81       	ldd	r24, Y+2	; 0x02
    3c10:	9b 81       	ldd	r25, Y+3	; 0x03
    3c12:	93 83       	std	Z+3, r25	; 0x03
    3c14:	82 83       	std	Z+2, r24	; 0x02
  
  return conn;
}
    3c16:	cf 01       	movw	r24, r30
    3c18:	df 91       	pop	r29
    3c1a:	cf 91       	pop	r28
    3c1c:	1f 91       	pop	r17
    3c1e:	0f 91       	pop	r16
    3c20:	ff 90       	pop	r15
    3c22:	ef 90       	pop	r14
    3c24:	08 95       	ret

00003c26 <uip_arp_update>:

}
/*-----------------------------------------------------------------------------------*/
static void
uip_arp_update(u16_t *ipaddr, struct uip_eth_addr *ethaddr)
{
    3c26:	ef 92       	push	r14
    3c28:	ff 92       	push	r15
    3c2a:	1f 93       	push	r17
    3c2c:	cf 93       	push	r28
    3c2e:	df 93       	push	r29
    3c30:	dc 01       	movw	r26, r24
    3c32:	7b 01       	movw	r14, r22
  register struct arp_entry *tabptr;
  /* Walk through the ARP mapping table and try to find an entry to
     update. If none is found, the IP -> MAC address mapping is
     inserted in the ARP table. */
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    3c34:	10 92 c3 03 	sts	0x03C3, r1
    3c38:	60 e0       	ldi	r22, 0x00	; 0
    3c3a:	28 c0       	rjmp	.+80     	; 0x3c8c <uip_arp_update+0x66>

    tabptr = &arp_table[i];
    3c3c:	8b e0       	ldi	r24, 0x0B	; 11
    3c3e:	68 9f       	mul	r22, r24
    3c40:	f0 01       	movw	r30, r0
    3c42:	11 24       	eor	r1, r1
    3c44:	ed 56       	subi	r30, 0x6D	; 109
    3c46:	fc 4f       	sbci	r31, 0xFC	; 252
    /* Only check those entries that are actually in use. */
    if(tabptr->ipaddr[0] != 0 &&
    3c48:	40 81       	ld	r20, Z
    3c4a:	51 81       	ldd	r21, Z+1	; 0x01
    3c4c:	41 15       	cp	r20, r1
    3c4e:	51 05       	cpc	r21, r1
    3c50:	e1 f0       	breq	.+56     	; 0x3c8a <uip_arp_update+0x64>
    3c52:	22 81       	ldd	r18, Z+2	; 0x02
    3c54:	33 81       	ldd	r19, Z+3	; 0x03
    3c56:	21 15       	cp	r18, r1
    3c58:	31 05       	cpc	r19, r1
    3c5a:	b9 f0       	breq	.+46     	; 0x3c8a <uip_arp_update+0x64>
       tabptr->ipaddr[1] != 0) {

      /* Check if the source IP address of the incoming packet matches
         the IP address in this ARP table entry. */
      if(ipaddr[0] == tabptr->ipaddr[0] &&
    3c5c:	8d 91       	ld	r24, X+
    3c5e:	9c 91       	ld	r25, X
    3c60:	11 97       	sbiw	r26, 0x01	; 1
    3c62:	84 17       	cp	r24, r20
    3c64:	95 07       	cpc	r25, r21
    3c66:	89 f4       	brne	.+34     	; 0x3c8a <uip_arp_update+0x64>
    3c68:	ed 01       	movw	r28, r26
    3c6a:	8a 81       	ldd	r24, Y+2	; 0x02
    3c6c:	9b 81       	ldd	r25, Y+3	; 0x03
    3c6e:	82 17       	cp	r24, r18
    3c70:	93 07       	cpc	r25, r19
    3c72:	59 f4       	brne	.+22     	; 0x3c8a <uip_arp_update+0x64>
    3c74:	60 93 c3 03 	sts	0x03C3, r22
	 ipaddr[1] == tabptr->ipaddr[1]) {
	 
	/* An old entry found, update this and return. */
	memcpy(tabptr->ethaddr.addr, ethaddr->addr, 6);
    3c78:	ef 01       	movw	r28, r30
    3c7a:	24 96       	adiw	r28, 0x04	; 4
    3c7c:	d7 01       	movw	r26, r14
    3c7e:	86 e0       	ldi	r24, 0x06	; 6
    3c80:	0d 90       	ld	r0, X+
    3c82:	09 92       	st	Y+, r0
    3c84:	81 50       	subi	r24, 0x01	; 1
    3c86:	e1 f7       	brne	.-8      	; 0x3c80 <uip_arp_update+0x5a>
    3c88:	63 c0       	rjmp	.+198    	; 0x3d50 <uip_arp_update+0x12a>
	tabptr->time = arptime;

	return;
    3c8a:	6f 5f       	subi	r22, 0xFF	; 255
{
  register struct arp_entry *tabptr;
  /* Walk through the ARP mapping table and try to find an entry to
     update. If none is found, the IP -> MAC address mapping is
     inserted in the ARP table. */
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    3c8c:	64 30       	cpi	r22, 0x04	; 4
    3c8e:	b0 f2       	brcs	.-84     	; 0x3c3c <uip_arp_update+0x16>

  /* If we get here, no existing ARP table entry was found, so we
     create one. */

  /* First, we try to find an unused entry in the ARP table. */
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    3c90:	10 92 c3 03 	sts	0x03C3, r1
    3c94:	20 e0       	ldi	r18, 0x00	; 0
    3c96:	12 c0       	rjmp	.+36     	; 0x3cbc <uip_arp_update+0x96>
    tabptr = &arp_table[i];
    3c98:	8b e0       	ldi	r24, 0x0B	; 11
    3c9a:	28 9f       	mul	r18, r24
    3c9c:	f0 01       	movw	r30, r0
    3c9e:	11 24       	eor	r1, r1
    3ca0:	ed 56       	subi	r30, 0x6D	; 109
    3ca2:	fc 4f       	sbci	r31, 0xFC	; 252
    if(tabptr->ipaddr[0] == 0 &&
    3ca4:	80 81       	ld	r24, Z
    3ca6:	91 81       	ldd	r25, Z+1	; 0x01
    3ca8:	89 2b       	or	r24, r25
    3caa:	39 f4       	brne	.+14     	; 0x3cba <uip_arp_update+0x94>
    3cac:	82 81       	ldd	r24, Z+2	; 0x02
    3cae:	93 81       	ldd	r25, Z+3	; 0x03
    3cb0:	89 2b       	or	r24, r25
    3cb2:	19 f4       	brne	.+6      	; 0x3cba <uip_arp_update+0x94>
    3cb4:	20 93 c3 03 	sts	0x03C3, r18
    3cb8:	3b c0       	rjmp	.+118    	; 0x3d30 <uip_arp_update+0x10a>
    3cba:	2f 5f       	subi	r18, 0xFF	; 255

  /* If we get here, no existing ARP table entry was found, so we
     create one. */

  /* First, we try to find an unused entry in the ARP table. */
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    3cbc:	24 30       	cpi	r18, 0x04	; 4
    3cbe:	60 f3       	brcs	.-40     	; 0x3c98 <uip_arp_update+0x72>
    3cc0:	20 93 c3 03 	sts	0x03C3, r18
    }
  }

  /* If no unused entry is found, we try to find the oldest entry and
     throw it away. */
  if(i == UIP_ARPTAB_SIZE) {
    3cc4:	24 30       	cpi	r18, 0x04	; 4
    3cc6:	a1 f5       	brne	.+104    	; 0x3d30 <uip_arp_update+0x10a>
    tmpage = 0;
    3cc8:	10 92 c6 03 	sts	0x03C6, r1
    c = 0;
    3ccc:	10 92 c4 03 	sts	0x03C4, r1
    for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
      tabptr = &arp_table[i];
      if(arptime - tabptr->time > tmpage) {
    3cd0:	10 91 c5 03 	lds	r17, 0x03C5
    3cd4:	c1 2f       	mov	r28, r17
    3cd6:	d0 e0       	ldi	r29, 0x00	; 0
    3cd8:	60 e0       	ldi	r22, 0x00	; 0
    3cda:	70 e0       	ldi	r23, 0x00	; 0
    3cdc:	50 e0       	ldi	r21, 0x00	; 0
    3cde:	1a c0       	rjmp	.+52     	; 0x3d14 <uip_arp_update+0xee>
    3ce0:	25 2f       	mov	r18, r21
    3ce2:	30 e0       	ldi	r19, 0x00	; 0
    3ce4:	8b e0       	ldi	r24, 0x0B	; 11
    3ce6:	90 e0       	ldi	r25, 0x00	; 0
    3ce8:	28 9f       	mul	r18, r24
    3cea:	f0 01       	movw	r30, r0
    3cec:	29 9f       	mul	r18, r25
    3cee:	f0 0d       	add	r31, r0
    3cf0:	38 9f       	mul	r19, r24
    3cf2:	f0 0d       	add	r31, r0
    3cf4:	11 24       	eor	r1, r1
    3cf6:	ed 56       	subi	r30, 0x6D	; 109
    3cf8:	fc 4f       	sbci	r31, 0xFC	; 252
    3cfa:	42 85       	ldd	r20, Z+10	; 0x0a
    3cfc:	9e 01       	movw	r18, r28
    3cfe:	24 1b       	sub	r18, r20
    3d00:	31 09       	sbc	r19, r1
    3d02:	87 2f       	mov	r24, r23
    3d04:	90 e0       	ldi	r25, 0x00	; 0
    3d06:	82 17       	cp	r24, r18
    3d08:	93 07       	cpc	r25, r19
    3d0a:	1c f4       	brge	.+6      	; 0x3d12 <uip_arp_update+0xec>
	tmpage = arptime - tabptr->time;
    3d0c:	71 2f       	mov	r23, r17
    3d0e:	74 1b       	sub	r23, r20
    3d10:	65 2f       	mov	r22, r21
    3d12:	5f 5f       	subi	r21, 0xFF	; 255
  /* If no unused entry is found, we try to find the oldest entry and
     throw it away. */
  if(i == UIP_ARPTAB_SIZE) {
    tmpage = 0;
    c = 0;
    for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    3d14:	54 30       	cpi	r21, 0x04	; 4
    3d16:	20 f3       	brcs	.-56     	; 0x3ce0 <uip_arp_update+0xba>
    3d18:	60 93 c4 03 	sts	0x03C4, r22
    3d1c:	70 93 c6 03 	sts	0x03C6, r23
      if(arptime - tabptr->time > tmpage) {
	tmpage = arptime - tabptr->time;
	c = i;
      }
    }
    i = c;
    3d20:	60 93 c3 03 	sts	0x03C3, r22
    tabptr = &arp_table[i];
    3d24:	8b e0       	ldi	r24, 0x0B	; 11
    3d26:	68 9f       	mul	r22, r24
    3d28:	f0 01       	movw	r30, r0
    3d2a:	11 24       	eor	r1, r1
    3d2c:	ed 56       	subi	r30, 0x6D	; 109
    3d2e:	fc 4f       	sbci	r31, 0xFC	; 252
  }

  /* Now, i is the ARP table entry which we will fill with the new
     information. */
  memcpy(tabptr->ipaddr, ipaddr, 4);
    3d30:	8d 91       	ld	r24, X+
    3d32:	9d 91       	ld	r25, X+
    3d34:	0d 90       	ld	r0, X+
    3d36:	bc 91       	ld	r27, X
    3d38:	a0 2d       	mov	r26, r0
    3d3a:	ef 01       	movw	r28, r30
    3d3c:	89 93       	st	Y+, r24
    3d3e:	99 93       	st	Y+, r25
    3d40:	a9 93       	st	Y+, r26
    3d42:	b9 93       	st	Y+, r27
  memcpy(tabptr->ethaddr.addr, ethaddr->addr, 6);
    3d44:	d7 01       	movw	r26, r14
    3d46:	86 e0       	ldi	r24, 0x06	; 6
    3d48:	0d 90       	ld	r0, X+
    3d4a:	09 92       	st	Y+, r0
    3d4c:	81 50       	subi	r24, 0x01	; 1
    3d4e:	e1 f7       	brne	.-8      	; 0x3d48 <uip_arp_update+0x122>
  tabptr->time = arptime;
    3d50:	80 91 c5 03 	lds	r24, 0x03C5
    3d54:	82 87       	std	Z+10, r24	; 0x0a
    3d56:	df 91       	pop	r29
    3d58:	cf 91       	pop	r28
    3d5a:	1f 91       	pop	r17
    3d5c:	ff 90       	pop	r15
    3d5e:	ef 90       	pop	r14
    3d60:	08 95       	ret

00003d62 <uip_arp_arpin>:
 * global variable uip_len.
 */
/*-----------------------------------------------------------------------------------*/
void
uip_arp_arpin(void)
{
    3d62:	cf 93       	push	r28
    3d64:	df 93       	push	r29
  
  if(uip_len < sizeof(struct arp_hdr)) {
    3d66:	80 91 37 04 	lds	r24, 0x0437
    3d6a:	90 91 38 04 	lds	r25, 0x0438
    3d6e:	8a 97       	sbiw	r24, 0x2a	; 42
    3d70:	28 f4       	brcc	.+10     	; 0x3d7c <uip_arp_arpin+0x1a>
    uip_len = 0;
    3d72:	10 92 38 04 	sts	0x0438, r1
    3d76:	10 92 37 04 	sts	0x0437, r1
    3d7a:	9b c0       	rjmp	.+310    	; 0x3eb2 <uip_arp_arpin+0x150>
    return;
  }
  uip_len = 0;
    3d7c:	10 92 38 04 	sts	0x0438, r1
    3d80:	10 92 37 04 	sts	0x0437, r1
  
  switch(BUF->opcode) {
    3d84:	cc eb       	ldi	r28, 0xBC	; 188
    3d86:	d5 e0       	ldi	r29, 0x05	; 5
    3d88:	80 91 d0 05 	lds	r24, 0x05D0
    3d8c:	90 91 d1 05 	lds	r25, 0x05D1
    3d90:	21 e0       	ldi	r18, 0x01	; 1
    3d92:	80 30       	cpi	r24, 0x00	; 0
    3d94:	92 07       	cpc	r25, r18
    3d96:	29 f0       	breq	.+10     	; 0x3da2 <uip_arp_arpin+0x40>
    3d98:	80 50       	subi	r24, 0x00	; 0
    3d9a:	92 40       	sbci	r25, 0x02	; 2
    3d9c:	09 f0       	breq	.+2      	; 0x3da0 <uip_arp_arpin+0x3e>
    3d9e:	89 c0       	rjmp	.+274    	; 0x3eb2 <uip_arp_arpin+0x150>
    3da0:	6c c0       	rjmp	.+216    	; 0x3e7a <uip_arp_arpin+0x118>
  case HTONS(ARP_REQUEST):
    /* ARP request. If it asked for our address, we send out a
       reply. */
    if(uip_ipaddr_cmp(BUF->dipaddr, uip_hostaddr)) {
    3da2:	20 91 e2 05 	lds	r18, 0x05E2
    3da6:	30 91 e3 05 	lds	r19, 0x05E3
    3daa:	80 91 b8 05 	lds	r24, 0x05B8
    3dae:	90 91 b9 05 	lds	r25, 0x05B9
    3db2:	28 17       	cp	r18, r24
    3db4:	39 07       	cpc	r19, r25
    3db6:	09 f0       	breq	.+2      	; 0x3dba <uip_arp_arpin+0x58>
    3db8:	7c c0       	rjmp	.+248    	; 0x3eb2 <uip_arp_arpin+0x150>
    3dba:	20 91 e4 05 	lds	r18, 0x05E4
    3dbe:	30 91 e5 05 	lds	r19, 0x05E5
    3dc2:	80 91 ba 05 	lds	r24, 0x05BA
    3dc6:	90 91 bb 05 	lds	r25, 0x05BB
    3dca:	28 17       	cp	r18, r24
    3dcc:	39 07       	cpc	r19, r25
    3dce:	09 f0       	breq	.+2      	; 0x3dd2 <uip_arp_arpin+0x70>
    3dd0:	70 c0       	rjmp	.+224    	; 0x3eb2 <uip_arp_arpin+0x150>
      /* First, we register the one who made the request in our ARP
	 table, since it is likely that we will do more communication
	 with this host in the future. */
      uip_arp_update(BUF->sipaddr, &BUF->shwaddr);
    3dd2:	be 01       	movw	r22, r28
    3dd4:	6a 5e       	subi	r22, 0xEA	; 234
    3dd6:	7f 4f       	sbci	r23, 0xFF	; 255
    3dd8:	ce 01       	movw	r24, r28
    3dda:	4c 96       	adiw	r24, 0x1c	; 28
    3ddc:	0e 94 13 1e 	call	0x3c26	; 0x3c26 <uip_arp_update>
      
      /* The reply opcode is 2. */
      BUF->opcode = HTONS(2);
    3de0:	80 e0       	ldi	r24, 0x00	; 0
    3de2:	92 e0       	ldi	r25, 0x02	; 2
    3de4:	90 93 d1 05 	sts	0x05D1, r25
    3de8:	80 93 d0 05 	sts	0x05D0, r24

      memcpy(BUF->dhwaddr.addr, BUF->shwaddr.addr, 6);
    3dec:	de 01       	movw	r26, r28
    3dee:	90 96       	adiw	r26, 0x20	; 32
    3df0:	fe 01       	movw	r30, r28
    3df2:	76 96       	adiw	r30, 0x16	; 22
    3df4:	86 e0       	ldi	r24, 0x06	; 6
    3df6:	01 90       	ld	r0, Z+
    3df8:	0d 92       	st	X+, r0
    3dfa:	81 50       	subi	r24, 0x01	; 1
    3dfc:	e1 f7       	brne	.-8      	; 0x3df6 <uip_arp_arpin+0x94>
      memcpy(BUF->shwaddr.addr, uip_ethaddr.addr, 6);
    3dfe:	a2 ed       	ldi	r26, 0xD2	; 210
    3e00:	b5 e0       	ldi	r27, 0x05	; 5
    3e02:	e1 e8       	ldi	r30, 0x81	; 129
    3e04:	f3 e0       	ldi	r31, 0x03	; 3
    3e06:	86 e0       	ldi	r24, 0x06	; 6
    3e08:	01 90       	ld	r0, Z+
    3e0a:	0d 92       	st	X+, r0
    3e0c:	81 50       	subi	r24, 0x01	; 1
    3e0e:	e1 f7       	brne	.-8      	; 0x3e08 <uip_arp_arpin+0xa6>
      memcpy(BUF->ethhdr.src.addr, uip_ethaddr.addr, 6);
    3e10:	a2 ec       	ldi	r26, 0xC2	; 194
    3e12:	b5 e0       	ldi	r27, 0x05	; 5
    3e14:	e1 e8       	ldi	r30, 0x81	; 129
    3e16:	f3 e0       	ldi	r31, 0x03	; 3
    3e18:	86 e0       	ldi	r24, 0x06	; 6
    3e1a:	01 90       	ld	r0, Z+
    3e1c:	0d 92       	st	X+, r0
    3e1e:	81 50       	subi	r24, 0x01	; 1
    3e20:	e1 f7       	brne	.-8      	; 0x3e1a <uip_arp_arpin+0xb8>
      memcpy(BUF->ethhdr.dest.addr, BUF->dhwaddr.addr, 6);
    3e22:	ec eb       	ldi	r30, 0xBC	; 188
    3e24:	f5 e0       	ldi	r31, 0x05	; 5
    3e26:	df 01       	movw	r26, r30
    3e28:	90 96       	adiw	r26, 0x20	; 32
    3e2a:	86 e0       	ldi	r24, 0x06	; 6
    3e2c:	0d 90       	ld	r0, X+
    3e2e:	01 92       	st	Z+, r0
    3e30:	81 50       	subi	r24, 0x01	; 1
    3e32:	e1 f7       	brne	.-8      	; 0x3e2c <uip_arp_arpin+0xca>
      
      BUF->dipaddr[0] = BUF->sipaddr[0];
    3e34:	80 91 d8 05 	lds	r24, 0x05D8
    3e38:	90 91 d9 05 	lds	r25, 0x05D9
    3e3c:	9f a3       	std	Y+39, r25	; 0x27
    3e3e:	8e a3       	std	Y+38, r24	; 0x26
      BUF->dipaddr[1] = BUF->sipaddr[1];
    3e40:	80 91 da 05 	lds	r24, 0x05DA
    3e44:	90 91 db 05 	lds	r25, 0x05DB
    3e48:	99 a7       	std	Y+41, r25	; 0x29
    3e4a:	88 a7       	std	Y+40, r24	; 0x28
      BUF->sipaddr[0] = uip_hostaddr[0];
    3e4c:	80 91 b8 05 	lds	r24, 0x05B8
    3e50:	90 91 b9 05 	lds	r25, 0x05B9
    3e54:	9d 8f       	std	Y+29, r25	; 0x1d
    3e56:	8c 8f       	std	Y+28, r24	; 0x1c
      BUF->sipaddr[1] = uip_hostaddr[1];
    3e58:	80 91 ba 05 	lds	r24, 0x05BA
    3e5c:	90 91 bb 05 	lds	r25, 0x05BB
    3e60:	9f 8f       	std	Y+31, r25	; 0x1f
    3e62:	8e 8f       	std	Y+30, r24	; 0x1e

      BUF->ethhdr.type = HTONS(UIP_ETHTYPE_ARP);
    3e64:	88 e0       	ldi	r24, 0x08	; 8
    3e66:	96 e0       	ldi	r25, 0x06	; 6
    3e68:	9d 87       	std	Y+13, r25	; 0x0d
    3e6a:	8c 87       	std	Y+12, r24	; 0x0c
      uip_len = sizeof(struct arp_hdr);
    3e6c:	8a e2       	ldi	r24, 0x2A	; 42
    3e6e:	90 e0       	ldi	r25, 0x00	; 0
    3e70:	90 93 38 04 	sts	0x0438, r25
    3e74:	80 93 37 04 	sts	0x0437, r24
    3e78:	1c c0       	rjmp	.+56     	; 0x3eb2 <uip_arp_arpin+0x150>
    }
    break;
  case HTONS(ARP_REPLY):
    /* ARP reply. We insert or update the ARP table if it was meant
       for us. */
    if(uip_ipaddr_cmp(BUF->dipaddr, uip_hostaddr)) {
    3e7a:	20 91 e2 05 	lds	r18, 0x05E2
    3e7e:	30 91 e3 05 	lds	r19, 0x05E3
    3e82:	80 91 b8 05 	lds	r24, 0x05B8
    3e86:	90 91 b9 05 	lds	r25, 0x05B9
    3e8a:	28 17       	cp	r18, r24
    3e8c:	39 07       	cpc	r19, r25
    3e8e:	89 f4       	brne	.+34     	; 0x3eb2 <uip_arp_arpin+0x150>
    3e90:	20 91 e4 05 	lds	r18, 0x05E4
    3e94:	30 91 e5 05 	lds	r19, 0x05E5
    3e98:	80 91 ba 05 	lds	r24, 0x05BA
    3e9c:	90 91 bb 05 	lds	r25, 0x05BB
    3ea0:	28 17       	cp	r18, r24
    3ea2:	39 07       	cpc	r19, r25
    3ea4:	31 f4       	brne	.+12     	; 0x3eb2 <uip_arp_arpin+0x150>
      uip_arp_update(BUF->sipaddr, &BUF->shwaddr);
    3ea6:	62 ed       	ldi	r22, 0xD2	; 210
    3ea8:	75 e0       	ldi	r23, 0x05	; 5
    3eaa:	88 ed       	ldi	r24, 0xD8	; 216
    3eac:	95 e0       	ldi	r25, 0x05	; 5
    3eae:	0e 94 13 1e 	call	0x3c26	; 0x3c26 <uip_arp_update>
    3eb2:	df 91       	pop	r29
    3eb4:	cf 91       	pop	r28
    3eb6:	08 95       	ret

00003eb8 <uip_arp_ipin>:
 */
/*-----------------------------------------------------------------------------------*/
#if 1
void
uip_arp_ipin(void)
{
    3eb8:	80 91 37 04 	lds	r24, 0x0437
    3ebc:	90 91 38 04 	lds	r25, 0x0438
    3ec0:	0e 97       	sbiw	r24, 0x0e	; 14
    3ec2:	90 93 38 04 	sts	0x0438, r25
    3ec6:	80 93 37 04 	sts	0x0437, r24
  uip_len -= sizeof(struct uip_eth_hdr);
	
  /* Only insert/update an entry if the source IP address of the
     incoming IP packet comes from a host on the local network. */
  if((IPBUF->srcipaddr[0] & uip_netmask[0]) !=
    3eca:	80 91 b4 05 	lds	r24, 0x05B4
    3ece:	90 91 b5 05 	lds	r25, 0x05B5
    3ed2:	20 91 d6 05 	lds	r18, 0x05D6
    3ed6:	30 91 d7 05 	lds	r19, 0x05D7
    3eda:	28 23       	and	r18, r24
    3edc:	39 23       	and	r19, r25
    3ede:	40 91 b8 05 	lds	r20, 0x05B8
    3ee2:	50 91 b9 05 	lds	r21, 0x05B9
    3ee6:	84 23       	and	r24, r20
    3ee8:	95 23       	and	r25, r21
    3eea:	28 17       	cp	r18, r24
    3eec:	39 07       	cpc	r19, r25
    3eee:	c9 f4       	brne	.+50     	; 0x3f22 <uip_arp_ipin+0x6a>
     (uip_hostaddr[0] & uip_netmask[0])) {
    return;
  }
  if((IPBUF->srcipaddr[1] & uip_netmask[1]) !=
    3ef0:	80 91 b6 05 	lds	r24, 0x05B6
    3ef4:	90 91 b7 05 	lds	r25, 0x05B7
    3ef8:	20 91 d8 05 	lds	r18, 0x05D8
    3efc:	30 91 d9 05 	lds	r19, 0x05D9
    3f00:	28 23       	and	r18, r24
    3f02:	39 23       	and	r19, r25
    3f04:	40 91 ba 05 	lds	r20, 0x05BA
    3f08:	50 91 bb 05 	lds	r21, 0x05BB
    3f0c:	84 23       	and	r24, r20
    3f0e:	95 23       	and	r25, r21
    3f10:	28 17       	cp	r18, r24
    3f12:	39 07       	cpc	r19, r25
    3f14:	31 f4       	brne	.+12     	; 0x3f22 <uip_arp_ipin+0x6a>
     (uip_hostaddr[1] & uip_netmask[1])) {
    return;
  }
  uip_arp_update(IPBUF->srcipaddr, &(IPBUF->ethhdr.src));
    3f16:	62 ec       	ldi	r22, 0xC2	; 194
    3f18:	75 e0       	ldi	r23, 0x05	; 5
    3f1a:	86 ed       	ldi	r24, 0xD6	; 214
    3f1c:	95 e0       	ldi	r25, 0x05	; 5
    3f1e:	0e 94 13 1e 	call	0x3c26	; 0x3c26 <uip_arp_update>
    3f22:	08 95       	ret

00003f24 <uip_arp_out>:
 * uip_len.
 */
/*-----------------------------------------------------------------------------------*/
void
uip_arp_out(void)
{
    3f24:	cf 93       	push	r28
    3f26:	df 93       	push	r29

     If not ARP table entry is found, we overwrite the original IP
     packet with an ARP request for the IP address. */

  /* First check if destination is a local broadcast. */
  if(uip_ipaddr_cmp(IPBUF->destipaddr, broadcast_ipaddr)) {
    3f28:	cc eb       	ldi	r28, 0xBC	; 188
    3f2a:	d5 e0       	ldi	r29, 0x05	; 5
    3f2c:	60 91 da 05 	lds	r22, 0x05DA
    3f30:	70 91 db 05 	lds	r23, 0x05DB
    3f34:	2f ef       	ldi	r18, 0xFF	; 255
    3f36:	6f 3f       	cpi	r22, 0xFF	; 255
    3f38:	72 07       	cpc	r23, r18
    3f3a:	89 f4       	brne	.+34     	; 0x3f5e <uip_arp_out+0x3a>
    3f3c:	80 91 dc 05 	lds	r24, 0x05DC
    3f40:	90 91 dd 05 	lds	r25, 0x05DD
    3f44:	8f 5f       	subi	r24, 0xFF	; 255
    3f46:	9f 4f       	sbci	r25, 0xFF	; 255
    3f48:	51 f4       	brne	.+20     	; 0x3f5e <uip_arp_out+0x3a>
    memcpy(IPBUF->ethhdr.dest.addr, broadcast_ethaddr.addr, 6);
    3f4a:	de 01       	movw	r26, r28
    3f4c:	e7 e0       	ldi	r30, 0x07	; 7
    3f4e:	f2 e0       	ldi	r31, 0x02	; 2
    3f50:	86 e0       	ldi	r24, 0x06	; 6
    3f52:	01 90       	ld	r0, Z+
    3f54:	0d 92       	st	X+, r0
    3f56:	81 50       	subi	r24, 0x01	; 1
    3f58:	09 f4       	brne	.+2      	; 0x3f5c <uip_arp_out+0x38>
    3f5a:	ce c0       	rjmp	.+412    	; 0x40f8 <uip_arp_out+0x1d4>
    3f5c:	fa cf       	rjmp	.-12     	; 0x3f52 <uip_arp_out+0x2e>
  } else {
    /* Check if the destination address is on the local network. */
    if(!uip_ipaddr_maskcmp(IPBUF->destipaddr, uip_hostaddr, uip_netmask)) {
    3f5e:	80 91 b4 05 	lds	r24, 0x05B4
    3f62:	90 91 b5 05 	lds	r25, 0x05B5
    3f66:	ac 01       	movw	r20, r24
    3f68:	46 23       	and	r20, r22
    3f6a:	57 23       	and	r21, r23
    3f6c:	20 91 b8 05 	lds	r18, 0x05B8
    3f70:	30 91 b9 05 	lds	r19, 0x05B9
    3f74:	82 23       	and	r24, r18
    3f76:	93 23       	and	r25, r19
    3f78:	48 17       	cp	r20, r24
    3f7a:	59 07       	cpc	r21, r25
    3f7c:	a1 f4       	brne	.+40     	; 0x3fa6 <uip_arp_out+0x82>
    3f7e:	e0 91 dc 05 	lds	r30, 0x05DC
    3f82:	f0 91 dd 05 	lds	r31, 0x05DD
    3f86:	80 91 b6 05 	lds	r24, 0x05B6
    3f8a:	90 91 b7 05 	lds	r25, 0x05B7
    3f8e:	af 01       	movw	r20, r30
    3f90:	48 23       	and	r20, r24
    3f92:	59 23       	and	r21, r25
    3f94:	20 91 ba 05 	lds	r18, 0x05BA
    3f98:	30 91 bb 05 	lds	r19, 0x05BB
    3f9c:	82 23       	and	r24, r18
    3f9e:	93 23       	and	r25, r19
    3fa0:	48 17       	cp	r20, r24
    3fa2:	59 07       	cpc	r21, r25
    3fa4:	89 f0       	breq	.+34     	; 0x3fc8 <uip_arp_out+0xa4>
      /* Destination address was not on the local network, so we need to
	 use the default router's IP address instead of the destination
	 address when determining the MAC address. */
      uip_ipaddr_copy(ipaddr, uip_draddr);
    3fa6:	80 91 84 05 	lds	r24, 0x0584
    3faa:	90 91 85 05 	lds	r25, 0x0585
    3fae:	90 93 c0 03 	sts	0x03C0, r25
    3fb2:	80 93 bf 03 	sts	0x03BF, r24
    3fb6:	80 91 86 05 	lds	r24, 0x0586
    3fba:	90 91 87 05 	lds	r25, 0x0587
    3fbe:	90 93 c2 03 	sts	0x03C2, r25
    3fc2:	80 93 c1 03 	sts	0x03C1, r24
    3fc6:	08 c0       	rjmp	.+16     	; 0x3fd8 <uip_arp_out+0xb4>
    } else {
      /* Else, we use the destination IP address. */
      uip_ipaddr_copy(ipaddr, IPBUF->destipaddr);
    3fc8:	70 93 c0 03 	sts	0x03C0, r23
    3fcc:	60 93 bf 03 	sts	0x03BF, r22
    3fd0:	f0 93 c2 03 	sts	0x03C2, r31
    3fd4:	e0 93 c1 03 	sts	0x03C1, r30
    }
      
    for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    3fd8:	10 92 c3 03 	sts	0x03C3, r1
      tabptr = &arp_table[i];
      if(uip_ipaddr_cmp(ipaddr, tabptr->ipaddr)) {
    3fdc:	60 91 bf 03 	lds	r22, 0x03BF
    3fe0:	70 91 c0 03 	lds	r23, 0x03C0
    3fe4:	40 91 c1 03 	lds	r20, 0x03C1
    3fe8:	50 91 c2 03 	lds	r21, 0x03C2
    3fec:	20 e0       	ldi	r18, 0x00	; 0
    3fee:	14 c0       	rjmp	.+40     	; 0x4018 <uip_arp_out+0xf4>
      /* Else, we use the destination IP address. */
      uip_ipaddr_copy(ipaddr, IPBUF->destipaddr);
    }
      
    for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
      tabptr = &arp_table[i];
    3ff0:	8b e0       	ldi	r24, 0x0B	; 11
    3ff2:	28 9f       	mul	r18, r24
    3ff4:	f0 01       	movw	r30, r0
    3ff6:	11 24       	eor	r1, r1
    3ff8:	ed 56       	subi	r30, 0x6D	; 109
    3ffa:	fc 4f       	sbci	r31, 0xFC	; 252
      if(uip_ipaddr_cmp(ipaddr, tabptr->ipaddr)) {
    3ffc:	80 81       	ld	r24, Z
    3ffe:	91 81       	ldd	r25, Z+1	; 0x01
    4000:	68 17       	cp	r22, r24
    4002:	79 07       	cpc	r23, r25
    4004:	41 f4       	brne	.+16     	; 0x4016 <uip_arp_out+0xf2>
    4006:	82 81       	ldd	r24, Z+2	; 0x02
    4008:	93 81       	ldd	r25, Z+3	; 0x03
    400a:	48 17       	cp	r20, r24
    400c:	59 07       	cpc	r21, r25
    400e:	19 f4       	brne	.+6      	; 0x4016 <uip_arp_out+0xf2>
    4010:	20 93 c3 03 	sts	0x03C3, r18
    4014:	69 c0       	rjmp	.+210    	; 0x40e8 <uip_arp_out+0x1c4>
    4016:	2f 5f       	subi	r18, 0xFF	; 255
    } else {
      /* Else, we use the destination IP address. */
      uip_ipaddr_copy(ipaddr, IPBUF->destipaddr);
    }
      
    for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    4018:	24 30       	cpi	r18, 0x04	; 4
    401a:	50 f3       	brcs	.-44     	; 0x3ff0 <uip_arp_out+0xcc>
    401c:	20 93 c3 03 	sts	0x03C3, r18
      if(uip_ipaddr_cmp(ipaddr, tabptr->ipaddr)) {
	break;
      }
    }

    if(i == UIP_ARPTAB_SIZE) {
    4020:	24 30       	cpi	r18, 0x04	; 4
    4022:	09 f0       	breq	.+2      	; 0x4026 <uip_arp_out+0x102>
    4024:	61 c0       	rjmp	.+194    	; 0x40e8 <uip_arp_out+0x1c4>
      /* The destination address was not in our ARP table, so we
	 overwrite the IP packet with an ARP request. */

      memset(BUF->ethhdr.dest.addr, 0xff, 6);
    4026:	46 e0       	ldi	r20, 0x06	; 6
    4028:	50 e0       	ldi	r21, 0x00	; 0
    402a:	6f ef       	ldi	r22, 0xFF	; 255
    402c:	70 e0       	ldi	r23, 0x00	; 0
    402e:	8c eb       	ldi	r24, 0xBC	; 188
    4030:	95 e0       	ldi	r25, 0x05	; 5
    4032:	0e 94 8b 2c 	call	0x5916	; 0x5916 <memset>
      memset(BUF->dhwaddr.addr, 0x00, 6);
    4036:	ec ed       	ldi	r30, 0xDC	; 220
    4038:	f5 e0       	ldi	r31, 0x05	; 5
    403a:	86 e0       	ldi	r24, 0x06	; 6
    403c:	df 01       	movw	r26, r30
    403e:	1d 92       	st	X+, r1
    4040:	8a 95       	dec	r24
    4042:	e9 f7       	brne	.-6      	; 0x403e <uip_arp_out+0x11a>
      memcpy(BUF->ethhdr.src.addr, uip_ethaddr.addr, 6);
    4044:	7a 97       	sbiw	r30, 0x1a	; 26
    4046:	a1 e8       	ldi	r26, 0x81	; 129
    4048:	b3 e0       	ldi	r27, 0x03	; 3
    404a:	86 e0       	ldi	r24, 0x06	; 6
    404c:	0d 90       	ld	r0, X+
    404e:	01 92       	st	Z+, r0
    4050:	81 50       	subi	r24, 0x01	; 1
    4052:	e1 f7       	brne	.-8      	; 0x404c <uip_arp_out+0x128>
      memcpy(BUF->shwaddr.addr, uip_ethaddr.addr, 6);
    4054:	a2 ed       	ldi	r26, 0xD2	; 210
    4056:	b5 e0       	ldi	r27, 0x05	; 5
    4058:	e1 e8       	ldi	r30, 0x81	; 129
    405a:	f3 e0       	ldi	r31, 0x03	; 3
    405c:	86 e0       	ldi	r24, 0x06	; 6
    405e:	01 90       	ld	r0, Z+
    4060:	0d 92       	st	X+, r0
    4062:	81 50       	subi	r24, 0x01	; 1
    4064:	e1 f7       	brne	.-8      	; 0x405e <uip_arp_out+0x13a>
    
      uip_ipaddr_copy(BUF->dipaddr, ipaddr);
    4066:	80 91 bf 03 	lds	r24, 0x03BF
    406a:	90 91 c0 03 	lds	r25, 0x03C0
    406e:	9f a3       	std	Y+39, r25	; 0x27
    4070:	8e a3       	std	Y+38, r24	; 0x26
    4072:	80 91 c1 03 	lds	r24, 0x03C1
    4076:	90 91 c2 03 	lds	r25, 0x03C2
    407a:	90 93 e5 05 	sts	0x05E5, r25
    407e:	80 93 e4 05 	sts	0x05E4, r24
      uip_ipaddr_copy(BUF->sipaddr, uip_hostaddr);
    4082:	80 91 b8 05 	lds	r24, 0x05B8
    4086:	90 91 b9 05 	lds	r25, 0x05B9
    408a:	9d 8f       	std	Y+29, r25	; 0x1d
    408c:	8c 8f       	std	Y+28, r24	; 0x1c
    408e:	80 91 ba 05 	lds	r24, 0x05BA
    4092:	90 91 bb 05 	lds	r25, 0x05BB
    4096:	90 93 db 05 	sts	0x05DB, r25
    409a:	80 93 da 05 	sts	0x05DA, r24
      BUF->opcode = HTONS(ARP_REQUEST); /* ARP request. */
    409e:	80 e0       	ldi	r24, 0x00	; 0
    40a0:	91 e0       	ldi	r25, 0x01	; 1
    40a2:	90 93 d1 05 	sts	0x05D1, r25
    40a6:	80 93 d0 05 	sts	0x05D0, r24
      BUF->hwtype = HTONS(ARP_HWTYPE_ETH);
    40aa:	90 93 cb 05 	sts	0x05CB, r25
    40ae:	80 93 ca 05 	sts	0x05CA, r24
      BUF->protocol = HTONS(UIP_ETHTYPE_IP);
    40b2:	88 e0       	ldi	r24, 0x08	; 8
    40b4:	90 e0       	ldi	r25, 0x00	; 0
    40b6:	90 93 cd 05 	sts	0x05CD, r25
    40ba:	80 93 cc 05 	sts	0x05CC, r24
      BUF->hwlen = 6;
    40be:	86 e0       	ldi	r24, 0x06	; 6
    40c0:	80 93 ce 05 	sts	0x05CE, r24
      BUF->protolen = 4;
    40c4:	84 e0       	ldi	r24, 0x04	; 4
    40c6:	80 93 cf 05 	sts	0x05CF, r24
      BUF->ethhdr.type = HTONS(UIP_ETHTYPE_ARP);
    40ca:	88 e0       	ldi	r24, 0x08	; 8
    40cc:	96 e0       	ldi	r25, 0x06	; 6
    40ce:	90 93 c9 05 	sts	0x05C9, r25
    40d2:	80 93 c8 05 	sts	0x05C8, r24

      uip_appdata = &uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN];
    40d6:	82 ef       	ldi	r24, 0xF2	; 242
    40d8:	95 e0       	ldi	r25, 0x05	; 5
    40da:	90 93 41 04 	sts	0x0441, r25
    40de:	80 93 40 04 	sts	0x0440, r24
    
      uip_len = sizeof(struct arp_hdr);
    40e2:	8a e2       	ldi	r24, 0x2A	; 42
    40e4:	90 e0       	ldi	r25, 0x00	; 0
    40e6:	1c c0       	rjmp	.+56     	; 0x4120 <uip_arp_out+0x1fc>
      return;
    }

    /* Build an ethernet header. */
    memcpy(IPBUF->ethhdr.dest.addr, tabptr->ethaddr.addr, 6);
    40e8:	ac eb       	ldi	r26, 0xBC	; 188
    40ea:	b5 e0       	ldi	r27, 0x05	; 5
    40ec:	34 96       	adiw	r30, 0x04	; 4
    40ee:	86 e0       	ldi	r24, 0x06	; 6
    40f0:	01 90       	ld	r0, Z+
    40f2:	0d 92       	st	X+, r0
    40f4:	81 50       	subi	r24, 0x01	; 1
    40f6:	e1 f7       	brne	.-8      	; 0x40f0 <uip_arp_out+0x1cc>
  }
  memcpy(IPBUF->ethhdr.src.addr, uip_ethaddr.addr, 6);
    40f8:	a2 ec       	ldi	r26, 0xC2	; 194
    40fa:	b5 e0       	ldi	r27, 0x05	; 5
    40fc:	e1 e8       	ldi	r30, 0x81	; 129
    40fe:	f3 e0       	ldi	r31, 0x03	; 3
    4100:	86 e0       	ldi	r24, 0x06	; 6
    4102:	01 90       	ld	r0, Z+
    4104:	0d 92       	st	X+, r0
    4106:	81 50       	subi	r24, 0x01	; 1
    4108:	e1 f7       	brne	.-8      	; 0x4102 <uip_arp_out+0x1de>
  
  IPBUF->ethhdr.type = HTONS(UIP_ETHTYPE_IP);
    410a:	88 e0       	ldi	r24, 0x08	; 8
    410c:	90 e0       	ldi	r25, 0x00	; 0
    410e:	90 93 c9 05 	sts	0x05C9, r25
    4112:	80 93 c8 05 	sts	0x05C8, r24

  uip_len += sizeof(struct uip_eth_hdr);
    4116:	80 91 37 04 	lds	r24, 0x0437
    411a:	90 91 38 04 	lds	r25, 0x0438
    411e:	0e 96       	adiw	r24, 0x0e	; 14
    4120:	90 93 38 04 	sts	0x0438, r25
    4124:	80 93 37 04 	sts	0x0437, r24
    4128:	df 91       	pop	r29
    412a:	cf 91       	pop	r28
    412c:	08 95       	ret

0000412e <uip_arp_timer>:
 *
 */
/*-----------------------------------------------------------------------------------*/
void
uip_arp_timer(void)
{
    412e:	80 91 c5 03 	lds	r24, 0x03C5
    4132:	8f 5f       	subi	r24, 0xFF	; 255
    4134:	80 93 c5 03 	sts	0x03C5, r24
  struct arp_entry *tabptr;
  
  ++arptime;
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    4138:	10 92 c3 03 	sts	0x03C3, r1
    413c:	20 c0       	rjmp	.+64     	; 0x417e <uip_arp_timer+0x50>
    tabptr = &arp_table[i];
    413e:	8b e0       	ldi	r24, 0x0B	; 11
    4140:	28 9f       	mul	r18, r24
    4142:	f0 01       	movw	r30, r0
    4144:	11 24       	eor	r1, r1
    4146:	ed 56       	subi	r30, 0x6D	; 109
    4148:	fc 4f       	sbci	r31, 0xFC	; 252
    if((tabptr->ipaddr[0] | tabptr->ipaddr[1]) != 0 &&
    414a:	82 81       	ldd	r24, Z+2	; 0x02
    414c:	93 81       	ldd	r25, Z+3	; 0x03
    414e:	20 81       	ld	r18, Z
    4150:	31 81       	ldd	r19, Z+1	; 0x01
    4152:	82 2b       	or	r24, r18
    4154:	93 2b       	or	r25, r19
    4156:	89 2b       	or	r24, r25
    4158:	69 f0       	breq	.+26     	; 0x4174 <uip_arp_timer+0x46>
    415a:	80 91 c5 03 	lds	r24, 0x03C5
    415e:	90 e0       	ldi	r25, 0x00	; 0
    4160:	22 85       	ldd	r18, Z+10	; 0x0a
    4162:	82 1b       	sub	r24, r18
    4164:	91 09       	sbc	r25, r1
    4166:	88 37       	cpi	r24, 0x78	; 120
    4168:	91 05       	cpc	r25, r1
    416a:	24 f0       	brlt	.+8      	; 0x4174 <uip_arp_timer+0x46>
       arptime - tabptr->time >= UIP_ARP_MAXAGE) {
      memset(tabptr->ipaddr, 0, 4);
    416c:	10 82       	st	Z, r1
    416e:	11 82       	std	Z+1, r1	; 0x01
    4170:	12 82       	std	Z+2, r1	; 0x02
    4172:	13 82       	std	Z+3, r1	; 0x03
uip_arp_timer(void)
{
  struct arp_entry *tabptr;
  
  ++arptime;
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    4174:	80 91 c3 03 	lds	r24, 0x03C3
    4178:	8f 5f       	subi	r24, 0xFF	; 255
    417a:	80 93 c3 03 	sts	0x03C3, r24
    417e:	20 91 c3 03 	lds	r18, 0x03C3
    4182:	24 30       	cpi	r18, 0x04	; 4
    4184:	e0 f2       	brcs	.-72     	; 0x413e <uip_arp_timer+0x10>
    4186:	08 95       	ret

00004188 <uip_arp_init>:
 *
 */
/*-----------------------------------------------------------------------------------*/
void
uip_arp_init(void)
{
    4188:	10 92 c3 03 	sts	0x03C3, r1
    418c:	0d c0       	rjmp	.+26     	; 0x41a8 <uip_arp_init+0x20>
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    memset(arp_table[i].ipaddr, 0, 4);
    418e:	eb e0       	ldi	r30, 0x0B	; 11
    4190:	8e 9f       	mul	r24, r30
    4192:	f0 01       	movw	r30, r0
    4194:	11 24       	eor	r1, r1
    4196:	ed 56       	subi	r30, 0x6D	; 109
    4198:	fc 4f       	sbci	r31, 0xFC	; 252
    419a:	10 82       	st	Z, r1
    419c:	11 82       	std	Z+1, r1	; 0x01
    419e:	12 82       	std	Z+2, r1	; 0x02
    41a0:	13 82       	std	Z+3, r1	; 0x03
 */
/*-----------------------------------------------------------------------------------*/
void
uip_arp_init(void)
{
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    41a2:	8f 5f       	subi	r24, 0xFF	; 255
    41a4:	80 93 c3 03 	sts	0x03C3, r24
    41a8:	80 91 c3 03 	lds	r24, 0x03C3
    41ac:	84 30       	cpi	r24, 0x04	; 4
    41ae:	78 f3       	brcs	.-34     	; 0x418e <uip_arp_init+0x6>
    41b0:	08 95       	ret

000041b2 <uiplib_ipaddrconv>:


/*-----------------------------------------------------------------------------------*/
unsigned char
uiplib_ipaddrconv(char *addrstr, unsigned char *ipaddr)
{
    41b2:	fc 01       	movw	r30, r24
    41b4:	db 01       	movw	r26, r22
    41b6:	90 e0       	ldi	r25, 0x00	; 0
    41b8:	40 e0       	ldi	r20, 0x00	; 0
    41ba:	30 e0       	ldi	r19, 0x00	; 0
    41bc:	03 c0       	rjmp	.+6      	; 0x41c4 <uiplib_ipaddrconv+0x12>
  char c;
  unsigned char i, j;

  tmp = 0;
  
  for(i = 0; i < 4; ++i) {
    41be:	40 e0       	ldi	r20, 0x00	; 0
    41c0:	90 e0       	ldi	r25, 0x00	; 0
      } else if(c >= '0' && c <= '9') {
	tmp = (tmp * 10) + (c - '0');
      } else {
	return 0;
      }
      ++addrstr;
    41c2:	31 96       	adiw	r30, 0x01	; 1
  tmp = 0;
  
  for(i = 0; i < 4; ++i) {
    j = 0;
    do {
      c = *addrstr;
    41c4:	80 81       	ld	r24, Z
      ++j;
    41c6:	4f 5f       	subi	r20, 0xFF	; 255
      if(j > 4) {
    41c8:	45 30       	cpi	r20, 0x05	; 5
    41ca:	d8 f4       	brcc	.+54     	; 0x4202 <uiplib_ipaddrconv+0x50>
	return 0;
      }
      if(c == '.' || c == 0) {
    41cc:	8e 32       	cpi	r24, 0x2E	; 46
    41ce:	11 f0       	breq	.+4      	; 0x41d4 <uiplib_ipaddrconv+0x22>
    41d0:	88 23       	and	r24, r24
    41d2:	21 f4       	brne	.+8      	; 0x41dc <uiplib_ipaddrconv+0x2a>
	*ipaddr = tmp;
    41d4:	9d 93       	st	X+, r25
	tmp = (tmp * 10) + (c - '0');
      } else {
	return 0;
      }
      ++addrstr;
    } while(c != '.' && c != 0);
    41d6:	8e 32       	cpi	r24, 0x2E	; 46
    41d8:	61 f4       	brne	.+24     	; 0x41f2 <uiplib_ipaddrconv+0x40>
    41da:	0d c0       	rjmp	.+26     	; 0x41f6 <uiplib_ipaddrconv+0x44>
      }
      if(c == '.' || c == 0) {
	*ipaddr = tmp;
	++ipaddr;
	tmp = 0;
      } else if(c >= '0' && c <= '9') {
    41dc:	28 2f       	mov	r18, r24
    41de:	20 53       	subi	r18, 0x30	; 48
    41e0:	2a 30       	cpi	r18, 0x0A	; 10
    41e2:	78 f4       	brcc	.+30     	; 0x4202 <uiplib_ipaddrconv+0x50>
	tmp = (tmp * 10) + (c - '0');
    41e4:	8a e0       	ldi	r24, 0x0A	; 10
    41e6:	98 9f       	mul	r25, r24
    41e8:	c0 01       	movw	r24, r0
    41ea:	11 24       	eor	r1, r1
    41ec:	92 2f       	mov	r25, r18
    41ee:	98 0f       	add	r25, r24
    41f0:	e8 cf       	rjmp	.-48     	; 0x41c2 <uiplib_ipaddrconv+0x10>
      } else {
	return 0;
      }
      ++addrstr;
    } while(c != '.' && c != 0);
    41f2:	88 23       	and	r24, r24
    41f4:	29 f7       	brne	.-54     	; 0x41c0 <uiplib_ipaddrconv+0xe>
  char c;
  unsigned char i, j;

  tmp = 0;
  
  for(i = 0; i < 4; ++i) {
    41f6:	3f 5f       	subi	r19, 0xFF	; 255
    41f8:	34 30       	cpi	r19, 0x04	; 4
    41fa:	08 f3       	brcs	.-62     	; 0x41be <uiplib_ipaddrconv+0xc>
    41fc:	81 e0       	ldi	r24, 0x01	; 1
    41fe:	90 e0       	ldi	r25, 0x00	; 0
    4200:	08 95       	ret
    4202:	80 e0       	ldi	r24, 0x00	; 0
    4204:	90 e0       	ldi	r25, 0x00	; 0
      }
      ++addrstr;
    } while(c != '.' && c != 0);
  }
  return 1;
}
    4206:	08 95       	ret

00004208 <data_acked>:
}

/*---------------------------------------------------------------------------*/
static char
data_acked(register struct psock *s)
{
    4208:	cf 93       	push	r28
    420a:	df 93       	push	r29
    420c:	fc 01       	movw	r30, r24
  if(s->state == STATE_DATA_SENT && uip_acked()) {
    420e:	84 89       	ldd	r24, Z+20	; 0x14
    4210:	86 30       	cpi	r24, 0x06	; 6
    4212:	41 f5       	brne	.+80     	; 0x4264 <data_acked+0x5c>
    4214:	80 91 3f 04 	lds	r24, 0x043F
    4218:	80 ff       	sbrs	r24, 0
    421a:	24 c0       	rjmp	.+72     	; 0x4264 <data_acked+0x5c>
    if(s->sendlen > uip_mss()) {
    421c:	82 85       	ldd	r24, Z+10	; 0x0a
    421e:	93 85       	ldd	r25, Z+11	; 0x0b
    4220:	a0 91 42 04 	lds	r26, 0x0442
    4224:	b0 91 43 04 	lds	r27, 0x0443
    4228:	ed 01       	movw	r28, r26
    422a:	4a 89       	ldd	r20, Y+18	; 0x12
    422c:	5b 89       	ldd	r21, Y+19	; 0x13
    422e:	24 81       	ldd	r18, Z+4	; 0x04
    4230:	35 81       	ldd	r19, Z+5	; 0x05
    4232:	48 17       	cp	r20, r24
    4234:	59 07       	cpc	r21, r25
    4236:	58 f4       	brcc	.+22     	; 0x424e <data_acked+0x46>
      s->sendlen -= uip_mss();
    4238:	84 1b       	sub	r24, r20
    423a:	95 0b       	sbc	r25, r21
    423c:	93 87       	std	Z+11, r25	; 0x0b
    423e:	82 87       	std	Z+10, r24	; 0x0a
      s->sendptr += uip_mss();
    4240:	8a 89       	ldd	r24, Y+18	; 0x12
    4242:	9b 89       	ldd	r25, Y+19	; 0x13
    4244:	28 0f       	add	r18, r24
    4246:	39 1f       	adc	r19, r25
    4248:	35 83       	std	Z+5, r19	; 0x05
    424a:	24 83       	std	Z+4, r18	; 0x04
    424c:	06 c0       	rjmp	.+12     	; 0x425a <data_acked+0x52>
    } else {
      s->sendptr += s->sendlen;
    424e:	28 0f       	add	r18, r24
    4250:	39 1f       	adc	r19, r25
    4252:	35 83       	std	Z+5, r19	; 0x05
    4254:	24 83       	std	Z+4, r18	; 0x04
      s->sendlen = 0;
    4256:	13 86       	std	Z+11, r1	; 0x0b
    4258:	12 86       	std	Z+10, r1	; 0x0a
    }
    s->state = STATE_ACKED;
    425a:	81 e0       	ldi	r24, 0x01	; 1
    425c:	84 8b       	std	Z+20, r24	; 0x14
    425e:	81 e0       	ldi	r24, 0x01	; 1
    4260:	90 e0       	ldi	r25, 0x00	; 0
    4262:	02 c0       	rjmp	.+4      	; 0x4268 <data_acked+0x60>
    return 1;
    4264:	80 e0       	ldi	r24, 0x00	; 0
    4266:	90 e0       	ldi	r25, 0x00	; 0
    4268:	df 91       	pop	r29
    426a:	cf 91       	pop	r28
    426c:	08 95       	ret

0000426e <psock_datalen>:
  PT_END(&s->psockpt);
}
/*---------------------------------------------------------------------------*/
u16_t
psock_datalen(struct psock *psock)
{
    426e:	fc 01       	movw	r30, r24
    4270:	82 89       	ldd	r24, Z+18	; 0x12
    4272:	93 89       	ldd	r25, Z+19	; 0x13
    4274:	20 89       	ldd	r18, Z+16	; 0x10
    4276:	31 89       	ldd	r19, Z+17	; 0x11
  return psock->bufsize - psock->buf.left;
}
    4278:	82 1b       	sub	r24, r18
    427a:	93 0b       	sbc	r25, r19
    427c:	08 95       	ret

0000427e <psock_newdata>:
/*---------------------------------------------------------------------------*/
char
psock_newdata(struct psock *s)
{
    427e:	fc 01       	movw	r30, r24
  if(s->readlen > 0) {
    4280:	84 85       	ldd	r24, Z+12	; 0x0c
    4282:	95 85       	ldd	r25, Z+13	; 0x0d
    4284:	89 2b       	or	r24, r25
    4286:	19 f0       	breq	.+6      	; 0x428e <psock_newdata+0x10>
    4288:	81 e0       	ldi	r24, 0x01	; 1
    428a:	90 e0       	ldi	r25, 0x00	; 0
    428c:	08 95       	ret
    /* There is data in the uip_appdata buffer that has not yet been
       read with the PSOCK_READ functions. */
    return 1;
  } else if(s->state == STATE_READ) {
    428e:	84 89       	ldd	r24, Z+20	; 0x14
    4290:	82 30       	cpi	r24, 0x02	; 2
    4292:	29 f4       	brne	.+10     	; 0x429e <psock_newdata+0x20>
    /* All data in uip_appdata buffer already consumed. */
    s->state = STATE_BLOCKED_NEWDATA;
    4294:	83 e0       	ldi	r24, 0x03	; 3
    4296:	84 8b       	std	Z+20, r24	; 0x14
    4298:	80 e0       	ldi	r24, 0x00	; 0
    429a:	90 e0       	ldi	r25, 0x00	; 0
    429c:	08 95       	ret
    return 0;
    429e:	80 91 3f 04 	lds	r24, 0x043F
    42a2:	90 e0       	ldi	r25, 0x00	; 0
    42a4:	96 95       	lsr	r25
    42a6:	87 95       	ror	r24
    42a8:	81 70       	andi	r24, 0x01	; 1
    42aa:	90 70       	andi	r25, 0x00	; 0
    return 1;
  } else {
    /* There is no new data. */
    return 0;
  }
}
    42ac:	08 95       	ret

000042ae <send_data>:
  return BUF_FULL;
}
/*---------------------------------------------------------------------------*/
static char
send_data(register struct psock *s)
{
    42ae:	cf 93       	push	r28
    42b0:	df 93       	push	r29
    42b2:	ec 01       	movw	r28, r24
  if(s->state != STATE_DATA_SENT || uip_rexmit()) {
    42b4:	8c 89       	ldd	r24, Y+20	; 0x14
    42b6:	86 30       	cpi	r24, 0x06	; 6
    42b8:	39 f4       	brne	.+14     	; 0x42c8 <send_data+0x1a>
    42ba:	80 91 3f 04 	lds	r24, 0x043F
    42be:	82 fd       	sbrc	r24, 2
    42c0:	03 c0       	rjmp	.+6      	; 0x42c8 <send_data+0x1a>
    42c2:	80 e0       	ldi	r24, 0x00	; 0
    42c4:	90 e0       	ldi	r25, 0x00	; 0
    42c6:	14 c0       	rjmp	.+40     	; 0x42f0 <send_data+0x42>
    if(s->sendlen > uip_mss()) {
    42c8:	2a 85       	ldd	r18, Y+10	; 0x0a
    42ca:	3b 85       	ldd	r19, Y+11	; 0x0b
    42cc:	e0 91 42 04 	lds	r30, 0x0442
    42d0:	f0 91 43 04 	lds	r31, 0x0443
    42d4:	62 89       	ldd	r22, Z+18	; 0x12
    42d6:	73 89       	ldd	r23, Z+19	; 0x13
    42d8:	8c 81       	ldd	r24, Y+4	; 0x04
    42da:	9d 81       	ldd	r25, Y+5	; 0x05
    42dc:	62 17       	cp	r22, r18
    42de:	73 07       	cpc	r23, r19
    42e0:	08 f0       	brcs	.+2      	; 0x42e4 <send_data+0x36>
      uip_send(s->sendptr, uip_mss());
    } else {
      uip_send(s->sendptr, s->sendlen);
    42e2:	b9 01       	movw	r22, r18
    42e4:	0e 94 f3 15 	call	0x2be6	; 0x2be6 <uip_send>
    }
    s->state = STATE_DATA_SENT;
    42e8:	86 e0       	ldi	r24, 0x06	; 6
    42ea:	8c 8b       	std	Y+20, r24	; 0x14
    42ec:	81 e0       	ldi	r24, 0x01	; 1
    42ee:	90 e0       	ldi	r25, 0x00	; 0
    42f0:	df 91       	pop	r29
    42f2:	cf 91       	pop	r28
    42f4:	08 95       	ret

000042f6 <psock_generator_send>:
  PT_END(&s->psockpt);
}
/*---------------------------------------------------------------------------*/
PT_THREAD(psock_generator_send(register struct psock *s,
			       unsigned short (*generate)(void *), void *arg))
{
    42f6:	cf 92       	push	r12
    42f8:	df 92       	push	r13
    42fa:	ef 92       	push	r14
    42fc:	ff 92       	push	r15
    42fe:	1f 93       	push	r17
    4300:	cf 93       	push	r28
    4302:	df 93       	push	r29
    4304:	ec 01       	movw	r28, r24
    4306:	7b 01       	movw	r14, r22
    4308:	6a 01       	movw	r12, r20
  PT_BEGIN(&s->psockpt);
    430a:	8a 81       	ldd	r24, Y+2	; 0x02
    430c:	9b 81       	ldd	r25, Y+3	; 0x03
    430e:	00 97       	sbiw	r24, 0x00	; 0
    4310:	21 f0       	breq	.+8      	; 0x431a <psock_generator_send+0x24>
    4312:	8a 52       	subi	r24, 0x2A	; 42
    4314:	91 40       	sbci	r25, 0x01	; 1
    4316:	89 f5       	brne	.+98     	; 0x437a <psock_generator_send+0x84>
    4318:	1f c0       	rjmp	.+62     	; 0x4358 <psock_generator_send+0x62>

  /* Ensure that there is a generator function to call. */
  if(generate == NULL) {
    431a:	61 15       	cp	r22, r1
    431c:	71 05       	cpc	r23, r1
    431e:	29 f4       	brne	.+10     	; 0x432a <psock_generator_send+0x34>
    PT_EXIT(&s->psockpt);
    4320:	1b 82       	std	Y+3, r1	; 0x03
    4322:	1a 82       	std	Y+2, r1	; 0x02
    4324:	81 e0       	ldi	r24, 0x01	; 1
    4326:	90 e0       	ldi	r25, 0x00	; 0
    4328:	2c c0       	rjmp	.+88     	; 0x4382 <psock_generator_send+0x8c>
  }

  /* Call the generator function to generate the data in the
     uip_appdata buffer. */
  s->sendlen = generate(arg);
    432a:	ca 01       	movw	r24, r20
    432c:	fb 01       	movw	r30, r22
    432e:	09 95       	icall
    4330:	9b 87       	std	Y+11, r25	; 0x0b
    4332:	8a 87       	std	Y+10, r24	; 0x0a
  s->sendptr = uip_appdata;
    4334:	80 91 40 04 	lds	r24, 0x0440
    4338:	90 91 41 04 	lds	r25, 0x0441
    433c:	9d 83       	std	Y+5, r25	; 0x05
    433e:	8c 83       	std	Y+4, r24	; 0x04

  s->state = STATE_NONE;  
    4340:	1c 8a       	std	Y+20, r1	; 0x14
  do {
    /* Call the generator function again if we are called to perform a
       retransmission. */
    if(uip_rexmit()) {
    4342:	80 91 3f 04 	lds	r24, 0x043F
    4346:	82 ff       	sbrs	r24, 2
    4348:	03 c0       	rjmp	.+6      	; 0x4350 <psock_generator_send+0x5a>
      generate(arg);
    434a:	c6 01       	movw	r24, r12
    434c:	f7 01       	movw	r30, r14
    434e:	09 95       	icall
    }
    /* Wait until all data is sent and acknowledged. */
    PT_WAIT_UNTIL(&s->psockpt, data_acked(s) & send_data(s));
    4350:	8a e2       	ldi	r24, 0x2A	; 42
    4352:	91 e0       	ldi	r25, 0x01	; 1
    4354:	9b 83       	std	Y+3, r25	; 0x03
    4356:	8a 83       	std	Y+2, r24	; 0x02
    4358:	ce 01       	movw	r24, r28
    435a:	0e 94 04 21 	call	0x4208	; 0x4208 <data_acked>
    435e:	18 2f       	mov	r17, r24
    4360:	ce 01       	movw	r24, r28
    4362:	0e 94 57 21 	call	0x42ae	; 0x42ae <send_data>
    4366:	18 23       	and	r17, r24
    4368:	19 f4       	brne	.+6      	; 0x4370 <psock_generator_send+0x7a>
    436a:	80 e0       	ldi	r24, 0x00	; 0
    436c:	90 e0       	ldi	r25, 0x00	; 0
    436e:	09 c0       	rjmp	.+18     	; 0x4382 <psock_generator_send+0x8c>
  } while(s->sendlen > 0);
    4370:	8a 85       	ldd	r24, Y+10	; 0x0a
    4372:	9b 85       	ldd	r25, Y+11	; 0x0b
    4374:	89 2b       	or	r24, r25
    4376:	29 f7       	brne	.-54     	; 0x4342 <psock_generator_send+0x4c>
  
  s->state = STATE_NONE;
    4378:	1c 8a       	std	Y+20, r1	; 0x14
  
  PT_END(&s->psockpt);
    437a:	1b 82       	std	Y+3, r1	; 0x03
    437c:	1a 82       	std	Y+2, r1	; 0x02
    437e:	82 e0       	ldi	r24, 0x02	; 2
    4380:	90 e0       	ldi	r25, 0x00	; 0
    4382:	df 91       	pop	r29
    4384:	cf 91       	pop	r28
    4386:	1f 91       	pop	r17
    4388:	ff 90       	pop	r15
    438a:	ef 90       	pop	r14
    438c:	df 90       	pop	r13
    438e:	cf 90       	pop	r12
    4390:	08 95       	ret

00004392 <psock_send>:
  return 0;
}
/*---------------------------------------------------------------------------*/
PT_THREAD(psock_send(register struct psock *s, const char *buf,
		     unsigned int len))
{
    4392:	1f 93       	push	r17
    4394:	cf 93       	push	r28
    4396:	df 93       	push	r29
    4398:	ec 01       	movw	r28, r24
	PT_BEGIN(&s->psockpt);
    439a:	8a 81       	ldd	r24, Y+2	; 0x02
    439c:	9b 81       	ldd	r25, Y+3	; 0x03
    439e:	00 97       	sbiw	r24, 0x00	; 0
    43a0:	21 f0       	breq	.+8      	; 0x43aa <psock_send+0x18>
    43a2:	82 3e       	cpi	r24, 0xE2	; 226
    43a4:	91 05       	cpc	r25, r1
    43a6:	21 f5       	brne	.+72     	; 0x43f0 <psock_send+0x5e>
    43a8:	12 c0       	rjmp	.+36     	; 0x43ce <psock_send+0x3c>
	
	/* If there is no data to send, we exit immediately. */
  if(len == 0) {
    43aa:	41 15       	cp	r20, r1
    43ac:	51 05       	cpc	r21, r1
    43ae:	29 f4       	brne	.+10     	; 0x43ba <psock_send+0x28>
    PT_EXIT(&s->psockpt);
    43b0:	1b 82       	std	Y+3, r1	; 0x03
    43b2:	1a 82       	std	Y+2, r1	; 0x02
    43b4:	81 e0       	ldi	r24, 0x01	; 1
    43b6:	90 e0       	ldi	r25, 0x00	; 0
    43b8:	1f c0       	rjmp	.+62     	; 0x43f8 <psock_send+0x66>
  }

  /* Save the length of and a pointer to the data that is to be
     sent. */
  s->sendptr = buf;
    43ba:	7d 83       	std	Y+5, r23	; 0x05
    43bc:	6c 83       	std	Y+4, r22	; 0x04
  s->sendlen = len;
    43be:	5b 87       	std	Y+11, r21	; 0x0b
    43c0:	4a 87       	std	Y+10, r20	; 0x0a
	
  s->state = STATE_NONE;
    43c2:	1c 8a       	std	Y+20, r1	; 0x14
    43c4:	10 c0       	rjmp	.+32     	; 0x43e6 <psock_send+0x54>
     * send_data() must be called in succession to ensure that all
     * data is sent. Therefore the & operator is used instead of the
     * && operator, which would cause only the data_acked() function
     * to be called when it returns false.
     */
    PT_WAIT_UNTIL(&s->psockpt, data_acked(s) & send_data(s));
    43c6:	82 ee       	ldi	r24, 0xE2	; 226
    43c8:	90 e0       	ldi	r25, 0x00	; 0
    43ca:	9b 83       	std	Y+3, r25	; 0x03
    43cc:	8a 83       	std	Y+2, r24	; 0x02
    43ce:	ce 01       	movw	r24, r28
    43d0:	0e 94 04 21 	call	0x4208	; 0x4208 <data_acked>
    43d4:	18 2f       	mov	r17, r24
    43d6:	ce 01       	movw	r24, r28
    43d8:	0e 94 57 21 	call	0x42ae	; 0x42ae <send_data>
    43dc:	18 23       	and	r17, r24
    43de:	19 f4       	brne	.+6      	; 0x43e6 <psock_send+0x54>
    43e0:	80 e0       	ldi	r24, 0x00	; 0
    43e2:	90 e0       	ldi	r25, 0x00	; 0
    43e4:	09 c0       	rjmp	.+18     	; 0x43f8 <psock_send+0x66>
	
  s->state = STATE_NONE;

  /* We loop here until all data is sent. The s->sendlen variable is
     updated by the data_sent() function. */
  while(s->sendlen > 0) {
    43e6:	8a 85       	ldd	r24, Y+10	; 0x0a
    43e8:	9b 85       	ldd	r25, Y+11	; 0x0b
    43ea:	89 2b       	or	r24, r25
    43ec:	61 f7       	brne	.-40     	; 0x43c6 <psock_send+0x34>
     * to be called when it returns false.
     */
    PT_WAIT_UNTIL(&s->psockpt, data_acked(s) & send_data(s));
  }

  s->state = STATE_NONE;
    43ee:	1c 8a       	std	Y+20, r1	; 0x14
  
  PT_END(&s->psockpt);
    43f0:	1b 82       	std	Y+3, r1	; 0x03
    43f2:	1a 82       	std	Y+2, r1	; 0x02
    43f4:	82 e0       	ldi	r24, 0x02	; 2
    43f6:	90 e0       	ldi	r25, 0x00	; 0
    43f8:	df 91       	pop	r29
    43fa:	cf 91       	pop	r28
    43fc:	1f 91       	pop	r17
    43fe:	08 95       	ret

00004400 <psock_send_P>:
}

/*---------------------------------------------------------------------------*/
PT_THREAD(psock_send_P(register struct psock *s, const char *buf,
		     unsigned int len))
{
    4400:	1f 93       	push	r17
    4402:	cf 93       	push	r28
    4404:	df 93       	push	r29
    4406:	ec 01       	movw	r28, r24
	PT_BEGIN(&s->psockpt);
    4408:	8a 81       	ldd	r24, Y+2	; 0x02
    440a:	9b 81       	ldd	r25, Y+3	; 0x03
    440c:	00 97       	sbiw	r24, 0x00	; 0
    440e:	29 f0       	breq	.+10     	; 0x441a <psock_send_P+0x1a>
    4410:	8b 50       	subi	r24, 0x0B	; 11
    4412:	91 40       	sbci	r25, 0x01	; 1
    4414:	09 f0       	breq	.+2      	; 0x4418 <psock_send_P+0x18>
    4416:	3f c0       	rjmp	.+126    	; 0x4496 <psock_send_P+0x96>
    4418:	12 c0       	rjmp	.+36     	; 0x443e <psock_send_P+0x3e>
	
	/* If there is no data to send, we exit immediately. */
  if(len == 0) {
    441a:	41 15       	cp	r20, r1
    441c:	51 05       	cpc	r21, r1
    441e:	29 f4       	brne	.+10     	; 0x442a <psock_send_P+0x2a>
    PT_EXIT(&s->psockpt);
    4420:	1b 82       	std	Y+3, r1	; 0x03
    4422:	1a 82       	std	Y+2, r1	; 0x02
    4424:	81 e0       	ldi	r24, 0x01	; 1
    4426:	90 e0       	ldi	r25, 0x00	; 0
    4428:	3a c0       	rjmp	.+116    	; 0x449e <psock_send_P+0x9e>
  }

  /* Save the length of and a pointer to the data that is to be
     sent. */
  s->sendptr = buf;
    442a:	7d 83       	std	Y+5, r23	; 0x05
    442c:	6c 83       	std	Y+4, r22	; 0x04
  s->sendlen = len;
    442e:	5b 87       	std	Y+11, r21	; 0x0b
    4430:	4a 87       	std	Y+10, r20	; 0x0a
	
	
  s->state = STATE_NONE;
    4432:	1c 8a       	std	Y+20, r1	; 0x14
    4434:	2b c0       	rjmp	.+86     	; 0x448c <psock_send_P+0x8c>
     * send_data() must be called in succession to ensure that all
     * data is sent. Therefore the & operator is used instead of the
     * && operator, which would cause only the data_acked() function
     * to be called when it returns false.
     */
    PT_WAIT_UNTIL(&s->psockpt, data_acked(s) & send_data_P(s));
    4436:	8b e0       	ldi	r24, 0x0B	; 11
    4438:	91 e0       	ldi	r25, 0x01	; 1
    443a:	9b 83       	std	Y+3, r25	; 0x03
    443c:	8a 83       	std	Y+2, r24	; 0x02
    443e:	ce 01       	movw	r24, r28
    4440:	0e 94 04 21 	call	0x4208	; 0x4208 <data_acked>
    4444:	18 2f       	mov	r17, r24
}
/*---------------------------------------------------------------------------*/
static char
send_data_P(register struct psock *s)
{
  if(s->state != STATE_DATA_SENT || uip_rexmit()) {
    4446:	8c 89       	ldd	r24, Y+20	; 0x14
    4448:	86 30       	cpi	r24, 0x06	; 6
    444a:	39 f4       	brne	.+14     	; 0x445a <psock_send_P+0x5a>
    444c:	80 91 3f 04 	lds	r24, 0x043F
    4450:	82 fd       	sbrc	r24, 2
    4452:	03 c0       	rjmp	.+6      	; 0x445a <psock_send_P+0x5a>
    4454:	80 e0       	ldi	r24, 0x00	; 0
    4456:	90 e0       	ldi	r25, 0x00	; 0
    4458:	14 c0       	rjmp	.+40     	; 0x4482 <psock_send_P+0x82>
    if(s->sendlen > uip_mss()) {
    445a:	2a 85       	ldd	r18, Y+10	; 0x0a
    445c:	3b 85       	ldd	r19, Y+11	; 0x0b
    445e:	e0 91 42 04 	lds	r30, 0x0442
    4462:	f0 91 43 04 	lds	r31, 0x0443
    4466:	62 89       	ldd	r22, Z+18	; 0x12
    4468:	73 89       	ldd	r23, Z+19	; 0x13
    446a:	8c 81       	ldd	r24, Y+4	; 0x04
    446c:	9d 81       	ldd	r25, Y+5	; 0x05
    446e:	62 17       	cp	r22, r18
    4470:	73 07       	cpc	r23, r19
    4472:	08 f0       	brcs	.+2      	; 0x4476 <psock_send_P+0x76>
      uip_send_P(s->sendptr, uip_mss());
    } else {
      uip_send_P(s->sendptr, s->sendlen);
    4474:	b9 01       	movw	r22, r18
    4476:	0e 94 07 16 	call	0x2c0e	; 0x2c0e <uip_send_P>
    }
    s->state = STATE_DATA_SENT;
    447a:	86 e0       	ldi	r24, 0x06	; 6
    447c:	8c 8b       	std	Y+20, r24	; 0x14
    447e:	81 e0       	ldi	r24, 0x01	; 1
    4480:	90 e0       	ldi	r25, 0x00	; 0
     * send_data() must be called in succession to ensure that all
     * data is sent. Therefore the & operator is used instead of the
     * && operator, which would cause only the data_acked() function
     * to be called when it returns false.
     */
    PT_WAIT_UNTIL(&s->psockpt, data_acked(s) & send_data_P(s));
    4482:	18 23       	and	r17, r24
    4484:	19 f4       	brne	.+6      	; 0x448c <psock_send_P+0x8c>
    4486:	80 e0       	ldi	r24, 0x00	; 0
    4488:	90 e0       	ldi	r25, 0x00	; 0
    448a:	09 c0       	rjmp	.+18     	; 0x449e <psock_send_P+0x9e>
	
  s->state = STATE_NONE;

  /* We loop here until all data is sent. The s->sendlen variable is
     updated by the data_sent() function. */
  while(s->sendlen > 0) {
    448c:	8a 85       	ldd	r24, Y+10	; 0x0a
    448e:	9b 85       	ldd	r25, Y+11	; 0x0b
    4490:	89 2b       	or	r24, r25
    4492:	89 f6       	brne	.-94     	; 0x4436 <psock_send_P+0x36>
     * to be called when it returns false.
     */
    PT_WAIT_UNTIL(&s->psockpt, data_acked(s) & send_data_P(s));
  }

  s->state = STATE_NONE;
    4494:	1c 8a       	std	Y+20, r1	; 0x14
  
  PT_END(&s->psockpt);
    4496:	1b 82       	std	Y+3, r1	; 0x03
    4498:	1a 82       	std	Y+2, r1	; 0x02
    449a:	82 e0       	ldi	r24, 0x02	; 2
    449c:	90 e0       	ldi	r25, 0x00	; 0
    449e:	df 91       	pop	r29
    44a0:	cf 91       	pop	r28
    44a2:	1f 91       	pop	r17
    44a4:	08 95       	ret

000044a6 <psock_init>:
  PT_END(&psock->psockpt);
}
/*---------------------------------------------------------------------------*/
void
psock_init(register struct psock *psock, char *buffer, unsigned int buffersize)
{
    44a6:	fc 01       	movw	r30, r24
  psock->state = STATE_NONE;
    44a8:	14 8a       	std	Z+20, r1	; 0x14
  psock->readlen = 0;
    44aa:	15 86       	std	Z+13, r1	; 0x0d
    44ac:	14 86       	std	Z+12, r1	; 0x0c
  psock->bufptr = buffer;
    44ae:	71 87       	std	Z+9, r23	; 0x09
    44b0:	60 87       	std	Z+8, r22	; 0x08
  psock->bufsize = buffersize;
    44b2:	53 8b       	std	Z+19, r21	; 0x13
    44b4:	42 8b       	std	Z+18, r20	; 0x12
/*---------------------------------------------------------------------------*/
static void
buf_setup(struct psock_buf *buf,
	  u8_t *bufptr, u16_t bufsize)
{
  buf->ptr = bufptr;
    44b6:	77 87       	std	Z+15, r23	; 0x0f
    44b8:	66 87       	std	Z+14, r22	; 0x0e
  buf->left = bufsize;
    44ba:	51 8b       	std	Z+17, r21	; 0x11
    44bc:	40 8b       	std	Z+16, r20	; 0x10
  psock->state = STATE_NONE;
  psock->readlen = 0;
  psock->bufptr = buffer;
  psock->bufsize = buffersize;
  buf_setup(&psock->buf, buffer, buffersize);
  PT_INIT(&psock->pt);
    44be:	11 82       	std	Z+1, r1	; 0x01
    44c0:	10 82       	st	Z, r1
  PT_INIT(&psock->psockpt);
    44c2:	13 82       	std	Z+3, r1	; 0x03
    44c4:	12 82       	std	Z+2, r1	; 0x02
    44c6:	08 95       	ret

000044c8 <psock_readbuf>:
  }
  PT_END(&psock->psockpt);
}
/*---------------------------------------------------------------------------*/
PT_THREAD(psock_readbuf(register struct psock *psock))
{
    44c8:	cf 93       	push	r28
    44ca:	df 93       	push	r29
    44cc:	ec 01       	movw	r28, r24
  PT_BEGIN(&psock->psockpt);
    44ce:	8a 81       	ldd	r24, Y+2	; 0x02
    44d0:	9b 81       	ldd	r25, Y+3	; 0x03
    44d2:	00 97       	sbiw	r24, 0x00	; 0
    44d4:	29 f0       	breq	.+10     	; 0x44e0 <psock_readbuf+0x18>
    44d6:	82 57       	subi	r24, 0x72	; 114
    44d8:	91 40       	sbci	r25, 0x01	; 1
    44da:	09 f0       	breq	.+2      	; 0x44de <psock_readbuf+0x16>
    44dc:	8b c0       	rjmp	.+278    	; 0x45f4 <psock_readbuf+0x12c>
    44de:	10 c0       	rjmp	.+32     	; 0x4500 <psock_readbuf+0x38>

  buf_setup(&psock->buf, psock->bufptr, psock->bufsize);
    44e0:	2a 89       	ldd	r18, Y+18	; 0x12
    44e2:	3b 89       	ldd	r19, Y+19	; 0x13
/*---------------------------------------------------------------------------*/
static void
buf_setup(struct psock_buf *buf,
	  u8_t *bufptr, u16_t bufsize)
{
  buf->ptr = bufptr;
    44e4:	88 85       	ldd	r24, Y+8	; 0x08
    44e6:	99 85       	ldd	r25, Y+9	; 0x09
    44e8:	9f 87       	std	Y+15, r25	; 0x0f
    44ea:	8e 87       	std	Y+14, r24	; 0x0e
  buf->left = bufsize;
    44ec:	39 8b       	std	Y+17, r19	; 0x11
    44ee:	28 8b       	std	Y+16, r18	; 0x10
  
  /* XXX: Should add buf_checkmarker() before do{} loop, if
     incoming data has been handled while waiting for a write. */

  do {
    if(psock->readlen == 0) {
    44f0:	8c 85       	ldd	r24, Y+12	; 0x0c
    44f2:	9d 85       	ldd	r25, Y+13	; 0x0d
    44f4:	89 2b       	or	r24, r25
    44f6:	c1 f4       	brne	.+48     	; 0x4528 <psock_readbuf+0x60>
      PT_WAIT_UNTIL(&psock->psockpt, psock_newdata(psock));
    44f8:	82 e7       	ldi	r24, 0x72	; 114
    44fa:	91 e0       	ldi	r25, 0x01	; 1
    44fc:	9b 83       	std	Y+3, r25	; 0x03
    44fe:	8a 83       	std	Y+2, r24	; 0x02
    4500:	ce 01       	movw	r24, r28
    4502:	0e 94 3f 21 	call	0x427e	; 0x427e <psock_newdata>
    4506:	88 23       	and	r24, r24
    4508:	09 f4       	brne	.+2      	; 0x450c <psock_readbuf+0x44>
    450a:	71 c0       	rjmp	.+226    	; 0x45ee <psock_readbuf+0x126>
      //printf("Waited for newdata\n");
      psock->state = STATE_READ;
    450c:	82 e0       	ldi	r24, 0x02	; 2
    450e:	8c 8b       	std	Y+20, r24	; 0x14
      psock->readptr = (u8_t *)uip_appdata;
    4510:	80 91 40 04 	lds	r24, 0x0440
    4514:	90 91 41 04 	lds	r25, 0x0441
    4518:	9f 83       	std	Y+7, r25	; 0x07
    451a:	8e 83       	std	Y+6, r24	; 0x06
      psock->readlen = uip_datalen();
    451c:	80 91 37 04 	lds	r24, 0x0437
    4520:	90 91 38 04 	lds	r25, 0x0438
    4524:	9d 87       	std	Y+13, r25	; 0x0d
    4526:	8c 87       	std	Y+12, r24	; 0x0c
/*---------------------------------------------------------------------------*/
static u8_t
buf_bufdata(struct psock_buf *buf, u16_t len,
	    u8_t **dataptr, u16_t *datalen)
{
  if(*datalen < buf->left) {
    4528:	2c 85       	ldd	r18, Y+12	; 0x0c
    452a:	3d 85       	ldd	r19, Y+13	; 0x0d
    452c:	48 89       	ldd	r20, Y+16	; 0x10
    452e:	59 89       	ldd	r21, Y+17	; 0x11
    4530:	24 17       	cp	r18, r20
    4532:	35 07       	cpc	r19, r21
    4534:	f0 f4       	brcc	.+60     	; 0x4572 <psock_readbuf+0xaa>
    memcpy(buf->ptr, *dataptr, *datalen);
    4536:	6e 81       	ldd	r22, Y+6	; 0x06
    4538:	7f 81       	ldd	r23, Y+7	; 0x07
    453a:	a9 01       	movw	r20, r18
    453c:	8e 85       	ldd	r24, Y+14	; 0x0e
    453e:	9f 85       	ldd	r25, Y+15	; 0x0f
    4540:	0e 94 82 2c 	call	0x5904	; 0x5904 <memcpy>
    buf->ptr += *datalen;
    4544:	2c 85       	ldd	r18, Y+12	; 0x0c
    4546:	3d 85       	ldd	r19, Y+13	; 0x0d
    4548:	8e 85       	ldd	r24, Y+14	; 0x0e
    454a:	9f 85       	ldd	r25, Y+15	; 0x0f
    454c:	82 0f       	add	r24, r18
    454e:	93 1f       	adc	r25, r19
    4550:	9f 87       	std	Y+15, r25	; 0x0f
    4552:	8e 87       	std	Y+14, r24	; 0x0e
    buf->left -= *datalen;
    4554:	88 89       	ldd	r24, Y+16	; 0x10
    4556:	99 89       	ldd	r25, Y+17	; 0x11
    4558:	82 1b       	sub	r24, r18
    455a:	93 0b       	sbc	r25, r19
    455c:	99 8b       	std	Y+17, r25	; 0x11
    455e:	88 8b       	std	Y+16, r24	; 0x10
    *dataptr += *datalen;
    4560:	8e 81       	ldd	r24, Y+6	; 0x06
    4562:	9f 81       	ldd	r25, Y+7	; 0x07
    4564:	82 0f       	add	r24, r18
    4566:	93 1f       	adc	r25, r19
    4568:	9f 83       	std	Y+7, r25	; 0x07
    456a:	8e 83       	std	Y+6, r24	; 0x06
    *datalen = 0;
    456c:	1d 86       	std	Y+13, r1	; 0x0d
    456e:	1c 86       	std	Y+12, r1	; 0x0c
    4570:	bf cf       	rjmp	.-130    	; 0x44f0 <psock_readbuf+0x28>
    4572:	8e 85       	ldd	r24, Y+14	; 0x0e
    4574:	9f 85       	ldd	r25, Y+15	; 0x0f
    4576:	6e 81       	ldd	r22, Y+6	; 0x06
    4578:	7f 81       	ldd	r23, Y+7	; 0x07
    return BUF_NOT_FULL;
  } else if(*datalen == buf->left) {
    457a:	24 17       	cp	r18, r20
    457c:	35 07       	cpc	r19, r21
    457e:	a9 f4       	brne	.+42     	; 0x45aa <psock_readbuf+0xe2>
    memcpy(buf->ptr, *dataptr, *datalen);
    4580:	0e 94 82 2c 	call	0x5904	; 0x5904 <memcpy>
    buf->ptr += *datalen;
    4584:	8c 85       	ldd	r24, Y+12	; 0x0c
    4586:	9d 85       	ldd	r25, Y+13	; 0x0d
    4588:	2e 85       	ldd	r18, Y+14	; 0x0e
    458a:	3f 85       	ldd	r19, Y+15	; 0x0f
    458c:	28 0f       	add	r18, r24
    458e:	39 1f       	adc	r19, r25
    4590:	3f 87       	std	Y+15, r19	; 0x0f
    4592:	2e 87       	std	Y+14, r18	; 0x0e
    buf->left = 0;
    4594:	19 8a       	std	Y+17, r1	; 0x11
    4596:	18 8a       	std	Y+16, r1	; 0x10
    *dataptr += *datalen;
    4598:	2e 81       	ldd	r18, Y+6	; 0x06
    459a:	3f 81       	ldd	r19, Y+7	; 0x07
    459c:	28 0f       	add	r18, r24
    459e:	39 1f       	adc	r19, r25
    45a0:	3f 83       	std	Y+7, r19	; 0x07
    45a2:	2e 83       	std	Y+6, r18	; 0x06
    *datalen = 0;
    45a4:	1d 86       	std	Y+13, r1	; 0x0d
    45a6:	1c 86       	std	Y+12, r1	; 0x0c
    45a8:	18 c0       	rjmp	.+48     	; 0x45da <psock_readbuf+0x112>
    return BUF_FULL;
  } else {
    memcpy(buf->ptr, *dataptr, buf->left);
    45aa:	0e 94 82 2c 	call	0x5904	; 0x5904 <memcpy>
    buf->ptr += buf->left;
    45ae:	8e 85       	ldd	r24, Y+14	; 0x0e
    45b0:	9f 85       	ldd	r25, Y+15	; 0x0f
    45b2:	28 89       	ldd	r18, Y+16	; 0x10
    45b4:	39 89       	ldd	r19, Y+17	; 0x11
    45b6:	82 0f       	add	r24, r18
    45b8:	93 1f       	adc	r25, r19
    45ba:	9f 87       	std	Y+15, r25	; 0x0f
    45bc:	8e 87       	std	Y+14, r24	; 0x0e
    *datalen -= buf->left;
    45be:	8c 85       	ldd	r24, Y+12	; 0x0c
    45c0:	9d 85       	ldd	r25, Y+13	; 0x0d
    45c2:	82 1b       	sub	r24, r18
    45c4:	93 0b       	sbc	r25, r19
    45c6:	9d 87       	std	Y+13, r25	; 0x0d
    45c8:	8c 87       	std	Y+12, r24	; 0x0c
    *dataptr += buf->left;
    45ca:	8e 81       	ldd	r24, Y+6	; 0x06
    45cc:	9f 81       	ldd	r25, Y+7	; 0x07
    45ce:	82 0f       	add	r24, r18
    45d0:	93 1f       	adc	r25, r19
    45d2:	9f 83       	std	Y+7, r25	; 0x07
    45d4:	8e 83       	std	Y+6, r24	; 0x06
    buf->left = 0;
    45d6:	19 8a       	std	Y+17, r1	; 0x11
    45d8:	18 8a       	std	Y+16, r1	; 0x10
    }
  } while(buf_bufdata(&psock->buf, psock->bufsize,
			 &psock->readptr,
			 &psock->readlen) != BUF_FULL);

  if(psock_datalen(psock) == 0) {
    45da:	2a 89       	ldd	r18, Y+18	; 0x12
    45dc:	3b 89       	ldd	r19, Y+19	; 0x13
    45de:	88 89       	ldd	r24, Y+16	; 0x10
    45e0:	99 89       	ldd	r25, Y+17	; 0x11
    45e2:	28 17       	cp	r18, r24
    45e4:	39 07       	cpc	r19, r25
    45e6:	31 f4       	brne	.+12     	; 0x45f4 <psock_readbuf+0x12c>
    psock->state = STATE_NONE;
    45e8:	1c 8a       	std	Y+20, r1	; 0x14
    PT_RESTART(&psock->psockpt);
    45ea:	1b 82       	std	Y+3, r1	; 0x03
    45ec:	1a 82       	std	Y+2, r1	; 0x02
    45ee:	80 e0       	ldi	r24, 0x00	; 0
    45f0:	90 e0       	ldi	r25, 0x00	; 0
    45f2:	04 c0       	rjmp	.+8      	; 0x45fc <psock_readbuf+0x134>
  }
  PT_END(&psock->psockpt);
    45f4:	1b 82       	std	Y+3, r1	; 0x03
    45f6:	1a 82       	std	Y+2, r1	; 0x02
    45f8:	82 e0       	ldi	r24, 0x02	; 2
    45fa:	90 e0       	ldi	r25, 0x00	; 0
    45fc:	df 91       	pop	r29
    45fe:	cf 91       	pop	r28
    4600:	08 95       	ret

00004602 <psock_readto>:
    return 0;
  }
}
/*---------------------------------------------------------------------------*/
PT_THREAD(psock_readto(register struct psock *psock, unsigned char c))
{
    4602:	1f 93       	push	r17
    4604:	cf 93       	push	r28
    4606:	df 93       	push	r29
    4608:	ec 01       	movw	r28, r24
    460a:	16 2f       	mov	r17, r22
  PT_BEGIN(&psock->psockpt);
    460c:	8a 81       	ldd	r24, Y+2	; 0x02
    460e:	9b 81       	ldd	r25, Y+3	; 0x03
    4610:	00 97       	sbiw	r24, 0x00	; 0
    4612:	29 f0       	breq	.+10     	; 0x461e <psock_readto+0x1c>
    4614:	87 55       	subi	r24, 0x57	; 87
    4616:	91 40       	sbci	r25, 0x01	; 1
    4618:	09 f0       	breq	.+2      	; 0x461c <psock_readto+0x1a>
    461a:	78 c0       	rjmp	.+240    	; 0x470c <psock_readto+0x10a>
    461c:	10 c0       	rjmp	.+32     	; 0x463e <psock_readto+0x3c>

  buf_setup(&psock->buf, psock->bufptr, psock->bufsize);
    461e:	2a 89       	ldd	r18, Y+18	; 0x12
    4620:	3b 89       	ldd	r19, Y+19	; 0x13
/*---------------------------------------------------------------------------*/
static void
buf_setup(struct psock_buf *buf,
	  u8_t *bufptr, u16_t bufsize)
{
  buf->ptr = bufptr;
    4622:	88 85       	ldd	r24, Y+8	; 0x08
    4624:	99 85       	ldd	r25, Y+9	; 0x09
    4626:	9f 87       	std	Y+15, r25	; 0x0f
    4628:	8e 87       	std	Y+14, r24	; 0x0e
  buf->left = bufsize;
    462a:	39 8b       	std	Y+17, r19	; 0x11
    462c:	28 8b       	std	Y+16, r18	; 0x10
  
  /* XXX: Should add buf_checkmarker() before do{} loop, if
     incoming data has been handled while waiting for a write. */

  do {
    if(psock->readlen == 0) {
    462e:	8c 85       	ldd	r24, Y+12	; 0x0c
    4630:	9d 85       	ldd	r25, Y+13	; 0x0d
    4632:	89 2b       	or	r24, r25
    4634:	c1 f5       	brne	.+112    	; 0x46a6 <psock_readto+0xa4>
      PT_WAIT_UNTIL(&psock->psockpt, psock_newdata(psock));
    4636:	87 e5       	ldi	r24, 0x57	; 87
    4638:	91 e0       	ldi	r25, 0x01	; 1
    463a:	9b 83       	std	Y+3, r25	; 0x03
    463c:	8a 83       	std	Y+2, r24	; 0x02
    463e:	ce 01       	movw	r24, r28
    4640:	0e 94 3f 21 	call	0x427e	; 0x427e <psock_newdata>
    4644:	88 23       	and	r24, r24
    4646:	09 f4       	brne	.+2      	; 0x464a <psock_readto+0x48>
    4648:	5e c0       	rjmp	.+188    	; 0x4706 <psock_readto+0x104>
      psock->state = STATE_READ;
    464a:	82 e0       	ldi	r24, 0x02	; 2
    464c:	8c 8b       	std	Y+20, r24	; 0x14
      psock->readptr = (u8_t *)uip_appdata;
    464e:	80 91 40 04 	lds	r24, 0x0440
    4652:	90 91 41 04 	lds	r25, 0x0441
    4656:	9f 83       	std	Y+7, r25	; 0x07
    4658:	8e 83       	std	Y+6, r24	; 0x06
      psock->readlen = uip_datalen();
    465a:	80 91 37 04 	lds	r24, 0x0437
    465e:	90 91 38 04 	lds	r25, 0x0438
    4662:	9d 87       	std	Y+13, r25	; 0x0d
    4664:	8c 87       	std	Y+12, r24	; 0x0c
    4666:	1f c0       	rjmp	.+62     	; 0x46a6 <psock_readto+0xa4>
buf_bufto(register struct psock_buf *buf, u8_t endmarker,
	  register u8_t **dataptr, register u16_t *datalen)
{
  u8_t c;
  while(buf->left > 0 && *datalen > 0) {
    c = *buf->ptr = **dataptr;
    4668:	ee 81       	ldd	r30, Y+6	; 0x06
    466a:	ff 81       	ldd	r31, Y+7	; 0x07
    466c:	20 81       	ld	r18, Z
    466e:	ee 85       	ldd	r30, Y+14	; 0x0e
    4670:	ff 85       	ldd	r31, Y+15	; 0x0f
    4672:	20 83       	st	Z, r18
    ++*dataptr;
    4674:	8e 81       	ldd	r24, Y+6	; 0x06
    4676:	9f 81       	ldd	r25, Y+7	; 0x07
    4678:	01 96       	adiw	r24, 0x01	; 1
    467a:	9f 83       	std	Y+7, r25	; 0x07
    467c:	8e 83       	std	Y+6, r24	; 0x06
    ++buf->ptr;
    467e:	8e 85       	ldd	r24, Y+14	; 0x0e
    4680:	9f 85       	ldd	r25, Y+15	; 0x0f
    4682:	01 96       	adiw	r24, 0x01	; 1
    4684:	9f 87       	std	Y+15, r25	; 0x0f
    4686:	8e 87       	std	Y+14, r24	; 0x0e
    --*datalen;
    4688:	8c 85       	ldd	r24, Y+12	; 0x0c
    468a:	9d 85       	ldd	r25, Y+13	; 0x0d
    468c:	01 97       	sbiw	r24, 0x01	; 1
    468e:	9d 87       	std	Y+13, r25	; 0x0d
    4690:	8c 87       	std	Y+12, r24	; 0x0c
    --buf->left;
    4692:	88 89       	ldd	r24, Y+16	; 0x10
    4694:	99 89       	ldd	r25, Y+17	; 0x11
    4696:	01 97       	sbiw	r24, 0x01	; 1
    4698:	99 8b       	std	Y+17, r25	; 0x11
    469a:	88 8b       	std	Y+16, r24	; 0x10
    
    if(c == endmarker) {
    469c:	21 17       	cp	r18, r17
    469e:	19 f4       	brne	.+6      	; 0x46a6 <psock_readto+0xa4>
    46a0:	82 e0       	ldi	r24, 0x02	; 2
    46a2:	90 e0       	ldi	r25, 0x00	; 0
    46a4:	24 c0       	rjmp	.+72     	; 0x46ee <psock_readto+0xec>
static u8_t
buf_bufto(register struct psock_buf *buf, u8_t endmarker,
	  register u8_t **dataptr, register u16_t *datalen)
{
  u8_t c;
  while(buf->left > 0 && *datalen > 0) {
    46a6:	88 89       	ldd	r24, Y+16	; 0x10
    46a8:	99 89       	ldd	r25, Y+17	; 0x11
    46aa:	89 2b       	or	r24, r25
    46ac:	21 f0       	breq	.+8      	; 0x46b6 <psock_readto+0xb4>
    46ae:	8c 85       	ldd	r24, Y+12	; 0x0c
    46b0:	9d 85       	ldd	r25, Y+13	; 0x0d
    46b2:	89 2b       	or	r24, r25
    46b4:	c9 f6       	brne	.-78     	; 0x4668 <psock_readto+0x66>
    if(c == endmarker) {
      return BUF_FOUND;
    }
  }

  if(*datalen == 0) {
    46b6:	8c 85       	ldd	r24, Y+12	; 0x0c
    46b8:	9d 85       	ldd	r25, Y+13	; 0x0d
    46ba:	89 2b       	or	r24, r25
    46bc:	89 f4       	brne	.+34     	; 0x46e0 <psock_readto+0xde>
    46be:	80 e0       	ldi	r24, 0x00	; 0
    46c0:	90 e0       	ldi	r25, 0x00	; 0
    46c2:	15 c0       	rjmp	.+42     	; 0x46ee <psock_readto+0xec>
    return BUF_NOT_FOUND;
  }

  while(*datalen > 0) {
    c = **dataptr;
    46c4:	ee 81       	ldd	r30, Y+6	; 0x06
    46c6:	ff 81       	ldd	r31, Y+7	; 0x07
    46c8:	81 91       	ld	r24, Z+
    --*datalen;
    46ca:	21 50       	subi	r18, 0x01	; 1
    46cc:	30 40       	sbci	r19, 0x00	; 0
    46ce:	3d 87       	std	Y+13, r19	; 0x0d
    46d0:	2c 87       	std	Y+12, r18	; 0x0c
    ++*dataptr;
    46d2:	ff 83       	std	Y+7, r31	; 0x07
    46d4:	ee 83       	std	Y+6, r30	; 0x06
    
    if(c == endmarker) {
    46d6:	81 17       	cp	r24, r17
    46d8:	19 f4       	brne	.+6      	; 0x46e0 <psock_readto+0xde>
    46da:	83 e0       	ldi	r24, 0x03	; 3
    46dc:	90 e0       	ldi	r25, 0x00	; 0
    46de:	07 c0       	rjmp	.+14     	; 0x46ee <psock_readto+0xec>

  if(*datalen == 0) {
    return BUF_NOT_FOUND;
  }

  while(*datalen > 0) {
    46e0:	2c 85       	ldd	r18, Y+12	; 0x0c
    46e2:	3d 85       	ldd	r19, Y+13	; 0x0d
    46e4:	21 15       	cp	r18, r1
    46e6:	31 05       	cpc	r19, r1
    46e8:	69 f7       	brne	.-38     	; 0x46c4 <psock_readto+0xc2>
    46ea:	81 e0       	ldi	r24, 0x01	; 1
    46ec:	90 e0       	ldi	r25, 0x00	; 0
      psock->readptr = (u8_t *)uip_appdata;
      psock->readlen = uip_datalen();
    }
  } while((buf_bufto(&psock->buf, c,
		     &psock->readptr,
		     &psock->readlen) & BUF_FOUND) == 0);
    46ee:	81 ff       	sbrs	r24, 1
    46f0:	9e cf       	rjmp	.-196    	; 0x462e <psock_readto+0x2c>
  
  if(psock_datalen(psock) == 0) {
    46f2:	2a 89       	ldd	r18, Y+18	; 0x12
    46f4:	3b 89       	ldd	r19, Y+19	; 0x13
    46f6:	88 89       	ldd	r24, Y+16	; 0x10
    46f8:	99 89       	ldd	r25, Y+17	; 0x11
    46fa:	28 17       	cp	r18, r24
    46fc:	39 07       	cpc	r19, r25
    46fe:	31 f4       	brne	.+12     	; 0x470c <psock_readto+0x10a>
    psock->state = STATE_NONE;
    4700:	1c 8a       	std	Y+20, r1	; 0x14
    PT_RESTART(&psock->psockpt);
    4702:	1b 82       	std	Y+3, r1	; 0x03
    4704:	1a 82       	std	Y+2, r1	; 0x02
    4706:	80 e0       	ldi	r24, 0x00	; 0
    4708:	90 e0       	ldi	r25, 0x00	; 0
    470a:	04 c0       	rjmp	.+8      	; 0x4714 <psock_readto+0x112>
  }
  PT_END(&psock->psockpt);
    470c:	1b 82       	std	Y+3, r1	; 0x03
    470e:	1a 82       	std	Y+2, r1	; 0x02
    4710:	82 e0       	ldi	r24, 0x02	; 2
    4712:	90 e0       	ldi	r25, 0x00	; 0
    4714:	df 91       	pop	r29
    4716:	cf 91       	pop	r28
    4718:	1f 91       	pop	r17
    471a:	08 95       	ret

0000471c <timer_reset>:
 *
 * \sa timer_restart()
 */
void
timer_reset(struct timer *t)
{
    471c:	fc 01       	movw	r30, r24
  t->start += t->interval;
    471e:	80 81       	ld	r24, Z
    4720:	91 81       	ldd	r25, Z+1	; 0x01
    4722:	22 81       	ldd	r18, Z+2	; 0x02
    4724:	33 81       	ldd	r19, Z+3	; 0x03
    4726:	82 0f       	add	r24, r18
    4728:	93 1f       	adc	r25, r19
    472a:	91 83       	std	Z+1, r25	; 0x01
    472c:	80 83       	st	Z, r24
    472e:	08 95       	ret

00004730 <timer_expired>:
 * \return Non-zero if the timer has expired, zero otherwise.
 *
 */
int
timer_expired(struct timer *t)
{
    4730:	0f 93       	push	r16
    4732:	1f 93       	push	r17
    4734:	8c 01       	movw	r16, r24
  return (clock_time_t)(clock_time() - t->start) >= (clock_time_t)t->interval;
    4736:	0e 94 3a 0e 	call	0x1c74	; 0x1c74 <clock_time>
    473a:	40 e0       	ldi	r20, 0x00	; 0
    473c:	50 e0       	ldi	r21, 0x00	; 0
    473e:	f8 01       	movw	r30, r16
    4740:	20 81       	ld	r18, Z
    4742:	31 81       	ldd	r19, Z+1	; 0x01
    4744:	82 1b       	sub	r24, r18
    4746:	93 0b       	sbc	r25, r19
    4748:	22 81       	ldd	r18, Z+2	; 0x02
    474a:	33 81       	ldd	r19, Z+3	; 0x03
    474c:	82 17       	cp	r24, r18
    474e:	93 07       	cpc	r25, r19
    4750:	14 f0       	brlt	.+4      	; 0x4756 <timer_expired+0x26>
    4752:	41 e0       	ldi	r20, 0x01	; 1
    4754:	50 e0       	ldi	r21, 0x00	; 0
}
    4756:	ca 01       	movw	r24, r20
    4758:	1f 91       	pop	r17
    475a:	0f 91       	pop	r16
    475c:	08 95       	ret

0000475e <timer_restart>:
 *
 * \sa timer_reset()
 */
void
timer_restart(struct timer *t)
{
    475e:	0f 93       	push	r16
    4760:	1f 93       	push	r17
    4762:	8c 01       	movw	r16, r24
  t->start = clock_time();
    4764:	0e 94 3a 0e 	call	0x1c74	; 0x1c74 <clock_time>
    4768:	f8 01       	movw	r30, r16
    476a:	91 83       	std	Z+1, r25	; 0x01
    476c:	80 83       	st	Z, r24
    476e:	1f 91       	pop	r17
    4770:	0f 91       	pop	r16
    4772:	08 95       	ret

00004774 <timer_set>:
 * \param interval The interval before the timer expires.
 *
 */
void
timer_set(struct timer *t, clock_time_t interval)
{
    4774:	0f 93       	push	r16
    4776:	1f 93       	push	r17
    4778:	8c 01       	movw	r16, r24
  t->interval = interval;
    477a:	fc 01       	movw	r30, r24
    477c:	73 83       	std	Z+3, r23	; 0x03
    477e:	62 83       	std	Z+2, r22	; 0x02
  t->start = clock_time();
    4780:	0e 94 3a 0e 	call	0x1c74	; 0x1c74 <clock_time>
    4784:	f8 01       	movw	r30, r16
    4786:	91 83       	std	Z+1, r25	; 0x01
    4788:	80 83       	st	Z, r24
    478a:	1f 91       	pop	r17
    478c:	0f 91       	pop	r16
    478e:	08 95       	ret

00004790 <uip_neighbor_init>:
static struct neighbor_entry entries[ENTRIES];

/*---------------------------------------------------------------------------*/
void
uip_neighbor_init(void)
{
    4790:	e1 ed       	ldi	r30, 0xD1	; 209
    4792:	f3 e0       	ldi	r31, 0x03	; 3
  int i;

  for(i = 0; i < ENTRIES; ++i) {
    entries[i].time = MAX_TIME;
    4794:	80 e8       	ldi	r24, 0x80	; 128
    4796:	80 83       	st	Z, r24
    4798:	3b 96       	adiw	r30, 0x0b	; 11
void
uip_neighbor_init(void)
{
  int i;

  for(i = 0; i < ENTRIES; ++i) {
    479a:	84 e0       	ldi	r24, 0x04	; 4
    479c:	e9 32       	cpi	r30, 0x29	; 41
    479e:	f8 07       	cpc	r31, r24
    47a0:	c9 f7       	brne	.-14     	; 0x4794 <uip_neighbor_init+0x4>
    47a2:	08 95       	ret

000047a4 <uip_neighbor_periodic>:
  }
}
/*---------------------------------------------------------------------------*/
void
uip_neighbor_periodic(void)
{
    47a4:	e1 ed       	ldi	r30, 0xD1	; 209
    47a6:	f3 e0       	ldi	r31, 0x03	; 3
  int i;

  for(i = 0; i < ENTRIES; ++i) {
    if(entries[i].time < MAX_TIME) {
    47a8:	80 81       	ld	r24, Z
    47aa:	87 fd       	sbrc	r24, 7
    47ac:	02 c0       	rjmp	.+4      	; 0x47b2 <uip_neighbor_periodic+0xe>
      entries[i].time++;
    47ae:	8f 5f       	subi	r24, 0xFF	; 255
    47b0:	80 83       	st	Z, r24
    47b2:	3b 96       	adiw	r30, 0x0b	; 11
void
uip_neighbor_periodic(void)
{
  int i;

  for(i = 0; i < ENTRIES; ++i) {
    47b4:	84 e0       	ldi	r24, 0x04	; 4
    47b6:	e9 32       	cpi	r30, 0x29	; 41
    47b8:	f8 07       	cpc	r31, r24
    47ba:	b1 f7       	brne	.-20     	; 0x47a8 <uip_neighbor_periodic+0x4>
    47bc:	08 95       	ret

000047be <find_entry>:
  memcpy(&entries[oldest].addr, addr, sizeof(struct uip_neighbor_addr));
}
/*---------------------------------------------------------------------------*/
static struct neighbor_entry *
find_entry(uip_ipaddr_t ipaddr)
{
    47be:	cf 93       	push	r28
    47c0:	df 93       	push	r29
    47c2:	dc 01       	movw	r26, r24
  int i;
  
  for(i = 0; i < ENTRIES; ++i) {
    if(uip_ipaddr_cmp(entries[i].ipaddr, ipaddr)) {
    47c4:	6d 91       	ld	r22, X+
    47c6:	7c 91       	ld	r23, X
    47c8:	11 97       	sbiw	r26, 0x01	; 1
    47ca:	e7 ec       	ldi	r30, 0xC7	; 199
    47cc:	f3 e0       	ldi	r31, 0x03	; 3
    47ce:	40 e0       	ldi	r20, 0x00	; 0
    47d0:	50 e0       	ldi	r21, 0x00	; 0
    47d2:	80 81       	ld	r24, Z
    47d4:	91 81       	ldd	r25, Z+1	; 0x01
    47d6:	86 17       	cp	r24, r22
    47d8:	97 07       	cpc	r25, r23
    47da:	a9 f4       	brne	.+42     	; 0x4806 <find_entry+0x48>
    47dc:	22 81       	ldd	r18, Z+2	; 0x02
    47de:	33 81       	ldd	r19, Z+3	; 0x03
    47e0:	ed 01       	movw	r28, r26
    47e2:	8a 81       	ldd	r24, Y+2	; 0x02
    47e4:	9b 81       	ldd	r25, Y+3	; 0x03
    47e6:	28 17       	cp	r18, r24
    47e8:	39 07       	cpc	r19, r25
    47ea:	69 f4       	brne	.+26     	; 0x4806 <find_entry+0x48>
      return &entries[i];
    47ec:	8b e0       	ldi	r24, 0x0B	; 11
    47ee:	90 e0       	ldi	r25, 0x00	; 0
    47f0:	9c 01       	movw	r18, r24
    47f2:	42 9f       	mul	r20, r18
    47f4:	c0 01       	movw	r24, r0
    47f6:	43 9f       	mul	r20, r19
    47f8:	90 0d       	add	r25, r0
    47fa:	52 9f       	mul	r21, r18
    47fc:	90 0d       	add	r25, r0
    47fe:	11 24       	eor	r1, r1
    4800:	89 53       	subi	r24, 0x39	; 57
    4802:	9c 4f       	sbci	r25, 0xFC	; 252
    4804:	08 c0       	rjmp	.+16     	; 0x4816 <find_entry+0x58>
static struct neighbor_entry *
find_entry(uip_ipaddr_t ipaddr)
{
  int i;
  
  for(i = 0; i < ENTRIES; ++i) {
    4806:	4f 5f       	subi	r20, 0xFF	; 255
    4808:	5f 4f       	sbci	r21, 0xFF	; 255
    480a:	3b 96       	adiw	r30, 0x0b	; 11
    480c:	48 30       	cpi	r20, 0x08	; 8
    480e:	51 05       	cpc	r21, r1
    4810:	01 f7       	brne	.-64     	; 0x47d2 <find_entry+0x14>
    4812:	80 e0       	ldi	r24, 0x00	; 0
    4814:	90 e0       	ldi	r25, 0x00	; 0
    4816:	df 91       	pop	r29
    4818:	cf 91       	pop	r28
    481a:	08 95       	ret

0000481c <uip_neighbor_update>:
  return NULL;
}
/*---------------------------------------------------------------------------*/
void
uip_neighbor_update(uip_ipaddr_t ipaddr)
{
    481c:	0e 94 df 23 	call	0x47be	; 0x47be <find_entry>
    4820:	fc 01       	movw	r30, r24
  struct neighbor_entry *e;

  e = find_entry(ipaddr);
  if(e != NULL) {
    4822:	89 2b       	or	r24, r25
    4824:	09 f0       	breq	.+2      	; 0x4828 <uip_neighbor_update+0xc>
    e->time = 0;
    4826:	12 86       	std	Z+10, r1	; 0x0a
    4828:	08 95       	ret

0000482a <uip_neighbor_lookup>:
  }
}
/*---------------------------------------------------------------------------*/
struct uip_neighbor_addr *
uip_neighbor_lookup(uip_ipaddr_t ipaddr)
{
    482a:	0e 94 df 23 	call	0x47be	; 0x47be <find_entry>
  struct neighbor_entry *e;

  e = find_entry(ipaddr);
  if(e != NULL) {
    482e:	00 97       	sbiw	r24, 0x00	; 0
    4830:	19 f4       	brne	.+6      	; 0x4838 <uip_neighbor_lookup+0xe>
    4832:	80 e0       	ldi	r24, 0x00	; 0
    4834:	90 e0       	ldi	r25, 0x00	; 0
    4836:	08 95       	ret
    /*    printf("Lookup neighbor with link address %02x:%02x:%02x:%02x:%02x:%02x\n",
	   e->addr.addr.addr[0], e->addr.addr.addr[1], e->addr.addr.addr[2], e->addr.addr.addr[3],
	   e->addr.addr.addr[4], e->addr.addr.addr[5]);*/

    return &e->addr;
    4838:	04 96       	adiw	r24, 0x04	; 4
  }
  return NULL;
}
    483a:	08 95       	ret

0000483c <uip_neighbor_add>:
  }
}
/*---------------------------------------------------------------------------*/
void
uip_neighbor_add(uip_ipaddr_t ipaddr, struct uip_neighbor_addr *addr)
{
    483c:	0f 93       	push	r16
    483e:	1f 93       	push	r17
    4840:	cf 93       	push	r28
    4842:	df 93       	push	r29
    4844:	8c 01       	movw	r16, r24
    4846:	eb 01       	movw	r28, r22
    4848:	e7 ec       	ldi	r30, 0xC7	; 199
    484a:	f3 e0       	ldi	r31, 0x03	; 3
    484c:	60 e0       	ldi	r22, 0x00	; 0
    484e:	70 e0       	ldi	r23, 0x00	; 0
    4850:	a0 e0       	ldi	r26, 0x00	; 0
    4852:	b0 e0       	ldi	r27, 0x00	; 0
    4854:	50 e0       	ldi	r21, 0x00	; 0
  
  /* Find the first unused entry or the oldest used entry. */
  oldest_time = 0;
  oldest = 0;
  for(i = 0; i < ENTRIES; ++i) {
    if(entries[i].time == MAX_TIME) {
    4856:	42 85       	ldd	r20, Z+10	; 0x0a
    4858:	40 38       	cpi	r20, 0x80	; 128
    485a:	c9 f0       	breq	.+50     	; 0x488e <uip_neighbor_add+0x52>
      oldest = i;
      break;
    }
    if(uip_ipaddr_cmp(entries[i].ipaddr, addr)) {
    485c:	20 81       	ld	r18, Z
    485e:	31 81       	ldd	r19, Z+1	; 0x01
    4860:	88 81       	ld	r24, Y
    4862:	99 81       	ldd	r25, Y+1	; 0x01
    4864:	28 17       	cp	r18, r24
    4866:	39 07       	cpc	r19, r25
    4868:	39 f4       	brne	.+14     	; 0x4878 <uip_neighbor_add+0x3c>
    486a:	22 81       	ldd	r18, Z+2	; 0x02
    486c:	33 81       	ldd	r19, Z+3	; 0x03
    486e:	8a 81       	ldd	r24, Y+2	; 0x02
    4870:	9b 81       	ldd	r25, Y+3	; 0x03
    4872:	28 17       	cp	r18, r24
    4874:	39 07       	cpc	r19, r25
    4876:	59 f0       	breq	.+22     	; 0x488e <uip_neighbor_add+0x52>
      oldest = i;
      break;
    }
    if(entries[i].time > oldest_time) {
    4878:	54 17       	cp	r21, r20
    487a:	10 f4       	brcc	.+4      	; 0x4880 <uip_neighbor_add+0x44>
    487c:	db 01       	movw	r26, r22
    487e:	54 2f       	mov	r21, r20
	 //addr->addr.addr[4], addr->addr.addr[5]);
  
  /* Find the first unused entry or the oldest used entry. */
  oldest_time = 0;
  oldest = 0;
  for(i = 0; i < ENTRIES; ++i) {
    4880:	6f 5f       	subi	r22, 0xFF	; 255
    4882:	7f 4f       	sbci	r23, 0xFF	; 255
    4884:	3b 96       	adiw	r30, 0x0b	; 11
    4886:	68 30       	cpi	r22, 0x08	; 8
    4888:	71 05       	cpc	r23, r1
    488a:	11 f0       	breq	.+4      	; 0x4890 <uip_neighbor_add+0x54>
    488c:	e4 cf       	rjmp	.-56     	; 0x4856 <uip_neighbor_add+0x1a>
    488e:	db 01       	movw	r26, r22
    }
  }

  /* Use the oldest or first free entry (either pointed to by the
     "oldest" variable). */
  entries[oldest].time = 0;
    4890:	8b e0       	ldi	r24, 0x0B	; 11
    4892:	90 e0       	ldi	r25, 0x00	; 0
    4894:	a8 9f       	mul	r26, r24
    4896:	90 01       	movw	r18, r0
    4898:	a9 9f       	mul	r26, r25
    489a:	30 0d       	add	r19, r0
    489c:	b8 9f       	mul	r27, r24
    489e:	30 0d       	add	r19, r0
    48a0:	11 24       	eor	r1, r1
    48a2:	a9 01       	movw	r20, r18
    48a4:	49 53       	subi	r20, 0x39	; 57
    48a6:	5c 4f       	sbci	r21, 0xFC	; 252
    48a8:	fa 01       	movw	r30, r20
    48aa:	12 86       	std	Z+10, r1	; 0x0a
  uip_ipaddr_copy(entries[oldest].ipaddr, ipaddr);
    48ac:	d8 01       	movw	r26, r16
    48ae:	8d 91       	ld	r24, X+
    48b0:	9c 91       	ld	r25, X
    48b2:	91 83       	std	Z+1, r25	; 0x01
    48b4:	80 83       	st	Z, r24
    48b6:	f8 01       	movw	r30, r16
    48b8:	82 81       	ldd	r24, Z+2	; 0x02
    48ba:	93 81       	ldd	r25, Z+3	; 0x03
    48bc:	fa 01       	movw	r30, r20
    48be:	93 83       	std	Z+3, r25	; 0x03
    48c0:	82 83       	std	Z+2, r24	; 0x02
  memcpy(&entries[oldest].addr, addr, sizeof(struct uip_neighbor_addr));
    48c2:	d9 01       	movw	r26, r18
    48c4:	a5 53       	subi	r26, 0x35	; 53
    48c6:	bc 4f       	sbci	r27, 0xFC	; 252
    48c8:	fe 01       	movw	r30, r28
    48ca:	86 e0       	ldi	r24, 0x06	; 6
    48cc:	01 90       	ld	r0, Z+
    48ce:	0d 92       	st	X+, r0
    48d0:	81 50       	subi	r24, 0x01	; 1
    48d2:	e1 f7       	brne	.-8      	; 0x48cc <uip_neighbor_add+0x90>
    48d4:	df 91       	pop	r29
    48d6:	cf 91       	pop	r28
    48d8:	1f 91       	pop	r17
    48da:	0f 91       	pop	r16
    48dc:	08 95       	ret

000048de <httpd_init>:
 *             This function initializes the web server and should be
 *             called at system boot-up.
 */
void
httpd_init(void)
{
    48de:	80 e0       	ldi	r24, 0x00	; 0
    48e0:	90 e5       	ldi	r25, 0x50	; 80
    48e2:	0e 94 ae 15 	call	0x2b5c	; 0x2b5c <uip_listen>
    48e6:	08 95       	ret

000048e8 <send_headers>:
  PT_END(&s->scriptpt);
}
/*---------------------------------------------------------------------------*/
static
PT_THREAD(send_headers(struct httpd_state *s, const char *statushdr))
{
    48e8:	0f 93       	push	r16
    48ea:	1f 93       	push	r17
    48ec:	cf 93       	push	r28
    48ee:	df 93       	push	r29
    48f0:	8c 01       	movw	r16, r24
    48f2:	eb 01       	movw	r28, r22
  char *ptr;
  PSOCK_BEGIN(&s->sout);
    48f4:	fc 01       	movw	r30, r24
    48f6:	86 89       	ldd	r24, Z+22	; 0x16
    48f8:	97 89       	ldd	r25, Z+23	; 0x17
    48fa:	88 3e       	cpi	r24, 0xE8	; 232
    48fc:	91 05       	cpc	r25, r1
    48fe:	09 f4       	brne	.+2      	; 0x4902 <send_headers+0x1a>
    4900:	7d c0       	rjmp	.+250    	; 0x49fc <send_headers+0x114>
    4902:	89 3e       	cpi	r24, 0xE9	; 233
    4904:	91 05       	cpc	r25, r1
    4906:	88 f4       	brcc	.+34     	; 0x492a <send_headers+0x42>
    4908:	8e 3d       	cpi	r24, 0xDE	; 222
    490a:	91 05       	cpc	r25, r1
    490c:	41 f1       	breq	.+80     	; 0x495e <send_headers+0x76>
    490e:	8f 3d       	cpi	r24, 0xDF	; 223
    4910:	91 05       	cpc	r25, r1
    4912:	18 f4       	brcc	.+6      	; 0x491a <send_headers+0x32>
    4914:	89 2b       	or	r24, r25
    4916:	f1 f0       	breq	.+60     	; 0x4954 <send_headers+0x6c>
    4918:	cd c0       	rjmp	.+410    	; 0x4ab4 <send_headers+0x1cc>
    491a:	83 3e       	cpi	r24, 0xE3	; 227
    491c:	91 05       	cpc	r25, r1
    491e:	d1 f1       	breq	.+116    	; 0x4994 <send_headers+0xac>
    4920:	86 3e       	cpi	r24, 0xE6	; 230
    4922:	91 05       	cpc	r25, r1
    4924:	09 f0       	breq	.+2      	; 0x4928 <send_headers+0x40>
    4926:	c6 c0       	rjmp	.+396    	; 0x4ab4 <send_headers+0x1cc>
    4928:	53 c0       	rjmp	.+166    	; 0x49d0 <send_headers+0xe8>
    492a:	8c 3e       	cpi	r24, 0xEC	; 236
    492c:	91 05       	cpc	r25, r1
    492e:	09 f4       	brne	.+2      	; 0x4932 <send_headers+0x4a>
    4930:	91 c0       	rjmp	.+290    	; 0x4a54 <send_headers+0x16c>
    4932:	8d 3e       	cpi	r24, 0xED	; 237
    4934:	91 05       	cpc	r25, r1
    4936:	28 f4       	brcc	.+10     	; 0x4942 <send_headers+0x5a>
    4938:	8a 3e       	cpi	r24, 0xEA	; 234
    493a:	91 05       	cpc	r25, r1
    493c:	09 f0       	breq	.+2      	; 0x4940 <send_headers+0x58>
    493e:	ba c0       	rjmp	.+372    	; 0x4ab4 <send_headers+0x1cc>
    4940:	73 c0       	rjmp	.+230    	; 0x4a28 <send_headers+0x140>
    4942:	8e 3e       	cpi	r24, 0xEE	; 238
    4944:	91 05       	cpc	r25, r1
    4946:	09 f4       	brne	.+2      	; 0x494a <send_headers+0x62>
    4948:	9b c0       	rjmp	.+310    	; 0x4a80 <send_headers+0x198>
    494a:	80 3f       	cpi	r24, 0xF0	; 240
    494c:	91 05       	cpc	r25, r1
    494e:	09 f0       	breq	.+2      	; 0x4952 <send_headers+0x6a>
    4950:	b1 c0       	rjmp	.+354    	; 0x4ab4 <send_headers+0x1cc>
    4952:	a3 c0       	rjmp	.+326    	; 0x4a9a <send_headers+0x1b2>
  PSOCK_SEND_STR_P(&s->sout, statushdr);
    4954:	8e ed       	ldi	r24, 0xDE	; 222
    4956:	90 e0       	ldi	r25, 0x00	; 0
    4958:	f8 01       	movw	r30, r16
    495a:	97 8b       	std	Z+23, r25	; 0x17
    495c:	86 8b       	std	Z+22, r24	; 0x16
    495e:	ce 01       	movw	r24, r28
    4960:	0e 94 5c 2c 	call	0x58b8	; 0x58b8 <strlen_P>
    4964:	ac 01       	movw	r20, r24
    4966:	be 01       	movw	r22, r28
    4968:	c8 01       	movw	r24, r16
    496a:	46 96       	adiw	r24, 0x16	; 22
    496c:	0e 94 00 22 	call	0x4400	; 0x4400 <psock_send_P>
    4970:	88 23       	and	r24, r24
    4972:	09 f4       	brne	.+2      	; 0x4976 <send_headers+0x8e>
    4974:	a5 c0       	rjmp	.+330    	; 0x4ac0 <send_headers+0x1d8>
	
  ptr = strrchr(s->filename, ISO_period);
    4976:	6e e2       	ldi	r22, 0x2E	; 46
    4978:	70 e0       	ldi	r23, 0x00	; 0
    497a:	c8 01       	movw	r24, r16
    497c:	8f 59       	subi	r24, 0x9F	; 159
    497e:	9f 4f       	sbci	r25, 0xFF	; 255
    4980:	0e 94 ac 2c 	call	0x5958	; 0x5958 <strrchr>
    4984:	ec 01       	movw	r28, r24
	
	if(ptr == NULL) {
    4986:	00 97       	sbiw	r24, 0x00	; 0
    4988:	69 f4       	brne	.+26     	; 0x49a4 <send_headers+0xbc>
    PSOCK_SEND_STR_P(&s->sout, http_content_type_binary);
    498a:	83 ee       	ldi	r24, 0xE3	; 227
    498c:	90 e0       	ldi	r25, 0x00	; 0
    498e:	f8 01       	movw	r30, r16
    4990:	97 8b       	std	Z+23, r25	; 0x17
    4992:	86 8b       	std	Z+22, r24	; 0x16
    4994:	80 ea       	ldi	r24, 0xA0	; 160
    4996:	94 e0       	ldi	r25, 0x04	; 4
    4998:	0e 94 5c 2c 	call	0x58b8	; 0x58b8 <strlen_P>
    499c:	ac 01       	movw	r20, r24
    499e:	60 ea       	ldi	r22, 0xA0	; 160
    49a0:	74 e0       	ldi	r23, 0x04	; 4
    49a2:	82 c0       	rjmp	.+260    	; 0x4aa8 <send_headers+0x1c0>
  } else if(strncmp_P(ptr, http_html, 5) == 0 ||
    49a4:	45 e0       	ldi	r20, 0x05	; 5
    49a6:	50 e0       	ldi	r21, 0x00	; 0
    49a8:	6b ec       	ldi	r22, 0xCB	; 203
    49aa:	74 e0       	ldi	r23, 0x04	; 4
    49ac:	0e 94 65 2c 	call	0x58ca	; 0x58ca <strncmp_P>
    49b0:	89 2b       	or	r24, r25
    49b2:	49 f0       	breq	.+18     	; 0x49c6 <send_headers+0xde>
    49b4:	46 e0       	ldi	r20, 0x06	; 6
    49b6:	50 e0       	ldi	r21, 0x00	; 0
    49b8:	61 ed       	ldi	r22, 0xD1	; 209
    49ba:	74 e0       	ldi	r23, 0x04	; 4
    49bc:	ce 01       	movw	r24, r28
    49be:	0e 94 65 2c 	call	0x58ca	; 0x58ca <strncmp_P>
    49c2:	89 2b       	or	r24, r25
    49c4:	69 f4       	brne	.+26     	; 0x49e0 <send_headers+0xf8>
	    strncmp_P(ptr, http_shtml, 6) == 0) {
	  PSOCK_SEND_STR_P(&s->sout, http_content_type_html);
    49c6:	86 ee       	ldi	r24, 0xE6	; 230
    49c8:	90 e0       	ldi	r25, 0x00	; 0
    49ca:	f8 01       	movw	r30, r16
    49cc:	97 8b       	std	Z+23, r25	; 0x17
    49ce:	86 8b       	std	Z+22, r24	; 0x16
    49d0:	88 ef       	ldi	r24, 0xF8	; 248
    49d2:	93 e0       	ldi	r25, 0x03	; 3
    49d4:	0e 94 5c 2c 	call	0x58b8	; 0x58b8 <strlen_P>
    49d8:	ac 01       	movw	r20, r24
    49da:	68 ef       	ldi	r22, 0xF8	; 248
    49dc:	73 e0       	ldi	r23, 0x03	; 3
    49de:	64 c0       	rjmp	.+200    	; 0x4aa8 <send_headers+0x1c0>
  } else if(strncmp_P(ptr, http_css, 4) == 0) {
    49e0:	44 e0       	ldi	r20, 0x04	; 4
    49e2:	50 e0       	ldi	r21, 0x00	; 0
    49e4:	6d ed       	ldi	r22, 0xDD	; 221
    49e6:	74 e0       	ldi	r23, 0x04	; 4
    49e8:	ce 01       	movw	r24, r28
    49ea:	0e 94 65 2c 	call	0x58ca	; 0x58ca <strncmp_P>
    49ee:	89 2b       	or	r24, r25
    49f0:	69 f4       	brne	.+26     	; 0x4a0c <send_headers+0x124>
    PSOCK_SEND_STR_P(&s->sout, http_content_type_css);
    49f2:	88 ee       	ldi	r24, 0xE8	; 232
    49f4:	90 e0       	ldi	r25, 0x00	; 0
    49f6:	f8 01       	movw	r30, r16
    49f8:	97 8b       	std	Z+23, r25	; 0x17
    49fa:	86 8b       	std	Z+22, r24	; 0x16
    49fc:	84 e1       	ldi	r24, 0x14	; 20
    49fe:	94 e0       	ldi	r25, 0x04	; 4
    4a00:	0e 94 5c 2c 	call	0x58b8	; 0x58b8 <strlen_P>
    4a04:	ac 01       	movw	r20, r24
    4a06:	64 e1       	ldi	r22, 0x14	; 20
    4a08:	74 e0       	ldi	r23, 0x04	; 4
    4a0a:	4e c0       	rjmp	.+156    	; 0x4aa8 <send_headers+0x1c0>
  } else if(strncmp_P(ptr, http_png, 4) == 0) {
    4a0c:	44 e0       	ldi	r20, 0x04	; 4
    4a0e:	50 e0       	ldi	r21, 0x00	; 0
    4a10:	62 ee       	ldi	r22, 0xE2	; 226
    4a12:	74 e0       	ldi	r23, 0x04	; 4
    4a14:	ce 01       	movw	r24, r28
    4a16:	0e 94 65 2c 	call	0x58ca	; 0x58ca <strncmp_P>
    4a1a:	89 2b       	or	r24, r25
    4a1c:	69 f4       	brne	.+26     	; 0x4a38 <send_headers+0x150>
    PSOCK_SEND_STR_P(&s->sout, http_content_type_png);
    4a1e:	8a ee       	ldi	r24, 0xEA	; 234
    4a20:	90 e0       	ldi	r25, 0x00	; 0
    4a22:	f8 01       	movw	r30, r16
    4a24:	97 8b       	std	Z+23, r25	; 0x17
    4a26:	86 8b       	std	Z+22, r24	; 0x16
    4a28:	8b e4       	ldi	r24, 0x4B	; 75
    4a2a:	94 e0       	ldi	r25, 0x04	; 4
    4a2c:	0e 94 5c 2c 	call	0x58b8	; 0x58b8 <strlen_P>
    4a30:	ac 01       	movw	r20, r24
    4a32:	6b e4       	ldi	r22, 0x4B	; 75
    4a34:	74 e0       	ldi	r23, 0x04	; 4
    4a36:	38 c0       	rjmp	.+112    	; 0x4aa8 <send_headers+0x1c0>
  } else if(strncmp_P(ptr, http_gif, 4) == 0) {
    4a38:	44 e0       	ldi	r20, 0x04	; 4
    4a3a:	50 e0       	ldi	r21, 0x00	; 0
    4a3c:	67 ee       	ldi	r22, 0xE7	; 231
    4a3e:	74 e0       	ldi	r23, 0x04	; 4
    4a40:	ce 01       	movw	r24, r28
    4a42:	0e 94 65 2c 	call	0x58ca	; 0x58ca <strncmp_P>
    4a46:	89 2b       	or	r24, r25
    4a48:	69 f4       	brne	.+26     	; 0x4a64 <send_headers+0x17c>
    PSOCK_SEND_STR_P(&s->sout, http_content_type_gif);
    4a4a:	8c ee       	ldi	r24, 0xEC	; 236
    4a4c:	90 e0       	ldi	r25, 0x00	; 0
    4a4e:	f8 01       	movw	r30, r16
    4a50:	97 8b       	std	Z+23, r25	; 0x17
    4a52:	86 8b       	std	Z+22, r24	; 0x16
    4a54:	87 e6       	ldi	r24, 0x67	; 103
    4a56:	94 e0       	ldi	r25, 0x04	; 4
    4a58:	0e 94 5c 2c 	call	0x58b8	; 0x58b8 <strlen_P>
    4a5c:	ac 01       	movw	r20, r24
    4a5e:	67 e6       	ldi	r22, 0x67	; 103
    4a60:	74 e0       	ldi	r23, 0x04	; 4
    4a62:	22 c0       	rjmp	.+68     	; 0x4aa8 <send_headers+0x1c0>
  } else if(strncmp_P(ptr, http_jpg, 4) == 0) {
    4a64:	44 e0       	ldi	r20, 0x04	; 4
    4a66:	50 e0       	ldi	r21, 0x00	; 0
    4a68:	6c ee       	ldi	r22, 0xEC	; 236
    4a6a:	74 e0       	ldi	r23, 0x04	; 4
    4a6c:	ce 01       	movw	r24, r28
    4a6e:	0e 94 65 2c 	call	0x58ca	; 0x58ca <strncmp_P>
    4a72:	89 2b       	or	r24, r25
    4a74:	69 f4       	brne	.+26     	; 0x4a90 <send_headers+0x1a8>
    PSOCK_SEND_STR_P(&s->sout, http_content_type_jpg);
    4a76:	8e ee       	ldi	r24, 0xEE	; 238
    4a78:	90 e0       	ldi	r25, 0x00	; 0
    4a7a:	f8 01       	movw	r30, r16
    4a7c:	97 8b       	std	Z+23, r25	; 0x17
    4a7e:	86 8b       	std	Z+22, r24	; 0x16
    4a80:	83 e8       	ldi	r24, 0x83	; 131
    4a82:	94 e0       	ldi	r25, 0x04	; 4
    4a84:	0e 94 5c 2c 	call	0x58b8	; 0x58b8 <strlen_P>
    4a88:	ac 01       	movw	r20, r24
    4a8a:	63 e8       	ldi	r22, 0x83	; 131
    4a8c:	74 e0       	ldi	r23, 0x04	; 4
    4a8e:	0c c0       	rjmp	.+24     	; 0x4aa8 <send_headers+0x1c0>
  } else {
    PSOCK_SEND_STR_P(&s->sout, http_content_type_plain);
    4a90:	80 ef       	ldi	r24, 0xF0	; 240
    4a92:	90 e0       	ldi	r25, 0x00	; 0
    4a94:	f8 01       	movw	r30, r16
    4a96:	97 8b       	std	Z+23, r25	; 0x17
    4a98:	86 8b       	std	Z+22, r24	; 0x16
    4a9a:	8b ed       	ldi	r24, 0xDB	; 219
    4a9c:	93 e0       	ldi	r25, 0x03	; 3
    4a9e:	0e 94 5c 2c 	call	0x58b8	; 0x58b8 <strlen_P>
    4aa2:	ac 01       	movw	r20, r24
    4aa4:	6b ed       	ldi	r22, 0xDB	; 219
    4aa6:	73 e0       	ldi	r23, 0x03	; 3
    4aa8:	c8 01       	movw	r24, r16
    4aaa:	46 96       	adiw	r24, 0x16	; 22
    4aac:	0e 94 00 22 	call	0x4400	; 0x4400 <psock_send_P>
    4ab0:	88 23       	and	r24, r24
    4ab2:	31 f0       	breq	.+12     	; 0x4ac0 <send_headers+0x1d8>
  }
  PSOCK_END(&s->sout);
    4ab4:	f8 01       	movw	r30, r16
    4ab6:	17 8a       	std	Z+23, r1	; 0x17
    4ab8:	16 8a       	std	Z+22, r1	; 0x16
    4aba:	82 e0       	ldi	r24, 0x02	; 2
    4abc:	90 e0       	ldi	r25, 0x00	; 0
    4abe:	02 c0       	rjmp	.+4      	; 0x4ac4 <send_headers+0x1dc>
    4ac0:	80 e0       	ldi	r24, 0x00	; 0
    4ac2:	90 e0       	ldi	r25, 0x00	; 0
    4ac4:	df 91       	pop	r29
    4ac6:	cf 91       	pop	r28
    4ac8:	1f 91       	pop	r17
    4aca:	0f 91       	pop	r16
    4acc:	08 95       	ret

00004ace <send_file>:
  return s->len;
}
/*---------------------------------------------------------------------------*/
static
PT_THREAD(send_file(struct httpd_state *s))
{
    4ace:	cf 93       	push	r28
    4ad0:	df 93       	push	r29
    4ad2:	ec 01       	movw	r28, r24
	PSOCK_BEGIN(&s->sout);
    4ad4:	8e 89       	ldd	r24, Y+22	; 0x16
    4ad6:	9f 89       	ldd	r25, Y+23	; 0x17
    4ad8:	00 97       	sbiw	r24, 0x00	; 0
    4ada:	21 f0       	breq	.+8      	; 0x4ae4 <send_file+0x16>
    4adc:	82 37       	cpi	r24, 0x72	; 114
    4ade:	91 05       	cpc	r25, r1
    4ae0:	61 f5       	brne	.+88     	; 0x4b3a <send_file+0x6c>
    4ae2:	04 c0       	rjmp	.+8      	; 0x4aec <send_file+0x1e>
	do {
    PSOCK_GENERATOR_SEND(&s->sout, generate_part_of_file, s);
    4ae4:	82 e7       	ldi	r24, 0x72	; 114
    4ae6:	90 e0       	ldi	r25, 0x00	; 0
    4ae8:	9f 8b       	std	Y+23, r25	; 0x17
    4aea:	8e 8b       	std	Y+22, r24	; 0x16
    4aec:	ae 01       	movw	r20, r28
    4aee:	67 e1       	ldi	r22, 0x17	; 23
    4af0:	78 e2       	ldi	r23, 0x28	; 40
    4af2:	ce 01       	movw	r24, r28
    4af4:	46 96       	adiw	r24, 0x16	; 22
    4af6:	0e 94 7b 21 	call	0x42f6	; 0x42f6 <psock_generator_send>
    4afa:	88 23       	and	r24, r24
    4afc:	19 f4       	brne	.+6      	; 0x4b04 <send_file+0x36>
    4afe:	80 e0       	ldi	r24, 0x00	; 0
    4b00:	90 e0       	ldi	r25, 0x00	; 0
    4b02:	1f c0       	rjmp	.+62     	; 0x4b42 <send_file+0x74>
    s->file.len -= s->len;
    4b04:	fe 01       	movw	r30, r28
    4b06:	e8 58       	subi	r30, 0x88	; 136
    4b08:	ff 4f       	sbci	r31, 0xFF	; 255
    4b0a:	c6 58       	subi	r28, 0x86	; 134
    4b0c:	df 4f       	sbci	r29, 0xFF	; 255
    4b0e:	20 81       	ld	r18, Z
    4b10:	31 81       	ldd	r19, Z+1	; 0x01
    4b12:	48 81       	ld	r20, Y
    4b14:	59 81       	ldd	r21, Y+1	; 0x01
    4b16:	ca 57       	subi	r28, 0x7A	; 122
    4b18:	d0 40       	sbci	r29, 0x00	; 0
    4b1a:	24 1b       	sub	r18, r20
    4b1c:	35 0b       	sbc	r19, r21
    4b1e:	31 83       	std	Z+1, r19	; 0x01
    4b20:	20 83       	st	Z, r18
    s->file.data += s->len;
    4b22:	fe 01       	movw	r30, r28
    4b24:	ea 58       	subi	r30, 0x8A	; 138
    4b26:	ff 4f       	sbci	r31, 0xFF	; 255
    4b28:	80 81       	ld	r24, Z
    4b2a:	91 81       	ldd	r25, Z+1	; 0x01
    4b2c:	84 0f       	add	r24, r20
    4b2e:	95 1f       	adc	r25, r21
    4b30:	91 83       	std	Z+1, r25	; 0x01
    4b32:	80 83       	st	Z, r24
  } while(s->file.len > 0);
    4b34:	12 16       	cp	r1, r18
    4b36:	13 06       	cpc	r1, r19
    4b38:	ac f2       	brlt	.-86     	; 0x4ae4 <send_file+0x16>
	PSOCK_END(&s->sout);
    4b3a:	1f 8a       	std	Y+23, r1	; 0x17
    4b3c:	1e 8a       	std	Y+22, r1	; 0x16
    4b3e:	82 e0       	ldi	r24, 0x02	; 2
    4b40:	90 e0       	ldi	r25, 0x00	; 0
    4b42:	df 91       	pop	r29
    4b44:	cf 91       	pop	r28
    4b46:	08 95       	ret

00004b48 <handle_connection>:
  PSOCK_END(&s->sin);
}
/*---------------------------------------------------------------------------*/
static void
handle_connection(struct httpd_state *s)
{
    4b48:	ef 92       	push	r14
    4b4a:	ff 92       	push	r15
    4b4c:	0f 93       	push	r16
    4b4e:	1f 93       	push	r17
    4b50:	cf 93       	push	r28
    4b52:	df 93       	push	r29
    4b54:	ec 01       	movw	r28, r24
/*---------------------------------------------------------------------------*/
static
PT_THREAD(handle_input(struct httpd_state *s))
{
	//uart_puts_P(PSTR("\n\r\x1B[1mHandle Input\x1B[0m"));
	PSOCK_BEGIN(&s->sin);
    4b56:	89 81       	ldd	r24, Y+1	; 0x01
    4b58:	9a 81       	ldd	r25, Y+2	; 0x02
    4b5a:	21 e0       	ldi	r18, 0x01	; 1
    4b5c:	85 31       	cpi	r24, 0x15	; 21
    4b5e:	92 07       	cpc	r25, r18
    4b60:	a1 f0       	breq	.+40     	; 0x4b8a <handle_connection+0x42>
    4b62:	a1 e0       	ldi	r26, 0x01	; 1
    4b64:	86 31       	cpi	r24, 0x16	; 22
    4b66:	9a 07       	cpc	r25, r26
    4b68:	18 f4       	brcc	.+6      	; 0x4b70 <handle_connection+0x28>
    4b6a:	89 2b       	or	r24, r25
    4b6c:	51 f0       	breq	.+20     	; 0x4b82 <handle_connection+0x3a>
    4b6e:	78 c0       	rjmp	.+240    	; 0x4c60 <handle_connection+0x118>
    4b70:	b1 e0       	ldi	r27, 0x01	; 1
    4b72:	8a 31       	cpi	r24, 0x1A	; 26
    4b74:	9b 07       	cpc	r25, r27
    4b76:	f9 f0       	breq	.+62     	; 0x4bb6 <handle_connection+0x6e>
    4b78:	88 52       	subi	r24, 0x28	; 40
    4b7a:	91 40       	sbci	r25, 0x01	; 1
    4b7c:	09 f0       	breq	.+2      	; 0x4b80 <handle_connection+0x38>
    4b7e:	70 c0       	rjmp	.+224    	; 0x4c60 <handle_connection+0x118>
    4b80:	54 c0       	rjmp	.+168    	; 0x4c2a <handle_connection+0xe2>

  PSOCK_READTO(&s->sin, ISO_space);
    4b82:	85 e1       	ldi	r24, 0x15	; 21
    4b84:	91 e0       	ldi	r25, 0x01	; 1
    4b86:	9a 83       	std	Y+2, r25	; 0x02
    4b88:	89 83       	std	Y+1, r24	; 0x01
    4b8a:	60 e2       	ldi	r22, 0x20	; 32
    4b8c:	ce 01       	movw	r24, r28
    4b8e:	01 96       	adiw	r24, 0x01	; 1
    4b90:	0e 94 01 23 	call	0x4602	; 0x4602 <psock_readto>
    4b94:	88 23       	and	r24, r24
    4b96:	09 f4       	brne	.+2      	; 0x4b9a <handle_connection+0x52>
    4b98:	65 c0       	rjmp	.+202    	; 0x4c64 <handle_connection+0x11c>

  if(strncmp_P(s->inputbuf, http_get, 4) != 0) {
    4b9a:	44 e0       	ldi	r20, 0x04	; 4
    4b9c:	50 e0       	ldi	r21, 0x00	; 0
    4b9e:	68 ec       	ldi	r22, 0xC8	; 200
    4ba0:	72 e0       	ldi	r23, 0x02	; 2
    4ba2:	ce 01       	movw	r24, r28
    4ba4:	8f 96       	adiw	r24, 0x2f	; 47
    4ba6:	0e 94 65 2c 	call	0x58ca	; 0x58ca <strncmp_P>
    4baa:	89 2b       	or	r24, r25
    4bac:	89 f4       	brne	.+34     	; 0x4bd0 <handle_connection+0x88>
    PSOCK_CLOSE_EXIT(&s->sin);
  }
  PSOCK_READTO(&s->sin, ISO_space);
    4bae:	8a e1       	ldi	r24, 0x1A	; 26
    4bb0:	91 e0       	ldi	r25, 0x01	; 1
    4bb2:	9a 83       	std	Y+2, r25	; 0x02
    4bb4:	89 83       	std	Y+1, r24	; 0x01
    4bb6:	8e 01       	movw	r16, r28
    4bb8:	0f 5f       	subi	r16, 0xFF	; 255
    4bba:	1f 4f       	sbci	r17, 0xFF	; 255
    4bbc:	60 e2       	ldi	r22, 0x20	; 32
    4bbe:	c8 01       	movw	r24, r16
    4bc0:	0e 94 01 23 	call	0x4602	; 0x4602 <psock_readto>
    4bc4:	88 23       	and	r24, r24
    4bc6:	09 f4       	brne	.+2      	; 0x4bca <handle_connection+0x82>
    4bc8:	4d c0       	rjmp	.+154    	; 0x4c64 <handle_connection+0x11c>
	
  if(s->inputbuf[0] != ISO_slash) {
    4bca:	8f a5       	ldd	r24, Y+47	; 0x2f
    4bcc:	8f 32       	cpi	r24, 0x2F	; 47
    4bce:	21 f0       	breq	.+8      	; 0x4bd8 <handle_connection+0x90>
    PSOCK_CLOSE_EXIT(&s->sin);
    4bd0:	80 e1       	ldi	r24, 0x10	; 16
    4bd2:	80 93 3f 04 	sts	0x043F, r24
    4bd6:	44 c0       	rjmp	.+136    	; 0x4c60 <handle_connection+0x118>
  }
	
  if(s->inputbuf[1] == ISO_space) {
    4bd8:	88 a9       	ldd	r24, Y+48	; 0x30
    4bda:	21 e6       	ldi	r18, 0x61	; 97
    4bdc:	e2 2e       	mov	r14, r18
    4bde:	f1 2c       	mov	r15, r1
    4be0:	ec 0e       	add	r14, r28
    4be2:	fd 1e       	adc	r15, r29
    4be4:	80 32       	cpi	r24, 0x20	; 32
    4be6:	41 f4       	brne	.+16     	; 0x4bf8 <handle_connection+0xb0>
    strncpy_P(s->filename, http_index_html, sizeof(s->filename));
    4be8:	44 e1       	ldi	r20, 0x14	; 20
    4bea:	50 e0       	ldi	r21, 0x00	; 0
    4bec:	6d e0       	ldi	r22, 0x0D	; 13
    4bee:	73 e0       	ldi	r23, 0x03	; 3
    4bf0:	c7 01       	movw	r24, r14
    4bf2:	0e 94 73 2c 	call	0x58e6	; 0x58e6 <strncpy_P>
    4bf6:	0f c0       	rjmp	.+30     	; 0x4c16 <handle_connection+0xce>
  } else {
    s->inputbuf[PSOCK_DATALEN(&s->sin) - 1] = 0;
    4bf8:	c8 01       	movw	r24, r16
    4bfa:	0e 94 37 21 	call	0x426e	; 0x426e <psock_datalen>
    4bfe:	fc 01       	movw	r30, r24
    4c00:	ec 0f       	add	r30, r28
    4c02:	fd 1f       	adc	r31, r29
    4c04:	16 a6       	std	Z+46, r1	; 0x2e
    strncpy(s->filename, &s->inputbuf[0], sizeof(s->filename));
    4c06:	be 01       	movw	r22, r28
    4c08:	61 5d       	subi	r22, 0xD1	; 209
    4c0a:	7f 4f       	sbci	r23, 0xFF	; 255
    4c0c:	44 e1       	ldi	r20, 0x14	; 20
    4c0e:	50 e0       	ldi	r21, 0x00	; 0
    4c10:	c7 01       	movw	r24, r14
    4c12:	0e 94 9d 2c 	call	0x593a	; 0x593a <strncpy>
  }
	s->state = STATE_OUTPUT;
    4c16:	cb 58       	subi	r28, 0x8B	; 139
    4c18:	df 4f       	sbci	r29, 0xFF	; 255
    4c1a:	81 e0       	ldi	r24, 0x01	; 1
    4c1c:	88 83       	st	Y, r24
    4c1e:	c5 57       	subi	r28, 0x75	; 117
    4c20:	d0 40       	sbci	r29, 0x00	; 0
	while(1) {
    PSOCK_READTO(&s->sin, ISO_nl);
    4c22:	88 e2       	ldi	r24, 0x28	; 40
    4c24:	91 e0       	ldi	r25, 0x01	; 1
    4c26:	9a 83       	std	Y+2, r25	; 0x02
    4c28:	89 83       	std	Y+1, r24	; 0x01
    4c2a:	8e 01       	movw	r16, r28
    4c2c:	0f 5f       	subi	r16, 0xFF	; 255
    4c2e:	1f 4f       	sbci	r17, 0xFF	; 255
    4c30:	6a e0       	ldi	r22, 0x0A	; 10
    4c32:	c8 01       	movw	r24, r16
    4c34:	0e 94 01 23 	call	0x4602	; 0x4602 <psock_readto>
    4c38:	88 23       	and	r24, r24
    4c3a:	a1 f0       	breq	.+40     	; 0x4c64 <handle_connection+0x11c>
	  if(strncmp_P(s->inputbuf, http_referer, 8) == 0) {
    4c3c:	48 e0       	ldi	r20, 0x08	; 8
    4c3e:	50 e0       	ldi	r21, 0x00	; 0
    4c40:	63 e2       	ldi	r22, 0x23	; 35
    4c42:	73 e0       	ldi	r23, 0x03	; 3
    4c44:	ce 01       	movw	r24, r28
    4c46:	8f 96       	adiw	r24, 0x2f	; 47
    4c48:	0e 94 65 2c 	call	0x58ca	; 0x58ca <strncmp_P>
    4c4c:	89 2b       	or	r24, r25
    4c4e:	49 f7       	brne	.-46     	; 0x4c22 <handle_connection+0xda>
      s->inputbuf[PSOCK_DATALEN(&s->sin) - 2] = 0;
    4c50:	c8 01       	movw	r24, r16
    4c52:	0e 94 37 21 	call	0x426e	; 0x426e <psock_datalen>
    4c56:	fc 01       	movw	r30, r24
    4c58:	ec 0f       	add	r30, r28
    4c5a:	fd 1f       	adc	r31, r29
    4c5c:	15 a6       	std	Z+45, r1	; 0x2d
    4c5e:	e1 cf       	rjmp	.-62     	; 0x4c22 <handle_connection+0xda>
      /*      httpd_log(&s->inputbuf[9]);*/
    }
  }
  
  PSOCK_END(&s->sin);
    4c60:	1a 82       	std	Y+2, r1	; 0x02
    4c62:	19 82       	std	Y+1, r1	; 0x01
/*---------------------------------------------------------------------------*/
static void
handle_connection(struct httpd_state *s)
{
  handle_input(s);
  if(s->state == STATE_OUTPUT) {
    4c64:	cb 58       	subi	r28, 0x8B	; 139
    4c66:	df 4f       	sbci	r29, 0xFF	; 255
    4c68:	88 81       	ld	r24, Y
    4c6a:	c5 57       	subi	r28, 0x75	; 117
    4c6c:	d0 40       	sbci	r29, 0x00	; 0
    4c6e:	81 30       	cpi	r24, 0x01	; 1
    4c70:	09 f0       	breq	.+2      	; 0x4c74 <handle_connection+0x12c>
    4c72:	85 c1       	rjmp	.+778    	; 0x4f7e <handle_connection+0x436>
/*---------------------------------------------------------------------------*/
static
PT_THREAD(handle_output(struct httpd_state *s))
{
	char *ptr;
  PT_BEGIN(&s->outputpt);
    4c74:	8b a5       	ldd	r24, Y+43	; 0x2b
    4c76:	9c a5       	ldd	r25, Y+44	; 0x2c
    4c78:	8e 3f       	cpi	r24, 0xFE	; 254
    4c7a:	91 05       	cpc	r25, r1
    4c7c:	09 f4       	brne	.+2      	; 0x4c80 <handle_connection+0x138>
    4c7e:	41 c0       	rjmp	.+130    	; 0x4d02 <handle_connection+0x1ba>
    4c80:	8f 3f       	cpi	r24, 0xFF	; 255
    4c82:	91 05       	cpc	r25, r1
    4c84:	38 f4       	brcc	.+14     	; 0x4c94 <handle_connection+0x14c>
    4c86:	00 97       	sbiw	r24, 0x00	; 0
    4c88:	a1 f0       	breq	.+40     	; 0x4cb2 <handle_connection+0x16a>
    4c8a:	8d 3f       	cpi	r24, 0xFD	; 253
    4c8c:	91 05       	cpc	r25, r1
    4c8e:	09 f0       	breq	.+2      	; 0x4c92 <handle_connection+0x14a>
    4c90:	74 c1       	rjmp	.+744    	; 0x4f7a <handle_connection+0x432>
    4c92:	2b c0       	rjmp	.+86     	; 0x4cea <handle_connection+0x1a2>
    4c94:	f1 e0       	ldi	r31, 0x01	; 1
    4c96:	86 30       	cpi	r24, 0x06	; 6
    4c98:	9f 07       	cpc	r25, r31
    4c9a:	09 f4       	brne	.+2      	; 0x4c9e <handle_connection+0x156>
    4c9c:	5e c0       	rjmp	.+188    	; 0x4d5a <handle_connection+0x212>
    4c9e:	21 e0       	ldi	r18, 0x01	; 1
    4ca0:	88 30       	cpi	r24, 0x08	; 8
    4ca2:	92 07       	cpc	r25, r18
    4ca4:	09 f4       	brne	.+2      	; 0x4ca8 <handle_connection+0x160>
    4ca6:	61 c1       	rjmp	.+706    	; 0x4f6a <handle_connection+0x422>
    4ca8:	80 50       	subi	r24, 0x00	; 0
    4caa:	91 40       	sbci	r25, 0x01	; 1
    4cac:	09 f0       	breq	.+2      	; 0x4cb0 <handle_connection+0x168>
    4cae:	65 c1       	rjmp	.+714    	; 0x4f7a <handle_connection+0x432>
    4cb0:	33 c0       	rjmp	.+102    	; 0x4d18 <handle_connection+0x1d0>
  if(!httpd_fs_open(s->filename, &s->file)) {
    4cb2:	8e 01       	movw	r16, r28
    4cb4:	0a 58       	subi	r16, 0x8A	; 138
    4cb6:	1f 4f       	sbci	r17, 0xFF	; 255
    4cb8:	91 e6       	ldi	r25, 0x61	; 97
    4cba:	e9 2e       	mov	r14, r25
    4cbc:	f1 2c       	mov	r15, r1
    4cbe:	ec 0e       	add	r14, r28
    4cc0:	fd 1e       	adc	r15, r29
    4cc2:	b8 01       	movw	r22, r16
    4cc4:	c7 01       	movw	r24, r14
    4cc6:	0e 94 63 28 	call	0x50c6	; 0x50c6 <httpd_fs_open>
    4cca:	89 2b       	or	r24, r25
    4ccc:	09 f5       	brne	.+66     	; 0x4d10 <handle_connection+0x1c8>
    httpd_fs_open_P(http_404_html, &s->file);
    4cce:	b8 01       	movw	r22, r16
    4cd0:	89 e1       	ldi	r24, 0x19	; 25
    4cd2:	93 e0       	ldi	r25, 0x03	; 3
    4cd4:	0e 94 a1 28 	call	0x5142	; 0x5142 <httpd_fs_open_P>
    strcpy_P(s->filename, http_404_html);
    4cd8:	69 e1       	ldi	r22, 0x19	; 25
    4cda:	73 e0       	ldi	r23, 0x03	; 3
    4cdc:	c7 01       	movw	r24, r14
    4cde:	0e 94 55 2c 	call	0x58aa	; 0x58aa <strcpy_P>
    PT_WAIT_THREAD(&s->outputpt,send_headers(s,http_header_404));
    4ce2:	8d ef       	ldi	r24, 0xFD	; 253
    4ce4:	90 e0       	ldi	r25, 0x00	; 0
    4ce6:	9c a7       	std	Y+44, r25	; 0x2c
    4ce8:	8b a7       	std	Y+43, r24	; 0x2b
    4cea:	60 e8       	ldi	r22, 0x80	; 128
    4cec:	73 e0       	ldi	r23, 0x03	; 3
    4cee:	ce 01       	movw	r24, r28
    4cf0:	0e 94 74 24 	call	0x48e8	; 0x48e8 <send_headers>
    4cf4:	88 23       	and	r24, r24
    4cf6:	09 f4       	brne	.+2      	; 0x4cfa <handle_connection+0x1b2>
    4cf8:	42 c1       	rjmp	.+644    	; 0x4f7e <handle_connection+0x436>
    PT_WAIT_THREAD(&s->outputpt,send_file(s));
    4cfa:	8e ef       	ldi	r24, 0xFE	; 254
    4cfc:	90 e0       	ldi	r25, 0x00	; 0
    4cfe:	9c a7       	std	Y+44, r25	; 0x2c
    4d00:	8b a7       	std	Y+43, r24	; 0x2b
    4d02:	ce 01       	movw	r24, r28
    4d04:	0e 94 67 25 	call	0x4ace	; 0x4ace <send_file>
    4d08:	88 23       	and	r24, r24
    4d0a:	09 f0       	breq	.+2      	; 0x4d0e <handle_connection+0x1c6>
    4d0c:	33 c1       	rjmp	.+614    	; 0x4f74 <handle_connection+0x42c>
    4d0e:	37 c1       	rjmp	.+622    	; 0x4f7e <handle_connection+0x436>
  } else {
    PT_WAIT_THREAD(&s->outputpt,send_headers(s,http_header_200));
    4d10:	80 e0       	ldi	r24, 0x00	; 0
    4d12:	91 e0       	ldi	r25, 0x01	; 1
    4d14:	9c a7       	std	Y+44, r25	; 0x2c
    4d16:	8b a7       	std	Y+43, r24	; 0x2b
    4d18:	6c e2       	ldi	r22, 0x2C	; 44
    4d1a:	73 e0       	ldi	r23, 0x03	; 3
    4d1c:	ce 01       	movw	r24, r28
    4d1e:	0e 94 74 24 	call	0x48e8	; 0x48e8 <send_headers>
    4d22:	88 23       	and	r24, r24
    4d24:	09 f4       	brne	.+2      	; 0x4d28 <handle_connection+0x1e0>
    4d26:	2b c1       	rjmp	.+598    	; 0x4f7e <handle_connection+0x436>
		
		// s->filename = RAM
    ptr = strchr(s->filename, ISO_period);
    4d28:	6e e2       	ldi	r22, 0x2E	; 46
    4d2a:	70 e0       	ldi	r23, 0x00	; 0
    4d2c:	ce 01       	movw	r24, r28
    4d2e:	8f 59       	subi	r24, 0x9F	; 159
    4d30:	9f 4f       	sbci	r25, 0xFF	; 255
    4d32:	0e 94 92 2c 	call	0x5924	; 0x5924 <strchr>
    if(ptr != NULL && strncmp_P(ptr, http_shtml, 6) == 0) {
    4d36:	00 97       	sbiw	r24, 0x00	; 0
    4d38:	09 f4       	brne	.+2      	; 0x4d3c <handle_connection+0x1f4>
    4d3a:	13 c1       	rjmp	.+550    	; 0x4f62 <handle_connection+0x41a>
    4d3c:	46 e0       	ldi	r20, 0x06	; 6
    4d3e:	50 e0       	ldi	r21, 0x00	; 0
    4d40:	61 ed       	ldi	r22, 0xD1	; 209
    4d42:	74 e0       	ldi	r23, 0x04	; 4
    4d44:	0e 94 65 2c 	call	0x58ca	; 0x58ca <strncmp_P>
    4d48:	89 2b       	or	r24, r25
    4d4a:	09 f0       	breq	.+2      	; 0x4d4e <handle_connection+0x206>
    4d4c:	0a c1       	rjmp	.+532    	; 0x4f62 <handle_connection+0x41a>
      PT_INIT(&s->scriptpt);
    4d4e:	1e a6       	std	Y+46, r1	; 0x2e
    4d50:	1d a6       	std	Y+45, r1	; 0x2d
      PT_WAIT_THREAD(&s->outputpt, handle_script(s));
    4d52:	86 e0       	ldi	r24, 0x06	; 6
    4d54:	91 e0       	ldi	r25, 0x01	; 1
    4d56:	9c a7       	std	Y+44, r25	; 0x2c
    4d58:	8b a7       	std	Y+43, r24	; 0x2b
/*---------------------------------------------------------------------------*/
static
PT_THREAD(handle_script(struct httpd_state *s))
{
  char *ptr;
	PT_BEGIN(&s->scriptpt);
    4d5a:	8d a5       	ldd	r24, Y+45	; 0x2d
    4d5c:	9e a5       	ldd	r25, Y+46	; 0x2e
    4d5e:	8e 3a       	cpi	r24, 0xAE	; 174
    4d60:	91 05       	cpc	r25, r1
    4d62:	09 f4       	brne	.+2      	; 0x4d66 <handle_connection+0x21e>
    4d64:	39 c0       	rjmp	.+114    	; 0x4dd8 <handle_connection+0x290>
    4d66:	8f 3a       	cpi	r24, 0xAF	; 175
    4d68:	91 05       	cpc	r25, r1
    4d6a:	20 f4       	brcc	.+8      	; 0x4d74 <handle_connection+0x22c>
    4d6c:	89 2b       	or	r24, r25
    4d6e:	09 f4       	brne	.+2      	; 0x4d72 <handle_connection+0x22a>
    4d70:	eb c0       	rjmp	.+470    	; 0x4f48 <handle_connection+0x400>
    4d72:	f4 c0       	rjmp	.+488    	; 0x4f5c <handle_connection+0x414>
    4d74:	81 3b       	cpi	r24, 0xB1	; 177
    4d76:	91 05       	cpc	r25, r1
    4d78:	09 f4       	brne	.+2      	; 0x4d7c <handle_connection+0x234>
    4d7a:	39 c0       	rjmp	.+114    	; 0x4dee <handle_connection+0x2a6>
    4d7c:	80 3d       	cpi	r24, 0xD0	; 208
    4d7e:	91 05       	cpc	r25, r1
    4d80:	09 f0       	breq	.+2      	; 0x4d84 <handle_connection+0x23c>
    4d82:	ec c0       	rjmp	.+472    	; 0x4f5c <handle_connection+0x414>
    4d84:	ac c0       	rjmp	.+344    	; 0x4ede <handle_connection+0x396>
	//uart_puts_P(PSTR("\r\nSCRIPT"));
	while(s->file.len > 0) {

    /* Check if we should start executing a script. */
    if((pgm_read_byte(s->file.data) == ISO_percent) &&
    4d86:	de 01       	movw	r26, r28
    4d88:	aa 58       	subi	r26, 0x8A	; 138
    4d8a:	bf 4f       	sbci	r27, 0xFF	; 255
    4d8c:	ed 91       	ld	r30, X+
    4d8e:	fc 91       	ld	r31, X
    4d90:	11 97       	sbiw	r26, 0x01	; 1
    4d92:	84 91       	lpm	r24, Z
    4d94:	85 32       	cpi	r24, 0x25	; 37
    4d96:	09 f0       	breq	.+2      	; 0x4d9a <handle_connection+0x252>
    4d98:	61 c0       	rjmp	.+194    	; 0x4e5c <handle_connection+0x314>
       (pgm_read_byte(s->file.data + 1) == ISO_bang)) {
    4d9a:	31 96       	adiw	r30, 0x01	; 1
    4d9c:	84 91       	lpm	r24, Z
    4d9e:	31 97       	sbiw	r30, 0x01	; 1
	PT_BEGIN(&s->scriptpt);
	//uart_puts_P(PSTR("\r\nSCRIPT"));
	while(s->file.len > 0) {

    /* Check if we should start executing a script. */
    if((pgm_read_byte(s->file.data) == ISO_percent) &&
    4da0:	81 32       	cpi	r24, 0x21	; 33
    4da2:	09 f0       	breq	.+2      	; 0x4da6 <handle_connection+0x25e>
    4da4:	5b c0       	rjmp	.+182    	; 0x4e5c <handle_connection+0x314>
       (pgm_read_byte(s->file.data + 1) == ISO_bang)) {
      s->scriptptr = s->file.data + 3;
    4da6:	c4 58       	subi	r28, 0x84	; 132
    4da8:	df 4f       	sbci	r29, 0xFF	; 255
    4daa:	33 96       	adiw	r30, 0x03	; 3
    4dac:	e9 93       	st	Y+, r30
    4dae:	f9 93       	st	Y+, r31
      s->scriptlen = s->file.len - 3;
    4db0:	23 50       	subi	r18, 0x03	; 3
    4db2:	30 40       	sbci	r19, 0x00	; 0
    4db4:	39 83       	std	Y+1, r19	; 0x01
    4db6:	28 83       	st	Y, r18
    4db8:	ce 57       	subi	r28, 0x7E	; 126
    4dba:	d0 40       	sbci	r29, 0x00	; 0
			if(pgm_read_byte(s->scriptptr - 1) == ISO_colon) {
    4dbc:	31 97       	sbiw	r30, 0x01	; 1
    4dbe:	84 91       	lpm	r24, Z
    4dc0:	32 97       	sbiw	r30, 0x02	; 2
    4dc2:	8a 33       	cpi	r24, 0x3A	; 58
    4dc4:	81 f4       	brne	.+32     	; 0x4de6 <handle_connection+0x29e>

				httpd_fs_open_P(s->scriptptr + 1, &s->file);
    4dc6:	bd 01       	movw	r22, r26
    4dc8:	cf 01       	movw	r24, r30
    4dca:	04 96       	adiw	r24, 0x04	; 4
    4dcc:	0e 94 a1 28 	call	0x5142	; 0x5142 <httpd_fs_open_P>
			PT_WAIT_THREAD(&s->scriptpt, send_file(s));
    4dd0:	8e ea       	ldi	r24, 0xAE	; 174
    4dd2:	90 e0       	ldi	r25, 0x00	; 0
    4dd4:	9e a7       	std	Y+46, r25	; 0x2e
    4dd6:	8d a7       	std	Y+45, r24	; 0x2d
    4dd8:	ce 01       	movw	r24, r28
    4dda:	0e 94 67 25 	call	0x4ace	; 0x4ace <send_file>
    4dde:	88 23       	and	r24, r24
    4de0:	09 f4       	brne	.+2      	; 0x4de4 <handle_connection+0x29c>
    4de2:	cd c0       	rjmp	.+410    	; 0x4f7e <handle_connection+0x436>
    4de4:	15 c0       	rjmp	.+42     	; 0x4e10 <handle_connection+0x2c8>
			
      } else {
				PT_WAIT_THREAD(&s->scriptpt, httpd_cgi(s->scriptptr)(s, s->scriptptr));
    4de6:	81 eb       	ldi	r24, 0xB1	; 177
    4de8:	90 e0       	ldi	r25, 0x00	; 0
    4dea:	9e a7       	std	Y+46, r25	; 0x2e
    4dec:	8d a7       	std	Y+45, r24	; 0x2d
    4dee:	8e 01       	movw	r16, r28
    4df0:	04 58       	subi	r16, 0x84	; 132
    4df2:	1f 4f       	sbci	r17, 0xFF	; 255
    4df4:	f8 01       	movw	r30, r16
    4df6:	80 81       	ld	r24, Z
    4df8:	91 81       	ldd	r25, Z+1	; 0x01
    4dfa:	0e 94 26 29 	call	0x524c	; 0x524c <httpd_cgi>
    4dfe:	fc 01       	movw	r30, r24
    4e00:	d8 01       	movw	r26, r16
    4e02:	6d 91       	ld	r22, X+
    4e04:	7c 91       	ld	r23, X
    4e06:	ce 01       	movw	r24, r28
    4e08:	09 95       	icall
    4e0a:	88 23       	and	r24, r24
    4e0c:	09 f4       	brne	.+2      	; 0x4e10 <handle_connection+0x2c8>
    4e0e:	b7 c0       	rjmp	.+366    	; 0x4f7e <handle_connection+0x436>
/*---------------------------------------------------------------------------*/
static void
next_scriptstate(struct httpd_state *s)
{
  char *p;
  p = strchr_P(s->scriptptr, ISO_nl) + 1;
    4e10:	8c e7       	ldi	r24, 0x7C	; 124
    4e12:	e8 2e       	mov	r14, r24
    4e14:	f1 2c       	mov	r15, r1
    4e16:	ec 0e       	add	r14, r28
    4e18:	fd 1e       	adc	r15, r29
    4e1a:	f7 01       	movw	r30, r14
    4e1c:	00 81       	ld	r16, Z
    4e1e:	11 81       	ldd	r17, Z+1	; 0x01
    4e20:	6a e0       	ldi	r22, 0x0A	; 10
    4e22:	70 e0       	ldi	r23, 0x00	; 0
    4e24:	c8 01       	movw	r24, r16
    4e26:	0e 94 41 2c 	call	0x5882	; 0x5882 <strchr_P>
    4e2a:	01 96       	adiw	r24, 0x01	; 1
  s->scriptlen -= (unsigned short)(p - s->scriptptr);
    4e2c:	fe 01       	movw	r30, r28
    4e2e:	e2 58       	subi	r30, 0x82	; 130
    4e30:	ff 4f       	sbci	r31, 0xFF	; 255
    4e32:	ac 01       	movw	r20, r24
    4e34:	40 1b       	sub	r20, r16
    4e36:	51 0b       	sbc	r21, r17
    4e38:	20 81       	ld	r18, Z
    4e3a:	31 81       	ldd	r19, Z+1	; 0x01
    4e3c:	24 1b       	sub	r18, r20
    4e3e:	35 0b       	sbc	r19, r21
    4e40:	31 83       	std	Z+1, r19	; 0x01
    4e42:	20 83       	st	Z, r18
  s->scriptptr = p;
    4e44:	d7 01       	movw	r26, r14
    4e46:	8d 93       	st	X+, r24
    4e48:	9c 93       	st	X, r25
      }
      next_scriptstate(s);
      
      /* The script is over, so we reset the pointers and continue
			sending the rest of the file. */
      s->file.data = s->scriptptr;
    4e4a:	ca 58       	subi	r28, 0x8A	; 138
    4e4c:	df 4f       	sbci	r29, 0xFF	; 255
    4e4e:	89 93       	st	Y+, r24
    4e50:	99 93       	st	Y+, r25
      s->file.len = s->scriptlen;
    4e52:	39 83       	std	Y+1, r19	; 0x01
    4e54:	28 83       	st	Y, r18
    4e56:	c8 57       	subi	r28, 0x78	; 120
    4e58:	d0 40       	sbci	r29, 0x00	; 0
    4e5a:	76 c0       	rjmp	.+236    	; 0x4f48 <handle_connection+0x400>
    } else {
      /* See if we find the start of script marker in the block of HTML
	 to be sent. */
			//uart_puts_P(PSTR("\n\r\x1B[1mscript marker\x1B[0m"));
      if(s->file.len > uip_mss()) {
    4e5c:	e0 91 42 04 	lds	r30, 0x0442
    4e60:	f0 91 43 04 	lds	r31, 0x0443
    4e64:	82 89       	ldd	r24, Z+18	; 0x12
    4e66:	93 89       	ldd	r25, Z+19	; 0x13
    4e68:	fe 01       	movw	r30, r28
    4e6a:	e6 58       	subi	r30, 0x86	; 134
    4e6c:	ff 4f       	sbci	r31, 0xFF	; 255
    4e6e:	82 17       	cp	r24, r18
    4e70:	93 07       	cpc	r25, r19
    4e72:	18 f4       	brcc	.+6      	; 0x4e7a <handle_connection+0x332>
				s->len = uip_mss();
    4e74:	91 83       	std	Z+1, r25	; 0x01
    4e76:	80 83       	st	Z, r24
    4e78:	02 c0       	rjmp	.+4      	; 0x4e7e <handle_connection+0x336>
      } else {
				s->len = s->file.len;
    4e7a:	31 83       	std	Z+1, r19	; 0x01
    4e7c:	20 83       	st	Z, r18
      }

			if(pgm_read_byte(s->file.data) == ISO_percent) {
    4e7e:	ca 58       	subi	r28, 0x8A	; 138
    4e80:	df 4f       	sbci	r29, 0xFF	; 255
    4e82:	08 81       	ld	r16, Y
    4e84:	19 81       	ldd	r17, Y+1	; 0x01
    4e86:	c6 57       	subi	r28, 0x76	; 118
    4e88:	d0 40       	sbci	r29, 0x00	; 0
    4e8a:	f8 01       	movw	r30, r16
    4e8c:	84 91       	lpm	r24, Z
    4e8e:	85 32       	cpi	r24, 0x25	; 37
    4e90:	29 f4       	brne	.+10     	; 0x4e9c <handle_connection+0x354>
				ptr = strchr_P(s->file.data + 1, ISO_percent);
    4e92:	65 e2       	ldi	r22, 0x25	; 37
    4e94:	70 e0       	ldi	r23, 0x00	; 0
    4e96:	c8 01       	movw	r24, r16
    4e98:	01 96       	adiw	r24, 0x01	; 1
    4e9a:	03 c0       	rjmp	.+6      	; 0x4ea2 <handle_connection+0x35a>
      } else {
				ptr = strchr_P(s->file.data, ISO_percent); 
    4e9c:	65 e2       	ldi	r22, 0x25	; 37
    4e9e:	70 e0       	ldi	r23, 0x00	; 0
    4ea0:	c8 01       	movw	r24, r16
    4ea2:	0e 94 41 2c 	call	0x5882	; 0x5882 <strchr_P>
      }
      if(ptr != NULL && ptr != s->file.data) {
    4ea6:	00 97       	sbiw	r24, 0x00	; 0
    4ea8:	b1 f0       	breq	.+44     	; 0x4ed6 <handle_connection+0x38e>
    4eaa:	80 17       	cp	r24, r16
    4eac:	91 07       	cpc	r25, r17
    4eae:	99 f0       	breq	.+38     	; 0x4ed6 <handle_connection+0x38e>
				s->len = (int)(ptr - s->file.data);
    4eb0:	80 1b       	sub	r24, r16
    4eb2:	91 0b       	sbc	r25, r17
    4eb4:	de 01       	movw	r26, r28
    4eb6:	a6 58       	subi	r26, 0x86	; 134
    4eb8:	bf 4f       	sbci	r27, 0xFF	; 255
    4eba:	11 96       	adiw	r26, 0x01	; 1
    4ebc:	9c 93       	st	X, r25
    4ebe:	8e 93       	st	-X, r24
				if(s->len >= uip_mss()) {
    4ec0:	e0 91 42 04 	lds	r30, 0x0442
    4ec4:	f0 91 43 04 	lds	r31, 0x0443
    4ec8:	22 89       	ldd	r18, Z+18	; 0x12
    4eca:	33 89       	ldd	r19, Z+19	; 0x13
    4ecc:	82 17       	cp	r24, r18
    4ece:	93 07       	cpc	r25, r19
    4ed0:	10 f0       	brcs	.+4      	; 0x4ed6 <handle_connection+0x38e>
					s->len = uip_mss();
    4ed2:	2d 93       	st	X+, r18
    4ed4:	3c 93       	st	X, r19
				}
      }
			//uart_puts_P(PSTR("\n\r\x1B[1msend ???\x1B[0m"));
      PT_WAIT_THREAD(&s->scriptpt, send_part_of_file(s));
    4ed6:	80 ed       	ldi	r24, 0xD0	; 208
    4ed8:	90 e0       	ldi	r25, 0x00	; 0
    4eda:	9e a7       	std	Y+46, r25	; 0x2e
    4edc:	8d a7       	std	Y+45, r24	; 0x2d
}
/*---------------------------------------------------------------------------*/
static
PT_THREAD(send_part_of_file(struct httpd_state *s))
{
  PSOCK_BEGIN(&s->sout);
    4ede:	8e 89       	ldd	r24, Y+22	; 0x16
    4ee0:	9f 89       	ldd	r25, Y+23	; 0x17
    4ee2:	00 97       	sbiw	r24, 0x00	; 0
    4ee4:	21 f0       	breq	.+8      	; 0x4eee <handle_connection+0x3a6>
    4ee6:	86 38       	cpi	r24, 0x86	; 134
    4ee8:	91 05       	cpc	r25, r1
    4eea:	a1 f4       	brne	.+40     	; 0x4f14 <handle_connection+0x3cc>
    4eec:	04 c0       	rjmp	.+8      	; 0x4ef6 <handle_connection+0x3ae>
		if (((char*)uip_appdata)[t]!='\n')
			//	uart_putc( ((unsigned char *)uip_appdata)[t]);
			uart_putc(pgm_read_byte((char *)(s->file.data+t)));
	uart_puts_P(PSTR("<<<\r\n"));*/
  
  PSOCK_SEND_P(&s->sout, s->file.data, s->len);
    4eee:	86 e8       	ldi	r24, 0x86	; 134
    4ef0:	90 e0       	ldi	r25, 0x00	; 0
    4ef2:	9f 8b       	std	Y+23, r25	; 0x17
    4ef4:	8e 8b       	std	Y+22, r24	; 0x16
    4ef6:	c6 58       	subi	r28, 0x86	; 134
    4ef8:	df 4f       	sbci	r29, 0xFF	; 255
    4efa:	48 81       	ld	r20, Y
    4efc:	59 81       	ldd	r21, Y+1	; 0x01
    4efe:	24 97       	sbiw	r28, 0x04	; 4
    4f00:	68 81       	ld	r22, Y
    4f02:	79 81       	ldd	r23, Y+1	; 0x01
    4f04:	c6 57       	subi	r28, 0x76	; 118
    4f06:	d0 40       	sbci	r29, 0x00	; 0
    4f08:	ce 01       	movw	r24, r28
    4f0a:	46 96       	adiw	r24, 0x16	; 22
    4f0c:	0e 94 00 22 	call	0x4400	; 0x4400 <psock_send_P>
    4f10:	88 23       	and	r24, r24
    4f12:	a9 f1       	breq	.+106    	; 0x4f7e <handle_connection+0x436>
  
  PSOCK_END(&s->sout);
    4f14:	1f 8a       	std	Y+23, r1	; 0x17
    4f16:	1e 8a       	std	Y+22, r1	; 0x16
					s->len = uip_mss();
				}
      }
			//uart_puts_P(PSTR("\n\r\x1B[1msend ???\x1B[0m"));
      PT_WAIT_THREAD(&s->scriptpt, send_part_of_file(s));
      s->file.data += s->len;
    4f18:	fe 01       	movw	r30, r28
    4f1a:	ea 58       	subi	r30, 0x8A	; 138
    4f1c:	ff 4f       	sbci	r31, 0xFF	; 255
    4f1e:	c6 58       	subi	r28, 0x86	; 134
    4f20:	df 4f       	sbci	r29, 0xFF	; 255
    4f22:	80 81       	ld	r24, Z
    4f24:	91 81       	ldd	r25, Z+1	; 0x01
    4f26:	28 81       	ld	r18, Y
    4f28:	39 81       	ldd	r19, Y+1	; 0x01
    4f2a:	ca 57       	subi	r28, 0x7A	; 122
    4f2c:	d0 40       	sbci	r29, 0x00	; 0
    4f2e:	82 0f       	add	r24, r18
    4f30:	93 1f       	adc	r25, r19
    4f32:	91 83       	std	Z+1, r25	; 0x01
    4f34:	80 83       	st	Z, r24
      s->file.len -= s->len;
    4f36:	fe 01       	movw	r30, r28
    4f38:	e8 58       	subi	r30, 0x88	; 136
    4f3a:	ff 4f       	sbci	r31, 0xFF	; 255
    4f3c:	80 81       	ld	r24, Z
    4f3e:	91 81       	ldd	r25, Z+1	; 0x01
    4f40:	82 1b       	sub	r24, r18
    4f42:	93 0b       	sbc	r25, r19
    4f44:	91 83       	std	Z+1, r25	; 0x01
    4f46:	80 83       	st	Z, r24
PT_THREAD(handle_script(struct httpd_state *s))
{
  char *ptr;
	PT_BEGIN(&s->scriptpt);
	//uart_puts_P(PSTR("\r\nSCRIPT"));
	while(s->file.len > 0) {
    4f48:	c8 58       	subi	r28, 0x88	; 136
    4f4a:	df 4f       	sbci	r29, 0xFF	; 255
    4f4c:	28 81       	ld	r18, Y
    4f4e:	39 81       	ldd	r19, Y+1	; 0x01
    4f50:	c8 57       	subi	r28, 0x78	; 120
    4f52:	d0 40       	sbci	r29, 0x00	; 0
    4f54:	12 16       	cp	r1, r18
    4f56:	13 06       	cpc	r1, r19
    4f58:	0c f4       	brge	.+2      	; 0x4f5c <handle_connection+0x414>
    4f5a:	15 cf       	rjmp	.-470    	; 0x4d86 <handle_connection+0x23e>
      s->file.data += s->len;
      s->file.len -= s->len;
    }
  }
  
  PT_END(&s->scriptpt);
    4f5c:	1e a6       	std	Y+46, r1	; 0x2e
    4f5e:	1d a6       	std	Y+45, r1	; 0x2d
    4f60:	09 c0       	rjmp	.+18     	; 0x4f74 <handle_connection+0x42c>
    ptr = strchr(s->filename, ISO_period);
    if(ptr != NULL && strncmp_P(ptr, http_shtml, 6) == 0) {
      PT_INIT(&s->scriptpt);
      PT_WAIT_THREAD(&s->outputpt, handle_script(s));
    } else {
      PT_WAIT_THREAD(&s->outputpt,send_file(s));
    4f62:	88 e0       	ldi	r24, 0x08	; 8
    4f64:	91 e0       	ldi	r25, 0x01	; 1
    4f66:	9c a7       	std	Y+44, r25	; 0x2c
    4f68:	8b a7       	std	Y+43, r24	; 0x2b
    4f6a:	ce 01       	movw	r24, r28
    4f6c:	0e 94 67 25 	call	0x4ace	; 0x4ace <send_file>
    4f70:	88 23       	and	r24, r24
    4f72:	29 f0       	breq	.+10     	; 0x4f7e <handle_connection+0x436>
    }
  }
  PSOCK_CLOSE(&s->sout);
    4f74:	80 e1       	ldi	r24, 0x10	; 16
    4f76:	80 93 3f 04 	sts	0x043F, r24
  PT_END(&s->outputpt);
    4f7a:	1c a6       	std	Y+44, r1	; 0x2c
    4f7c:	1b a6       	std	Y+43, r1	; 0x2b
    4f7e:	df 91       	pop	r29
    4f80:	cf 91       	pop	r28
    4f82:	1f 91       	pop	r17
    4f84:	0f 91       	pop	r16
    4f86:	ff 90       	pop	r15
    4f88:	ef 90       	pop	r14
    4f8a:	08 95       	ret

00004f8c <httpd_appcall>:
  }
}
/*---------------------------------------------------------------------------*/
void
httpd_appcall(void)
{
    4f8c:	ef 92       	push	r14
    4f8e:	ff 92       	push	r15
    4f90:	0f 93       	push	r16
    4f92:	1f 93       	push	r17
    4f94:	cf 93       	push	r28
    4f96:	df 93       	push	r29
  struct httpd_state *s = (struct httpd_state *)&(uip_conn->appstate);
    4f98:	c0 91 42 04 	lds	r28, 0x0442
    4f9c:	d0 91 43 04 	lds	r29, 0x0443

	//uart_puts_P(PSTR("\n\r\x1B[1mAppcall\x1B[0m"));
	
  if(uip_closed() || uip_aborted() || uip_timedout()) {
    4fa0:	20 91 3f 04 	lds	r18, 0x043F
    4fa4:	24 fd       	sbrc	r18, 4
    4fa6:	3c c0       	rjmp	.+120    	; 0x5020 <httpd_appcall+0x94>
    4fa8:	25 fd       	sbrc	r18, 5
    4faa:	3a c0       	rjmp	.+116    	; 0x5020 <httpd_appcall+0x94>
    4fac:	27 fd       	sbrc	r18, 7
    4fae:	38 c0       	rjmp	.+112    	; 0x5020 <httpd_appcall+0x94>
}
/*---------------------------------------------------------------------------*/
void
httpd_appcall(void)
{
  struct httpd_state *s = (struct httpd_state *)&(uip_conn->appstate);
    4fb0:	3c e1       	ldi	r19, 0x1C	; 28
    4fb2:	e3 2e       	mov	r14, r19
    4fb4:	f1 2c       	mov	r15, r1
    4fb6:	ec 0e       	add	r14, r28
    4fb8:	fd 1e       	adc	r15, r29

	//uart_puts_P(PSTR("\n\r\x1B[1mAppcall\x1B[0m"));
	
  if(uip_closed() || uip_aborted() || uip_timedout()) {
  } else if(uip_connected()) {
    4fba:	26 ff       	sbrs	r18, 6
    4fbc:	1b c0       	rjmp	.+54     	; 0x4ff4 <httpd_appcall+0x68>
    PSOCK_INIT(&s->sin, s->inputbuf, sizeof(s->inputbuf) - 1);
    4fbe:	8e 01       	movw	r16, r28
    4fc0:	05 5b       	subi	r16, 0xB5	; 181
    4fc2:	1f 4f       	sbci	r17, 0xFF	; 255
    4fc4:	41 e3       	ldi	r20, 0x31	; 49
    4fc6:	50 e0       	ldi	r21, 0x00	; 0
    4fc8:	b8 01       	movw	r22, r16
    4fca:	ce 01       	movw	r24, r28
    4fcc:	4d 96       	adiw	r24, 0x1d	; 29
    4fce:	0e 94 53 22 	call	0x44a6	; 0x44a6 <psock_init>
    PSOCK_INIT(&s->sout, s->inputbuf, sizeof(s->inputbuf) - 1);
    4fd2:	41 e3       	ldi	r20, 0x31	; 49
    4fd4:	50 e0       	ldi	r21, 0x00	; 0
    4fd6:	b8 01       	movw	r22, r16
    4fd8:	ce 01       	movw	r24, r28
    4fda:	c2 96       	adiw	r24, 0x32	; 50
    4fdc:	0e 94 53 22 	call	0x44a6	; 0x44a6 <psock_init>
    PT_INIT(&s->outputpt);
    4fe0:	c9 5b       	subi	r28, 0xB9	; 185
    4fe2:	df 4f       	sbci	r29, 0xFF	; 255
    4fe4:	19 82       	std	Y+1, r1	; 0x01
    4fe6:	18 82       	st	Y, r1
    s->state = STATE_WAITING;
    4fe8:	c6 5b       	subi	r28, 0xB6	; 182
    4fea:	df 4f       	sbci	r29, 0xFF	; 255
    4fec:	18 82       	st	Y, r1
    4fee:	c1 59       	subi	r28, 0x91	; 145
    4ff0:	d0 40       	sbci	r29, 0x00	; 0
    4ff2:	0e c0       	rjmp	.+28     	; 0x5010 <httpd_appcall+0x84>
    /*    timer_set(&s->ti3mer, CLOCK_SECOND * 100);*/
    s->timer = 0;
    handle_connection(s);
		} else if(s != NULL) {
    4ff4:	e1 14       	cp	r14, r1
    4ff6:	f1 04       	cpc	r15, r1
    4ff8:	81 f0       	breq	.+32     	; 0x501a <httpd_appcall+0x8e>
			if(uip_poll()) {
    4ffa:	23 ff       	sbrs	r18, 3
    4ffc:	09 c0       	rjmp	.+18     	; 0x5010 <httpd_appcall+0x84>
				++s->timer;
    4ffe:	8c 8d       	ldd	r24, Y+28	; 0x1c
    5000:	8f 5f       	subi	r24, 0xFF	; 255
    5002:	8c 8f       	std	Y+28, r24	; 0x1c
				if(s->timer >= 20) {
    5004:	84 31       	cpi	r24, 0x14	; 20
    5006:	28 f0       	brcs	.+10     	; 0x5012 <httpd_appcall+0x86>
					uip_abort();
    5008:	80 e2       	ldi	r24, 0x20	; 32
    500a:	80 93 3f 04 	sts	0x043F, r24
    500e:	01 c0       	rjmp	.+2      	; 0x5012 <httpd_appcall+0x86>
				}
			} else {
      s->timer = 0;
    5010:	1c 8e       	std	Y+28, r1	; 0x1c
    }
    handle_connection(s);
    5012:	c7 01       	movw	r24, r14
    5014:	0e 94 a4 25 	call	0x4b48	; 0x4b48 <handle_connection>
    5018:	03 c0       	rjmp	.+6      	; 0x5020 <httpd_appcall+0x94>
  } else {
    uip_abort();
    501a:	80 e2       	ldi	r24, 0x20	; 32
    501c:	80 93 3f 04 	sts	0x043F, r24
    5020:	df 91       	pop	r29
    5022:	cf 91       	pop	r28
    5024:	1f 91       	pop	r17
    5026:	0f 91       	pop	r16
    5028:	ff 90       	pop	r15
    502a:	ef 90       	pop	r14
    502c:	08 95       	ret

0000502e <generate_part_of_file>:


/*---------------------------------------------------------------------------*/
static unsigned short
generate_part_of_file(void *state)
{
    502e:	0f 93       	push	r16
    5030:	1f 93       	push	r17
    5032:	dc 01       	movw	r26, r24
  struct httpd_state *s = (struct httpd_state *)state;

  if(s->file.len > uip_mss()) {
    5034:	a8 58       	subi	r26, 0x88	; 136
    5036:	bf 4f       	sbci	r27, 0xFF	; 255
    5038:	2d 91       	ld	r18, X+
    503a:	3c 91       	ld	r19, X
    503c:	11 97       	sbiw	r26, 0x01	; 1
    503e:	a8 57       	subi	r26, 0x78	; 120
    5040:	b0 40       	sbci	r27, 0x00	; 0
    5042:	e0 91 42 04 	lds	r30, 0x0442
    5046:	f0 91 43 04 	lds	r31, 0x0443
    504a:	82 89       	ldd	r24, Z+18	; 0x12
    504c:	93 89       	ldd	r25, Z+19	; 0x13
    504e:	fd 01       	movw	r30, r26
    5050:	e6 58       	subi	r30, 0x86	; 134
    5052:	ff 4f       	sbci	r31, 0xFF	; 255
    5054:	82 17       	cp	r24, r18
    5056:	93 07       	cpc	r25, r19
    5058:	18 f4       	brcc	.+6      	; 0x5060 <generate_part_of_file+0x32>
    s->len = uip_mss();
    505a:	91 83       	std	Z+1, r25	; 0x01
    505c:	80 83       	st	Z, r24
    505e:	02 c0       	rjmp	.+4      	; 0x5064 <generate_part_of_file+0x36>
  } else {
    s->len = s->file.len;
    5060:	31 83       	std	Z+1, r19	; 0x01
    5062:	20 83       	st	Z, r18
  }
  memcpy_P(uip_appdata, s->file.data, s->len);
    5064:	8d 01       	movw	r16, r26
    5066:	06 58       	subi	r16, 0x86	; 134
    5068:	1f 4f       	sbci	r17, 0xFF	; 255
    506a:	f8 01       	movw	r30, r16
    506c:	40 81       	ld	r20, Z
    506e:	51 81       	ldd	r21, Z+1	; 0x01
    5070:	aa 58       	subi	r26, 0x8A	; 138
    5072:	bf 4f       	sbci	r27, 0xFF	; 255
    5074:	6d 91       	ld	r22, X+
    5076:	7c 91       	ld	r23, X
    5078:	80 91 40 04 	lds	r24, 0x0440
    507c:	90 91 41 04 	lds	r25, 0x0441
    5080:	0e 94 38 2c 	call	0x5870	; 0x5870 <memcpy_P>
			//uart_putc( ((unsigned char *)uip_appdata)[t]);
			uart_putc(((char*)uip_appdata)[t]);
	uart_puts_P(PSTR("<<<\r\n"));*/
  
  return s->len;
}
    5084:	f8 01       	movw	r30, r16
    5086:	80 81       	ld	r24, Z
    5088:	91 81       	ldd	r25, Z+1	; 0x01
    508a:	1f 91       	pop	r17
    508c:	0f 91       	pop	r16
    508e:	08 95       	ret

00005090 <httpd_fs_strcmp>:
#endif /* HTTPD_FS_STATISTICS */

/*-----------------------------------------------------------------------------------*/
static u8_t
httpd_fs_strcmp(const char *str1, const char *str2)
{
    5090:	40 e0       	ldi	r20, 0x00	; 0
    5092:	50 e0       	ldi	r21, 0x00	; 0
	// parameter2 = progmem
  u8_t i;
  i = 0;
 loop:

  if(pgm_read_byte(&str2[i]) == 0 ||
    5094:	a4 2f       	mov	r26, r20
    5096:	b0 e0       	ldi	r27, 0x00	; 0
    5098:	fb 01       	movw	r30, r22
    509a:	ea 0f       	add	r30, r26
    509c:	fb 1f       	adc	r31, r27
    509e:	34 91       	lpm	r19, Z
    50a0:	33 23       	and	r19, r19
    50a2:	71 f0       	breq	.+28     	; 0x50c0 <httpd_fs_strcmp+0x30>
    50a4:	a8 0f       	add	r26, r24
    50a6:	b9 1f       	adc	r27, r25
    50a8:	2c 91       	ld	r18, X
    50aa:	2d 30       	cpi	r18, 0x0D	; 13
    50ac:	49 f0       	breq	.+18     	; 0x50c0 <httpd_fs_strcmp+0x30>
    50ae:	2a 30       	cpi	r18, 0x0A	; 10
    50b0:	39 f0       	breq	.+14     	; 0x50c0 <httpd_fs_strcmp+0x30>
     str1[i] == '\r' ||
     str1[i] == '\n') {
    return 0;
  }

  if(str1[i] != pgm_read_byte(&str2[i])) {
    50b2:	4f 5f       	subi	r20, 0xFF	; 255
    50b4:	5f 4f       	sbci	r21, 0xFF	; 255
    50b6:	23 17       	cp	r18, r19
    50b8:	69 f3       	breq	.-38     	; 0x5094 <httpd_fs_strcmp+0x4>
    50ba:	81 e0       	ldi	r24, 0x01	; 1
    50bc:	90 e0       	ldi	r25, 0x00	; 0
    50be:	08 95       	ret
    50c0:	80 e0       	ldi	r24, 0x00	; 0
    50c2:	90 e0       	ldi	r25, 0x00	; 0
  }


  ++i;
  goto loop;
}
    50c4:	08 95       	ret

000050c6 <httpd_fs_open>:
  goto loop;
}
/*-----------------------------------------------------------------------------------*/
int
httpd_fs_open(const char *name, struct httpd_fs_file *file)
{
    50c6:	cf 92       	push	r12
    50c8:	df 92       	push	r13
    50ca:	ef 92       	push	r14
    50cc:	ff 92       	push	r15
    50ce:	0f 93       	push	r16
    50d0:	1f 93       	push	r17
    50d2:	cf 93       	push	r28
    50d4:	df 93       	push	r29
    50d6:	6c 01       	movw	r12, r24
    50d8:	7b 01       	movw	r14, r22
#if HTTPD_FS_STATISTICS
  u16_t i = 0;
#endif /* HTTPD_FS_STATISTICS */
  struct httpd_fsdata_file_noconst *f;

  for(f = (struct httpd_fsdata_file_noconst *)HTTPD_FS_ROOT;
    50da:	c7 e6       	ldi	r28, 0x67	; 103
    50dc:	d2 e0       	ldi	r29, 0x02	; 2
    50de:	00 e0       	ldi	r16, 0x00	; 0
    50e0:	10 e0       	ldi	r17, 0x00	; 0
    50e2:	22 c0       	rjmp	.+68     	; 0x5128 <httpd_fs_open+0x62>
      f != NULL;
      f = (struct httpd_fsdata_file_noconst *)f->next) {

    if(httpd_fs_strcmp(name, f->name) == 0) {
    50e4:	6a 81       	ldd	r22, Y+2	; 0x02
    50e6:	7b 81       	ldd	r23, Y+3	; 0x03
    50e8:	c6 01       	movw	r24, r12
    50ea:	0e 94 48 28 	call	0x5090	; 0x5090 <httpd_fs_strcmp>
    50ee:	88 23       	and	r24, r24
    50f0:	b1 f4       	brne	.+44     	; 0x511e <httpd_fs_open+0x58>
      file->data = f->data;  // f = progmem !
    50f2:	8c 81       	ldd	r24, Y+4	; 0x04
    50f4:	9d 81       	ldd	r25, Y+5	; 0x05
    50f6:	f7 01       	movw	r30, r14
    50f8:	91 83       	std	Z+1, r25	; 0x01
    50fa:	80 83       	st	Z, r24
      file->len = f->len;    // f = progmem !
    50fc:	8e 81       	ldd	r24, Y+6	; 0x06
    50fe:	9f 81       	ldd	r25, Y+7	; 0x07
    5100:	93 83       	std	Z+3, r25	; 0x03
    5102:	82 83       	std	Z+2, r24	; 0x02
#if HTTPD_FS_STATISTICS
      ++count[i];
    5104:	f8 01       	movw	r30, r16
    5106:	ee 0f       	add	r30, r30
    5108:	ff 1f       	adc	r31, r31
    510a:	ef 5d       	subi	r30, 0xDF	; 223
    510c:	fb 4f       	sbci	r31, 0xFB	; 251
    510e:	80 81       	ld	r24, Z
    5110:	91 81       	ldd	r25, Z+1	; 0x01
    5112:	01 96       	adiw	r24, 0x01	; 1
    5114:	91 83       	std	Z+1, r25	; 0x01
    5116:	80 83       	st	Z, r24
    5118:	81 e0       	ldi	r24, 0x01	; 1
    511a:	90 e0       	ldi	r25, 0x00	; 0
    511c:	09 c0       	rjmp	.+18     	; 0x5130 <httpd_fs_open+0x6a>
#endif /* HTTPD_FS_STATISTICS */
      return 1;
    }
#if HTTPD_FS_STATISTICS
    ++i;
    511e:	0f 5f       	subi	r16, 0xFF	; 255
    5120:	1f 4f       	sbci	r17, 0xFF	; 255
#endif /* HTTPD_FS_STATISTICS */
  struct httpd_fsdata_file_noconst *f;

  for(f = (struct httpd_fsdata_file_noconst *)HTTPD_FS_ROOT;
      f != NULL;
      f = (struct httpd_fsdata_file_noconst *)f->next) {
    5122:	09 90       	ld	r0, Y+
    5124:	d8 81       	ld	r29, Y
    5126:	c0 2d       	mov	r28, r0
  u16_t i = 0;
#endif /* HTTPD_FS_STATISTICS */
  struct httpd_fsdata_file_noconst *f;

  for(f = (struct httpd_fsdata_file_noconst *)HTTPD_FS_ROOT;
      f != NULL;
    5128:	20 97       	sbiw	r28, 0x00	; 0
    512a:	e1 f6       	brne	.-72     	; 0x50e4 <httpd_fs_open+0x1e>
    512c:	80 e0       	ldi	r24, 0x00	; 0
    512e:	90 e0       	ldi	r25, 0x00	; 0
    5130:	df 91       	pop	r29
    5132:	cf 91       	pop	r28
    5134:	1f 91       	pop	r17
    5136:	0f 91       	pop	r16
    5138:	ff 90       	pop	r15
    513a:	ef 90       	pop	r14
    513c:	df 90       	pop	r13
    513e:	cf 90       	pop	r12
    5140:	08 95       	ret

00005142 <httpd_fs_open_P>:
  return 0;
}
/*-----------------------------------------------------------------------------------*/
int
httpd_fs_open_P(const char *name, struct httpd_fs_file *file)
{
    5142:	ff 92       	push	r15
    5144:	0f 93       	push	r16
    5146:	1f 93       	push	r17
    5148:	cf 93       	push	r28
    514a:	df 93       	push	r29
    514c:	8c 01       	movw	r16, r24
    514e:	eb 01       	movw	r28, r22
  u16_t i = 0;
#endif /* HTTPD_FS_STATISTICS */
  struct httpd_fsdata_file_noconst *f;
	

  for(f = (struct httpd_fsdata_file_noconst *)HTTPD_FS_ROOT;
    5150:	a7 e6       	ldi	r26, 0x67	; 103
    5152:	b2 e0       	ldi	r27, 0x02	; 2
    5154:	60 e0       	ldi	r22, 0x00	; 0
    5156:	70 e0       	ldi	r23, 0x00	; 0
    5158:	35 c0       	rjmp	.+106    	; 0x51c4 <httpd_fs_open_P+0x82>
      f != NULL;
    515a:	fd 01       	movw	r30, r26
    515c:	82 81       	ldd	r24, Z+2	; 0x02
    515e:	93 81       	ldd	r25, Z+3	; 0x03
    5160:	40 e0       	ldi	r20, 0x00	; 0
    5162:	50 e0       	ldi	r21, 0x00	; 0
	// parameter2 = progmem
  u8_t i;
  i = 0;
 loop:

  if(pgm_read_byte(&str2[i]) == 0 ||
    5164:	24 2f       	mov	r18, r20
    5166:	30 e0       	ldi	r19, 0x00	; 0
    5168:	fc 01       	movw	r30, r24
    516a:	e2 0f       	add	r30, r18
    516c:	f3 1f       	adc	r31, r19
    516e:	f4 90       	lpm	r15, Z
    5170:	ff 20       	and	r15, r15
    5172:	69 f0       	breq	.+26     	; 0x518e <httpd_fs_open_P+0x4c>
     pgm_read_byte(&str1[i]) == '\r' ||
    5174:	20 0f       	add	r18, r16
    5176:	31 1f       	adc	r19, r17
    5178:	f9 01       	movw	r30, r18
    517a:	24 91       	lpm	r18, Z
	// parameter2 = progmem
  u8_t i;
  i = 0;
 loop:

  if(pgm_read_byte(&str2[i]) == 0 ||
    517c:	2d 30       	cpi	r18, 0x0D	; 13
    517e:	39 f0       	breq	.+14     	; 0x518e <httpd_fs_open_P+0x4c>
    5180:	2a 30       	cpi	r18, 0x0A	; 10
    5182:	29 f0       	breq	.+10     	; 0x518e <httpd_fs_open_P+0x4c>
     pgm_read_byte(&str1[i]) == '\r' ||
     pgm_read_byte(&str1[i]) == '\n') {
    return 0;
  }

  if(pgm_read_byte(&str1[i]) != pgm_read_byte(&str2[i])) {
    5184:	4f 5f       	subi	r20, 0xFF	; 255
    5186:	5f 4f       	sbci	r21, 0xFF	; 255
    5188:	2f 15       	cp	r18, r15
    518a:	b9 f4       	brne	.+46     	; 0x51ba <httpd_fs_open_P+0x78>
    518c:	eb cf       	rjmp	.-42     	; 0x5164 <httpd_fs_open_P+0x22>
  for(f = (struct httpd_fsdata_file_noconst *)HTTPD_FS_ROOT;
      f != NULL;
      f = (struct httpd_fsdata_file_noconst *)f->next) {

    if(httpd_fs_strcmp_P(name, f->name) == 0) {
      file->data = f->data;  // f->data = zeiger auf progmem 
    518e:	fd 01       	movw	r30, r26
    5190:	84 81       	ldd	r24, Z+4	; 0x04
    5192:	95 81       	ldd	r25, Z+5	; 0x05
    5194:	99 83       	std	Y+1, r25	; 0x01
    5196:	88 83       	st	Y, r24
      file->len = f->len;    // f->len = zeiger auf progmem 
    5198:	86 81       	ldd	r24, Z+6	; 0x06
    519a:	97 81       	ldd	r25, Z+7	; 0x07
    519c:	9b 83       	std	Y+3, r25	; 0x03
    519e:	8a 83       	std	Y+2, r24	; 0x02
#if HTTPD_FS_STATISTICS
      ++count[i];
    51a0:	fb 01       	movw	r30, r22
    51a2:	ee 0f       	add	r30, r30
    51a4:	ff 1f       	adc	r31, r31
    51a6:	ef 5d       	subi	r30, 0xDF	; 223
    51a8:	fb 4f       	sbci	r31, 0xFB	; 251
    51aa:	80 81       	ld	r24, Z
    51ac:	91 81       	ldd	r25, Z+1	; 0x01
    51ae:	01 96       	adiw	r24, 0x01	; 1
    51b0:	91 83       	std	Z+1, r25	; 0x01
    51b2:	80 83       	st	Z, r24
    51b4:	81 e0       	ldi	r24, 0x01	; 1
    51b6:	90 e0       	ldi	r25, 0x00	; 0
    51b8:	09 c0       	rjmp	.+18     	; 0x51cc <httpd_fs_open_P+0x8a>
#endif /* HTTPD_FS_STATISTICS */
      return 1;
    }
#if HTTPD_FS_STATISTICS
    ++i;
    51ba:	6f 5f       	subi	r22, 0xFF	; 255
    51bc:	7f 4f       	sbci	r23, 0xFF	; 255
  struct httpd_fsdata_file_noconst *f;
	

  for(f = (struct httpd_fsdata_file_noconst *)HTTPD_FS_ROOT;
      f != NULL;
      f = (struct httpd_fsdata_file_noconst *)f->next) {
    51be:	0d 90       	ld	r0, X+
    51c0:	bc 91       	ld	r27, X
    51c2:	a0 2d       	mov	r26, r0
#endif /* HTTPD_FS_STATISTICS */
  struct httpd_fsdata_file_noconst *f;
	

  for(f = (struct httpd_fsdata_file_noconst *)HTTPD_FS_ROOT;
      f != NULL;
    51c4:	10 97       	sbiw	r26, 0x00	; 0
    51c6:	49 f6       	brne	.-110    	; 0x515a <httpd_fs_open_P+0x18>
    51c8:	80 e0       	ldi	r24, 0x00	; 0
    51ca:	90 e0       	ldi	r25, 0x00	; 0
    51cc:	df 91       	pop	r29
    51ce:	cf 91       	pop	r28
    51d0:	1f 91       	pop	r17
    51d2:	0f 91       	pop	r16
    51d4:	ff 90       	pop	r15
    51d6:	08 95       	ret

000051d8 <httpd_fs_init>:
}
/*-----------------------------------------------------------------------------------*/

void
httpd_fs_init(void)
{
    51d8:	e1 e2       	ldi	r30, 0x21	; 33
    51da:	f4 e0       	ldi	r31, 0x04	; 4
#if HTTPD_FS_STATISTICS
  u16_t i;
  for(i = 0; i < HTTPD_FS_NUMFILES; i++) {
    count[i] = 0;
    51dc:	11 92       	st	Z+, r1
    51de:	11 92       	st	Z+, r1
void
httpd_fs_init(void)
{
#if HTTPD_FS_STATISTICS
  u16_t i;
  for(i = 0; i < HTTPD_FS_NUMFILES; i++) {
    51e0:	84 e0       	ldi	r24, 0x04	; 4
    51e2:	e5 33       	cpi	r30, 0x35	; 53
    51e4:	f8 07       	cpc	r31, r24
    51e6:	d1 f7       	brne	.-12     	; 0x51dc <httpd_fs_init+0x4>
    51e8:	08 95       	ret

000051ea <httpd_fs_count>:
}
/*-----------------------------------------------------------------------------------*/
#if HTTPD_FS_STATISTICS
u16_t httpd_fs_count
(char *name)
{
    51ea:	ef 92       	push	r14
    51ec:	ff 92       	push	r15
    51ee:	0f 93       	push	r16
    51f0:	1f 93       	push	r17
    51f2:	cf 93       	push	r28
    51f4:	df 93       	push	r29
    51f6:	7c 01       	movw	r14, r24
  struct httpd_fsdata_file_noconst *f; 
  u16_t i;
// f = progmem
  i = 0;
  for(f = (struct httpd_fsdata_file_noconst *)HTTPD_FS_ROOT;
    51f8:	07 e6       	ldi	r16, 0x67	; 103
    51fa:	12 e0       	ldi	r17, 0x02	; 2
    51fc:	c0 e0       	ldi	r28, 0x00	; 0
    51fe:	d0 e0       	ldi	r29, 0x00	; 0
    5200:	13 c0       	rjmp	.+38     	; 0x5228 <httpd_fs_count+0x3e>
      f != NULL;
      f = (struct httpd_fsdata_file_noconst *)f->next) {

    if(httpd_fs_strcmp(name, f->name) == 0) {
    5202:	f8 01       	movw	r30, r16
    5204:	62 81       	ldd	r22, Z+2	; 0x02
    5206:	73 81       	ldd	r23, Z+3	; 0x03
    5208:	c7 01       	movw	r24, r14
    520a:	0e 94 48 28 	call	0x5090	; 0x5090 <httpd_fs_strcmp>
    520e:	88 23       	and	r24, r24
    5210:	39 f4       	brne	.+14     	; 0x5220 <httpd_fs_count+0x36>
      return count[i];
    5212:	cc 0f       	add	r28, r28
    5214:	dd 1f       	adc	r29, r29
    5216:	cf 5d       	subi	r28, 0xDF	; 223
    5218:	db 4f       	sbci	r29, 0xFB	; 251
    521a:	88 81       	ld	r24, Y
    521c:	99 81       	ldd	r25, Y+1	; 0x01
    521e:	09 c0       	rjmp	.+18     	; 0x5232 <httpd_fs_count+0x48>
    }
    ++i;
    5220:	21 96       	adiw	r28, 0x01	; 1
  u16_t i;
// f = progmem
  i = 0;
  for(f = (struct httpd_fsdata_file_noconst *)HTTPD_FS_ROOT;
      f != NULL;
      f = (struct httpd_fsdata_file_noconst *)f->next) {
    5222:	f8 01       	movw	r30, r16
    5224:	00 81       	ld	r16, Z
    5226:	11 81       	ldd	r17, Z+1	; 0x01
  struct httpd_fsdata_file_noconst *f; 
  u16_t i;
// f = progmem
  i = 0;
  for(f = (struct httpd_fsdata_file_noconst *)HTTPD_FS_ROOT;
      f != NULL;
    5228:	01 15       	cp	r16, r1
    522a:	11 05       	cpc	r17, r1
    522c:	51 f7       	brne	.-44     	; 0x5202 <httpd_fs_count+0x18>
    522e:	80 e0       	ldi	r24, 0x00	; 0
    5230:	90 e0       	ldi	r25, 0x00	; 0
    5232:	df 91       	pop	r29
    5234:	cf 91       	pop	r28
    5236:	1f 91       	pop	r17
    5238:	0f 91       	pop	r16
    523a:	ff 90       	pop	r15
    523c:	ef 90       	pop	r14
    523e:	08 95       	ret

00005240 <nullfunction>:
static const struct httpd_cgi_call *calls[] = { &file, &tcp, &net, NULL };

/*---------------------------------------------------------------------------*/
static
PT_THREAD(nullfunction(struct httpd_state *s, char *ptr))
{
    5240:	fc 01       	movw	r30, r24
    5242:	17 8a       	std	Z+23, r1	; 0x17
    5244:	16 8a       	std	Z+22, r1	; 0x16
  PSOCK_BEGIN(&s->sout);
  PSOCK_END(&s->sout);
}
    5246:	82 e0       	ldi	r24, 0x02	; 2
    5248:	90 e0       	ldi	r25, 0x00	; 0
    524a:	08 95       	ret

0000524c <httpd_cgi>:
/*---------------------------------------------------------------------------*/
httpd_cgifunction
httpd_cgi(char *name)
{
    524c:	ef 92       	push	r14
    524e:	ff 92       	push	r15
    5250:	0f 93       	push	r16
    5252:	1f 93       	push	r17
    5254:	cf 93       	push	r28
    5256:	df 93       	push	r29
    5258:	7c 01       	movw	r14, r24
    525a:	07 ed       	ldi	r16, 0xD7	; 215
    525c:	12 e0       	ldi	r17, 0x02	; 2
    525e:	15 c0       	rjmp	.+42     	; 0x528a <httpd_cgi+0x3e>
  const struct httpd_cgi_call **f;


  /* Find the matching name in the table, return the function. */
  for(f = calls; *f != NULL; ++f) {
    if(strncmp_P((*f)->name, name, strlen((*f)->name)) == 0) {
    5260:	a8 81       	ld	r26, Y
    5262:	b9 81       	ldd	r27, Y+1	; 0x01
    5264:	fd 01       	movw	r30, r26
    5266:	01 90       	ld	r0, Z+
    5268:	00 20       	and	r0, r0
    526a:	e9 f7       	brne	.-6      	; 0x5266 <httpd_cgi+0x1a>
    526c:	31 97       	sbiw	r30, 0x01	; 1
    526e:	ea 1b       	sub	r30, r26
    5270:	fb 0b       	sbc	r31, r27
    5272:	af 01       	movw	r20, r30
    5274:	b7 01       	movw	r22, r14
    5276:	cd 01       	movw	r24, r26
    5278:	0e 94 65 2c 	call	0x58ca	; 0x58ca <strncmp_P>
    527c:	89 2b       	or	r24, r25
    527e:	19 f4       	brne	.+6      	; 0x5286 <httpd_cgi+0x3a>
      return (*f)->function;
    5280:	8a 81       	ldd	r24, Y+2	; 0x02
    5282:	9b 81       	ldd	r25, Y+3	; 0x03
    5284:	09 c0       	rjmp	.+18     	; 0x5298 <httpd_cgi+0x4c>
{
  const struct httpd_cgi_call **f;


  /* Find the matching name in the table, return the function. */
  for(f = calls; *f != NULL; ++f) {
    5286:	0e 5f       	subi	r16, 0xFE	; 254
    5288:	1f 4f       	sbci	r17, 0xFF	; 255
    528a:	f8 01       	movw	r30, r16
    528c:	c0 81       	ld	r28, Z
    528e:	d1 81       	ldd	r29, Z+1	; 0x01
    5290:	20 97       	sbiw	r28, 0x00	; 0
    5292:	31 f7       	brne	.-52     	; 0x5260 <httpd_cgi+0x14>
    5294:	80 e2       	ldi	r24, 0x20	; 32
    5296:	99 e2       	ldi	r25, 0x29	; 41
    5298:	df 91       	pop	r29
    529a:	cf 91       	pop	r28
    529c:	1f 91       	pop	r17
    529e:	0f 91       	pop	r16
    52a0:	ff 90       	pop	r15
    52a2:	ef 90       	pop	r14
    52a4:	08 95       	ret

000052a6 <net_stats>:
		  "%5u\n", ((uip_stats_t *)&uip_stat)[s->count]);
}

static
PT_THREAD(net_stats(struct httpd_state *s, char *ptr))
{
    52a6:	cf 93       	push	r28
    52a8:	df 93       	push	r29
    52aa:	ec 01       	movw	r28, r24
  PSOCK_BEGIN(&s->sout);
    52ac:	8e 89       	ldd	r24, Y+22	; 0x16
    52ae:	9f 89       	ldd	r25, Y+23	; 0x17
    52b0:	00 97       	sbiw	r24, 0x00	; 0
    52b2:	21 f0       	breq	.+8      	; 0x52bc <net_stats+0x16>
    52b4:	84 3c       	cpi	r24, 0xC4	; 196
    52b6:	91 05       	cpc	r25, r1
    52b8:	41 f5       	brne	.+80     	; 0x530a <net_stats+0x64>
    52ba:	0b c0       	rjmp	.+22     	; 0x52d2 <net_stats+0x2c>

#if UIP_STATISTICS

  for(s->count = 0; s->count < sizeof(uip_stat) / sizeof(uip_stats_t);
    52bc:	c0 58       	subi	r28, 0x80	; 128
    52be:	df 4f       	sbci	r29, 0xFF	; 255
    52c0:	19 82       	std	Y+1, r1	; 0x01
    52c2:	18 82       	st	Y, r1
    52c4:	c0 58       	subi	r28, 0x80	; 128
    52c6:	d0 40       	sbci	r29, 0x00	; 0
    52c8:	18 c0       	rjmp	.+48     	; 0x52fa <net_stats+0x54>
      ++s->count) {
    PSOCK_GENERATOR_SEND(&s->sout, generate_net_stats, s);
    52ca:	84 ec       	ldi	r24, 0xC4	; 196
    52cc:	90 e0       	ldi	r25, 0x00	; 0
    52ce:	9f 8b       	std	Y+23, r25	; 0x17
    52d0:	8e 8b       	std	Y+22, r24	; 0x16
    52d2:	ae 01       	movw	r20, r28
    52d4:	68 ed       	ldi	r22, 0xD8	; 216
    52d6:	79 e2       	ldi	r23, 0x29	; 41
    52d8:	ce 01       	movw	r24, r28
    52da:	46 96       	adiw	r24, 0x16	; 22
    52dc:	0e 94 7b 21 	call	0x42f6	; 0x42f6 <psock_generator_send>
    52e0:	88 23       	and	r24, r24
    52e2:	19 f4       	brne	.+6      	; 0x52ea <net_stats+0x44>
    52e4:	80 e0       	ldi	r24, 0x00	; 0
    52e6:	90 e0       	ldi	r25, 0x00	; 0
    52e8:	14 c0       	rjmp	.+40     	; 0x5312 <net_stats+0x6c>
  PSOCK_BEGIN(&s->sout);

#if UIP_STATISTICS

  for(s->count = 0; s->count < sizeof(uip_stat) / sizeof(uip_stats_t);
      ++s->count) {
    52ea:	fe 01       	movw	r30, r28
    52ec:	e0 58       	subi	r30, 0x80	; 128
    52ee:	ff 4f       	sbci	r31, 0xFF	; 255
    52f0:	80 81       	ld	r24, Z
    52f2:	91 81       	ldd	r25, Z+1	; 0x01
    52f4:	01 96       	adiw	r24, 0x01	; 1
    52f6:	91 83       	std	Z+1, r25	; 0x01
    52f8:	80 83       	st	Z, r24
{
  PSOCK_BEGIN(&s->sout);

#if UIP_STATISTICS

  for(s->count = 0; s->count < sizeof(uip_stat) / sizeof(uip_stats_t);
    52fa:	c0 58       	subi	r28, 0x80	; 128
    52fc:	df 4f       	sbci	r29, 0xFF	; 255
    52fe:	88 81       	ld	r24, Y
    5300:	99 81       	ldd	r25, Y+1	; 0x01
    5302:	c0 58       	subi	r28, 0x80	; 128
    5304:	d0 40       	sbci	r29, 0x00	; 0
    5306:	46 97       	sbiw	r24, 0x16	; 22
    5308:	00 f3       	brcs	.-64     	; 0x52ca <net_stats+0x24>
    PSOCK_GENERATOR_SEND(&s->sout, generate_net_stats, s);
  }
  
#endif /* UIP_STATISTICS */
  
  PSOCK_END(&s->sout);
    530a:	1f 8a       	std	Y+23, r1	; 0x17
    530c:	1e 8a       	std	Y+22, r1	; 0x16
    530e:	82 e0       	ldi	r24, 0x02	; 2
    5310:	90 e0       	ldi	r25, 0x00	; 0
    5312:	df 91       	pop	r29
    5314:	cf 91       	pop	r28
    5316:	08 95       	ret

00005318 <tcp_stats>:
		 (uip_stopped(conn))? '!':' ');
}
/*---------------------------------------------------------------------------*/
static
PT_THREAD(tcp_stats(struct httpd_state *s, char *ptr))
{
    5318:	cf 93       	push	r28
    531a:	df 93       	push	r29
    531c:	ec 01       	movw	r28, r24
  
  PSOCK_BEGIN(&s->sout);
    531e:	8e 89       	ldd	r24, Y+22	; 0x16
    5320:	9f 89       	ldd	r25, Y+23	; 0x17
    5322:	00 97       	sbiw	r24, 0x00	; 0
    5324:	21 f0       	breq	.+8      	; 0x532e <tcp_stats+0x16>
    5326:	8c 3a       	cpi	r24, 0xAC	; 172
    5328:	91 05       	cpc	r25, r1
    532a:	d9 f5       	brne	.+118    	; 0x53a2 <tcp_stats+0x8a>
    532c:	1d c0       	rjmp	.+58     	; 0x5368 <tcp_stats+0x50>

  for(s->count = 0; s->count < UIP_CONNS; ++s->count) {
    532e:	c0 58       	subi	r28, 0x80	; 128
    5330:	df 4f       	sbci	r29, 0xFF	; 255
    5332:	19 82       	std	Y+1, r1	; 0x01
    5334:	18 82       	st	Y, r1
    5336:	c0 58       	subi	r28, 0x80	; 128
    5338:	d0 40       	sbci	r29, 0x00	; 0
    533a:	2a c0       	rjmp	.+84     	; 0x5390 <tcp_stats+0x78>
    if((uip_conns[s->count].tcpstateflags & UIP_TS_MASK) != UIP_CLOSED) {
    533c:	8e e9       	ldi	r24, 0x9E	; 158
    533e:	90 e0       	ldi	r25, 0x00	; 0
    5340:	9f 01       	movw	r18, r30
    5342:	28 9f       	mul	r18, r24
    5344:	f0 01       	movw	r30, r0
    5346:	29 9f       	mul	r18, r25
    5348:	f0 0d       	add	r31, r0
    534a:	38 9f       	mul	r19, r24
    534c:	f0 0d       	add	r31, r0
    534e:	11 24       	eor	r1, r1
    5350:	ec 5b       	subi	r30, 0xBC	; 188
    5352:	fb 4f       	sbci	r31, 0xFB	; 251
    5354:	81 8d       	ldd	r24, Z+25	; 0x19
    5356:	90 e0       	ldi	r25, 0x00	; 0
    5358:	8f 70       	andi	r24, 0x0F	; 15
    535a:	90 70       	andi	r25, 0x00	; 0
    535c:	89 2b       	or	r24, r25
    535e:	81 f0       	breq	.+32     	; 0x5380 <tcp_stats+0x68>
      PSOCK_GENERATOR_SEND(&s->sout, generate_tcp_stats, s);
    5360:	8c ea       	ldi	r24, 0xAC	; 172
    5362:	90 e0       	ldi	r25, 0x00	; 0
    5364:	9f 8b       	std	Y+23, r25	; 0x17
    5366:	8e 8b       	std	Y+22, r24	; 0x16
    5368:	ae 01       	movw	r20, r28
    536a:	60 e0       	ldi	r22, 0x00	; 0
    536c:	7a e2       	ldi	r23, 0x2A	; 42
    536e:	ce 01       	movw	r24, r28
    5370:	46 96       	adiw	r24, 0x16	; 22
    5372:	0e 94 7b 21 	call	0x42f6	; 0x42f6 <psock_generator_send>
    5376:	88 23       	and	r24, r24
    5378:	19 f4       	brne	.+6      	; 0x5380 <tcp_stats+0x68>
    537a:	80 e0       	ldi	r24, 0x00	; 0
    537c:	90 e0       	ldi	r25, 0x00	; 0
    537e:	15 c0       	rjmp	.+42     	; 0x53aa <tcp_stats+0x92>
PT_THREAD(tcp_stats(struct httpd_state *s, char *ptr))
{
  
  PSOCK_BEGIN(&s->sout);

  for(s->count = 0; s->count < UIP_CONNS; ++s->count) {
    5380:	fe 01       	movw	r30, r28
    5382:	e0 58       	subi	r30, 0x80	; 128
    5384:	ff 4f       	sbci	r31, 0xFF	; 255
    5386:	80 81       	ld	r24, Z
    5388:	91 81       	ldd	r25, Z+1	; 0x01
    538a:	01 96       	adiw	r24, 0x01	; 1
    538c:	91 83       	std	Z+1, r25	; 0x01
    538e:	80 83       	st	Z, r24
    5390:	c0 58       	subi	r28, 0x80	; 128
    5392:	df 4f       	sbci	r29, 0xFF	; 255
    5394:	e8 81       	ld	r30, Y
    5396:	f9 81       	ldd	r31, Y+1	; 0x01
    5398:	c0 58       	subi	r28, 0x80	; 128
    539a:	d0 40       	sbci	r29, 0x00	; 0
    539c:	e2 30       	cpi	r30, 0x02	; 2
    539e:	f1 05       	cpc	r31, r1
    53a0:	68 f2       	brcs	.-102    	; 0x533c <tcp_stats+0x24>
    if((uip_conns[s->count].tcpstateflags & UIP_TS_MASK) != UIP_CLOSED) {
      PSOCK_GENERATOR_SEND(&s->sout, generate_tcp_stats, s);
    }
  }

  PSOCK_END(&s->sout);
    53a2:	1f 8a       	std	Y+23, r1	; 0x17
    53a4:	1e 8a       	std	Y+22, r1	; 0x16
    53a6:	82 e0       	ldi	r24, 0x02	; 2
    53a8:	90 e0       	ldi	r25, 0x00	; 0
    53aa:	df 91       	pop	r29
    53ac:	cf 91       	pop	r28
    53ae:	08 95       	ret

000053b0 <generate_net_stats>:
}
/*---------------------------------------------------------------------------*/
static unsigned short
generate_net_stats(void *arg)
{
    53b0:	fc 01       	movw	r30, r24
    53b2:	e0 58       	subi	r30, 0x80	; 128
    53b4:	ff 4f       	sbci	r31, 0xFF	; 255
    53b6:	01 90       	ld	r0, Z+
    53b8:	f0 81       	ld	r31, Z
    53ba:	e0 2d       	mov	r30, r0
    53bc:	ee 0f       	add	r30, r30
    53be:	ff 1f       	adc	r31, r31
    53c0:	e8 57       	subi	r30, 0x78	; 120
    53c2:	fa 4f       	sbci	r31, 0xFA	; 250
    53c4:	80 81       	ld	r24, Z
    53c6:	91 81       	ldd	r25, Z+1	; 0x01
    53c8:	9f 93       	push	r25
    53ca:	8f 93       	push	r24
    53cc:	81 e7       	ldi	r24, 0x71	; 113
    53ce:	92 e0       	ldi	r25, 0x02	; 2
    53d0:	9f 93       	push	r25
    53d2:	8f 93       	push	r24
    53d4:	86 ea       	ldi	r24, 0xA6	; 166
    53d6:	95 e0       	ldi	r25, 0x05	; 5
    53d8:	9f 93       	push	r25
    53da:	8f 93       	push	r24
    53dc:	80 91 40 04 	lds	r24, 0x0440
    53e0:	90 91 41 04 	lds	r25, 0x0441
    53e4:	9f 93       	push	r25
    53e6:	8f 93       	push	r24
    53e8:	0e 94 ea 2c 	call	0x59d4	; 0x59d4 <snprintf>
    53ec:	2d b7       	in	r18, 0x3d	; 61
    53ee:	3e b7       	in	r19, 0x3e	; 62
    53f0:	28 5f       	subi	r18, 0xF8	; 248
    53f2:	3f 4f       	sbci	r19, 0xFF	; 255
    53f4:	0f b6       	in	r0, 0x3f	; 63
    53f6:	f8 94       	cli
    53f8:	3e bf       	out	0x3e, r19	; 62
    53fa:	0f be       	out	0x3f, r0	; 63
    53fc:	2d bf       	out	0x3d, r18	; 61
    53fe:	08 95       	ret

00005400 <generate_tcp_stats>:
  last_ack};
  

static unsigned short
generate_tcp_stats(void *arg)
{
    5400:	2f 92       	push	r2
    5402:	3f 92       	push	r3
    5404:	4f 92       	push	r4
    5406:	5f 92       	push	r5
    5408:	6f 92       	push	r6
    540a:	7f 92       	push	r7
    540c:	8f 92       	push	r8
    540e:	9f 92       	push	r9
    5410:	af 92       	push	r10
    5412:	bf 92       	push	r11
    5414:	cf 92       	push	r12
    5416:	df 92       	push	r13
    5418:	ef 92       	push	r14
    541a:	ff 92       	push	r15
    541c:	0f 93       	push	r16
    541e:	1f 93       	push	r17
    5420:	cf 93       	push	r28
    5422:	df 93       	push	r29
    5424:	cd b7       	in	r28, 0x3d	; 61
    5426:	de b7       	in	r29, 0x3e	; 62
    5428:	26 97       	sbiw	r28, 0x06	; 6
    542a:	0f b6       	in	r0, 0x3f	; 63
    542c:	f8 94       	cli
    542e:	de bf       	out	0x3e, r29	; 62
    5430:	0f be       	out	0x3f, r0	; 63
    5432:	cd bf       	out	0x3d, r28	; 61
  struct uip_conn *conn;
  struct httpd_state *s = (struct httpd_state *)arg;
  conn = &uip_conns[s->count]; 
    5434:	fc 01       	movw	r30, r24
    5436:	e0 58       	subi	r30, 0x80	; 128
    5438:	ff 4f       	sbci	r31, 0xFF	; 255
    543a:	20 81       	ld	r18, Z
    543c:	31 81       	ldd	r19, Z+1	; 0x01
    543e:	8e e9       	ldi	r24, 0x9E	; 158
    5440:	90 e0       	ldi	r25, 0x00	; 0
    5442:	28 9f       	mul	r18, r24
    5444:	a0 01       	movw	r20, r0
    5446:	29 9f       	mul	r18, r25
    5448:	50 0d       	add	r21, r0
    544a:	38 9f       	mul	r19, r24
    544c:	50 0d       	add	r21, r0
    544e:	11 24       	eor	r1, r1
    5450:	4c 5b       	subi	r20, 0xBC	; 188
    5452:	5b 4f       	sbci	r21, 0xFB	; 251
    5454:	5e 83       	std	Y+6, r21	; 0x06
    5456:	4d 83       	std	Y+5, r20	; 0x05
  return snprintf((char *)uip_appdata, UIP_APPDATA_SIZE,
    5458:	fa 01       	movw	r30, r20
    545a:	81 8d       	ldd	r24, Z+25	; 0x19
    545c:	a8 2f       	mov	r26, r24
    545e:	b0 e0       	ldi	r27, 0x00	; 0
    5460:	84 ff       	sbrs	r24, 4
    5462:	05 c0       	rjmp	.+10     	; 0x546e <generate_tcp_stats+0x6e>
    5464:	21 e2       	ldi	r18, 0x21	; 33
    5466:	30 e0       	ldi	r19, 0x00	; 0
    5468:	3c 83       	std	Y+4, r19	; 0x04
    546a:	2b 83       	std	Y+3, r18	; 0x03
    546c:	04 c0       	rjmp	.+8      	; 0x5476 <generate_tcp_stats+0x76>
    546e:	40 e2       	ldi	r20, 0x20	; 32
    5470:	50 e0       	ldi	r21, 0x00	; 0
    5472:	5c 83       	std	Y+4, r21	; 0x04
    5474:	4b 83       	std	Y+3, r20	; 0x03
    5476:	ed 81       	ldd	r30, Y+5	; 0x05
    5478:	fe 81       	ldd	r31, Y+6	; 0x06
    547a:	80 89       	ldd	r24, Z+16	; 0x10
    547c:	91 89       	ldd	r25, Z+17	; 0x11
    547e:	89 2b       	or	r24, r25
    5480:	29 f0       	breq	.+10     	; 0x548c <generate_tcp_stats+0x8c>
    5482:	2a e2       	ldi	r18, 0x2A	; 42
    5484:	30 e0       	ldi	r19, 0x00	; 0
    5486:	3a 83       	std	Y+2, r19	; 0x02
    5488:	29 83       	std	Y+1, r18	; 0x01
    548a:	04 c0       	rjmp	.+8      	; 0x5494 <generate_tcp_stats+0x94>
    548c:	40 e2       	ldi	r20, 0x20	; 32
    548e:	50 e0       	ldi	r21, 0x00	; 0
    5490:	5a 83       	std	Y+2, r21	; 0x02
    5492:	49 83       	std	Y+1, r20	; 0x01
    5494:	ed 81       	ldd	r30, Y+5	; 0x05
    5496:	fe 81       	ldd	r31, Y+6	; 0x06
    5498:	62 8c       	ldd	r6, Z+26	; 0x1a
    549a:	77 24       	eor	r7, r7
    549c:	83 8c       	ldd	r8, Z+27	; 0x1b
    549e:	99 24       	eor	r9, r9
    54a0:	af 70       	andi	r26, 0x0F	; 15
    54a2:	b0 70       	andi	r27, 0x00	; 0
    54a4:	aa 0f       	add	r26, r26
    54a6:	bb 1f       	adc	r27, r27
    54a8:	a1 52       	subi	r26, 0x21	; 33
    54aa:	bd 4f       	sbci	r27, 0xFD	; 253
    54ac:	2d 90       	ld	r2, X+
    54ae:	3c 90       	ld	r3, X
    54b0:	86 81       	ldd	r24, Z+6	; 0x06
    54b2:	97 81       	ldd	r25, Z+7	; 0x07
    54b4:	0e 94 ef 15 	call	0x2bde	; 0x2bde <htons>
    54b8:	2c 01       	movw	r4, r24
    54ba:	ed 81       	ldd	r30, Y+5	; 0x05
    54bc:	fe 81       	ldd	r31, Y+6	; 0x06
    54be:	82 81       	ldd	r24, Z+2	; 0x02
    54c0:	93 81       	ldd	r25, Z+3	; 0x03
    54c2:	0e 94 ef 15 	call	0x2bde	; 0x2bde <htons>
    54c6:	5c 01       	movw	r10, r24
    54c8:	ed 81       	ldd	r30, Y+5	; 0x05
    54ca:	fe 81       	ldd	r31, Y+6	; 0x06
    54cc:	82 81       	ldd	r24, Z+2	; 0x02
    54ce:	93 81       	ldd	r25, Z+3	; 0x03
    54d0:	0e 94 ef 15 	call	0x2bde	; 0x2bde <htons>
    54d4:	6c 01       	movw	r12, r24
    54d6:	ed 81       	ldd	r30, Y+5	; 0x05
    54d8:	fe 81       	ldd	r31, Y+6	; 0x06
    54da:	80 81       	ld	r24, Z
    54dc:	91 81       	ldd	r25, Z+1	; 0x01
    54de:	0e 94 ef 15 	call	0x2bde	; 0x2bde <htons>
    54e2:	7c 01       	movw	r14, r24
    54e4:	ed 81       	ldd	r30, Y+5	; 0x05
    54e6:	fe 81       	ldd	r31, Y+6	; 0x06
    54e8:	80 81       	ld	r24, Z
    54ea:	91 81       	ldd	r25, Z+1	; 0x01
    54ec:	0e 94 ef 15 	call	0x2bde	; 0x2bde <htons>
    54f0:	8c 01       	movw	r16, r24
    54f2:	ed 81       	ldd	r30, Y+5	; 0x05
    54f4:	fe 81       	ldd	r31, Y+6	; 0x06
    54f6:	84 81       	ldd	r24, Z+4	; 0x04
    54f8:	95 81       	ldd	r25, Z+5	; 0x05
    54fa:	0e 94 ef 15 	call	0x2bde	; 0x2bde <htons>
    54fe:	2b 81       	ldd	r18, Y+3	; 0x03
    5500:	3c 81       	ldd	r19, Y+4	; 0x04
    5502:	3f 93       	push	r19
    5504:	2f 93       	push	r18
    5506:	49 81       	ldd	r20, Y+1	; 0x01
    5508:	5a 81       	ldd	r21, Y+2	; 0x02
    550a:	5f 93       	push	r21
    550c:	4f 93       	push	r20
    550e:	7f 92       	push	r7
    5510:	6f 92       	push	r6
    5512:	9f 92       	push	r9
    5514:	8f 92       	push	r8
    5516:	3f 92       	push	r3
    5518:	2f 92       	push	r2
    551a:	5f 92       	push	r5
    551c:	4f 92       	push	r4
    551e:	5f ef       	ldi	r21, 0xFF	; 255
    5520:	a5 22       	and	r10, r21
    5522:	bb 24       	eor	r11, r11
    5524:	bf 92       	push	r11
    5526:	af 92       	push	r10
    5528:	cd 2c       	mov	r12, r13
    552a:	dd 24       	eor	r13, r13
    552c:	df 92       	push	r13
    552e:	cf 92       	push	r12
    5530:	ef ef       	ldi	r30, 0xFF	; 255
    5532:	ee 22       	and	r14, r30
    5534:	ff 24       	eor	r15, r15
    5536:	ff 92       	push	r15
    5538:	ef 92       	push	r14
    553a:	01 2f       	mov	r16, r17
    553c:	11 27       	eor	r17, r17
    553e:	1f 93       	push	r17
    5540:	0f 93       	push	r16
    5542:	9f 93       	push	r25
    5544:	8f 93       	push	r24
    5546:	86 e7       	ldi	r24, 0x76	; 118
    5548:	92 e0       	ldi	r25, 0x02	; 2
    554a:	9f 93       	push	r25
    554c:	8f 93       	push	r24
    554e:	86 ea       	ldi	r24, 0xA6	; 166
    5550:	95 e0       	ldi	r25, 0x05	; 5
    5552:	9f 93       	push	r25
    5554:	8f 93       	push	r24
    5556:	80 91 40 04 	lds	r24, 0x0440
    555a:	90 91 41 04 	lds	r25, 0x0441
    555e:	9f 93       	push	r25
    5560:	8f 93       	push	r24
    5562:	0e 94 ea 2c 	call	0x59d4	; 0x59d4 <snprintf>
    5566:	2d b7       	in	r18, 0x3d	; 61
    5568:	3e b7       	in	r19, 0x3e	; 62
    556a:	24 5e       	subi	r18, 0xE4	; 228
    556c:	3f 4f       	sbci	r19, 0xFF	; 255
    556e:	0f b6       	in	r0, 0x3f	; 63
    5570:	f8 94       	cli
    5572:	3e bf       	out	0x3e, r19	; 62
    5574:	0f be       	out	0x3f, r0	; 63
    5576:	2d bf       	out	0x3d, r18	; 61
    5578:	26 96       	adiw	r28, 0x06	; 6
    557a:	0f b6       	in	r0, 0x3f	; 63
    557c:	f8 94       	cli
    557e:	de bf       	out	0x3e, r29	; 62
    5580:	0f be       	out	0x3f, r0	; 63
    5582:	cd bf       	out	0x3d, r28	; 61
    5584:	df 91       	pop	r29
    5586:	cf 91       	pop	r28
    5588:	1f 91       	pop	r17
    558a:	0f 91       	pop	r16
    558c:	ff 90       	pop	r15
    558e:	ef 90       	pop	r14
    5590:	df 90       	pop	r13
    5592:	cf 90       	pop	r12
    5594:	bf 90       	pop	r11
    5596:	af 90       	pop	r10
    5598:	9f 90       	pop	r9
    559a:	8f 90       	pop	r8
    559c:	7f 90       	pop	r7
    559e:	6f 90       	pop	r6
    55a0:	5f 90       	pop	r5
    55a2:	4f 90       	pop	r4
    55a4:	3f 90       	pop	r3
    55a6:	2f 90       	pop	r2
    55a8:	08 95       	ret

000055aa <file_stats>:
	return snprintf((char *)uip_appdata, UIP_APPDATA_SIZE, "%5u", httpd_fs_count(f));
}
/*---------------------------------------------------------------------------*/
static
PT_THREAD(file_stats(struct httpd_state *s, char *ptr))
{
    55aa:	cf 93       	push	r28
    55ac:	df 93       	push	r29
    55ae:	ec 01       	movw	r28, r24
    55b0:	9b 01       	movw	r18, r22
  PSOCK_BEGIN(&s->sout);
    55b2:	8e 89       	ldd	r24, Y+22	; 0x16
    55b4:	9f 89       	ldd	r25, Y+23	; 0x17
    55b6:	00 97       	sbiw	r24, 0x00	; 0
    55b8:	21 f0       	breq	.+8      	; 0x55c2 <file_stats+0x18>
    55ba:	83 36       	cpi	r24, 0x63	; 99
    55bc:	91 05       	cpc	r25, r1
    55be:	b9 f4       	brne	.+46     	; 0x55ee <file_stats+0x44>
    55c0:	04 c0       	rjmp	.+8      	; 0x55ca <file_stats+0x20>

  PSOCK_GENERATOR_SEND(&s->sout, generate_file_stats, strchr(ptr, ' ') + 1);
    55c2:	83 e6       	ldi	r24, 0x63	; 99
    55c4:	90 e0       	ldi	r25, 0x00	; 0
    55c6:	9f 8b       	std	Y+23, r25	; 0x17
    55c8:	8e 8b       	std	Y+22, r24	; 0x16
    55ca:	60 e2       	ldi	r22, 0x20	; 32
    55cc:	70 e0       	ldi	r23, 0x00	; 0
    55ce:	c9 01       	movw	r24, r18
    55d0:	0e 94 92 2c 	call	0x5924	; 0x5924 <strchr>
    55d4:	01 96       	adiw	r24, 0x01	; 1
    55d6:	ac 01       	movw	r20, r24
    55d8:	6e ef       	ldi	r22, 0xFE	; 254
    55da:	7a e2       	ldi	r23, 0x2A	; 42
    55dc:	ce 01       	movw	r24, r28
    55de:	46 96       	adiw	r24, 0x16	; 22
    55e0:	0e 94 7b 21 	call	0x42f6	; 0x42f6 <psock_generator_send>
    55e4:	88 23       	and	r24, r24
    55e6:	19 f4       	brne	.+6      	; 0x55ee <file_stats+0x44>
    55e8:	80 e0       	ldi	r24, 0x00	; 0
    55ea:	90 e0       	ldi	r25, 0x00	; 0
    55ec:	04 c0       	rjmp	.+8      	; 0x55f6 <file_stats+0x4c>
  
  PSOCK_END(&s->sout);
    55ee:	1f 8a       	std	Y+23, r1	; 0x17
    55f0:	1e 8a       	std	Y+22, r1	; 0x16
    55f2:	82 e0       	ldi	r24, 0x02	; 2
    55f4:	90 e0       	ldi	r25, 0x00	; 0
    55f6:	df 91       	pop	r29
    55f8:	cf 91       	pop	r28
    55fa:	08 95       	ret

000055fc <generate_file_stats>:
  return nullfunction;
}
/*---------------------------------------------------------------------------*/
static unsigned short
generate_file_stats(void *arg)
{
    55fc:	0e 94 f5 28 	call	0x51ea	; 0x51ea <httpd_fs_count>
    5600:	9f 93       	push	r25
    5602:	8f 93       	push	r24
    5604:	83 ed       	ldi	r24, 0xD3	; 211
    5606:	92 e0       	ldi	r25, 0x02	; 2
    5608:	9f 93       	push	r25
    560a:	8f 93       	push	r24
    560c:	86 ea       	ldi	r24, 0xA6	; 166
    560e:	95 e0       	ldi	r25, 0x05	; 5
    5610:	9f 93       	push	r25
    5612:	8f 93       	push	r24
    5614:	80 91 40 04 	lds	r24, 0x0440
    5618:	90 91 41 04 	lds	r25, 0x0441
    561c:	9f 93       	push	r25
    561e:	8f 93       	push	r24
    5620:	0e 94 ea 2c 	call	0x59d4	; 0x59d4 <snprintf>
    5624:	2d b7       	in	r18, 0x3d	; 61
    5626:	3e b7       	in	r19, 0x3e	; 62
    5628:	28 5f       	subi	r18, 0xF8	; 248
    562a:	3f 4f       	sbci	r19, 0xFF	; 255
    562c:	0f b6       	in	r0, 0x3f	; 63
    562e:	f8 94       	cli
    5630:	3e bf       	out	0x3e, r19	; 62
    5632:	0f be       	out	0x3f, r0	; 63
    5634:	2d bf       	out	0x3d, r18	; 61
    5636:	08 95       	ret

00005638 <malloc>:
    5638:	cf 93       	push	r28
    563a:	df 93       	push	r29
    563c:	ac 01       	movw	r20, r24
    563e:	02 97       	sbiw	r24, 0x02	; 2
    5640:	10 f4       	brcc	.+4      	; 0x5646 <malloc+0xe>
    5642:	42 e0       	ldi	r20, 0x02	; 2
    5644:	50 e0       	ldi	r21, 0x00	; 0
    5646:	a0 91 9e 0b 	lds	r26, 0x0B9E
    564a:	b0 91 9f 0b 	lds	r27, 0x0B9F
    564e:	fd 01       	movw	r30, r26
    5650:	c0 e0       	ldi	r28, 0x00	; 0
    5652:	d0 e0       	ldi	r29, 0x00	; 0
    5654:	20 e0       	ldi	r18, 0x00	; 0
    5656:	30 e0       	ldi	r19, 0x00	; 0
    5658:	20 c0       	rjmp	.+64     	; 0x569a <malloc+0x62>
    565a:	80 81       	ld	r24, Z
    565c:	91 81       	ldd	r25, Z+1	; 0x01
    565e:	84 17       	cp	r24, r20
    5660:	95 07       	cpc	r25, r21
    5662:	69 f4       	brne	.+26     	; 0x567e <malloc+0x46>
    5664:	82 81       	ldd	r24, Z+2	; 0x02
    5666:	93 81       	ldd	r25, Z+3	; 0x03
    5668:	20 97       	sbiw	r28, 0x00	; 0
    566a:	19 f0       	breq	.+6      	; 0x5672 <malloc+0x3a>
    566c:	9b 83       	std	Y+3, r25	; 0x03
    566e:	8a 83       	std	Y+2, r24	; 0x02
    5670:	04 c0       	rjmp	.+8      	; 0x567a <malloc+0x42>
    5672:	90 93 9f 0b 	sts	0x0B9F, r25
    5676:	80 93 9e 0b 	sts	0x0B9E, r24
    567a:	9f 01       	movw	r18, r30
    567c:	32 c0       	rjmp	.+100    	; 0x56e2 <malloc+0xaa>
    567e:	48 17       	cp	r20, r24
    5680:	59 07       	cpc	r21, r25
    5682:	38 f4       	brcc	.+14     	; 0x5692 <malloc+0x5a>
    5684:	21 15       	cp	r18, r1
    5686:	31 05       	cpc	r19, r1
    5688:	19 f0       	breq	.+6      	; 0x5690 <malloc+0x58>
    568a:	82 17       	cp	r24, r18
    568c:	93 07       	cpc	r25, r19
    568e:	08 f4       	brcc	.+2      	; 0x5692 <malloc+0x5a>
    5690:	9c 01       	movw	r18, r24
    5692:	ef 01       	movw	r28, r30
    5694:	02 80       	ldd	r0, Z+2	; 0x02
    5696:	f3 81       	ldd	r31, Z+3	; 0x03
    5698:	e0 2d       	mov	r30, r0
    569a:	30 97       	sbiw	r30, 0x00	; 0
    569c:	f1 f6       	brne	.-68     	; 0x565a <malloc+0x22>
    569e:	21 15       	cp	r18, r1
    56a0:	31 05       	cpc	r19, r1
    56a2:	99 f1       	breq	.+102    	; 0x570a <malloc+0xd2>
    56a4:	c9 01       	movw	r24, r18
    56a6:	84 1b       	sub	r24, r20
    56a8:	95 0b       	sbc	r25, r21
    56aa:	04 97       	sbiw	r24, 0x04	; 4
    56ac:	08 f4       	brcc	.+2      	; 0x56b0 <malloc+0x78>
    56ae:	a9 01       	movw	r20, r18
    56b0:	e0 e0       	ldi	r30, 0x00	; 0
    56b2:	f0 e0       	ldi	r31, 0x00	; 0
    56b4:	28 c0       	rjmp	.+80     	; 0x5706 <malloc+0xce>
    56b6:	8d 91       	ld	r24, X+
    56b8:	9c 91       	ld	r25, X
    56ba:	11 97       	sbiw	r26, 0x01	; 1
    56bc:	82 17       	cp	r24, r18
    56be:	93 07       	cpc	r25, r19
    56c0:	f9 f4       	brne	.+62     	; 0x5700 <malloc+0xc8>
    56c2:	48 17       	cp	r20, r24
    56c4:	59 07       	cpc	r21, r25
    56c6:	81 f4       	brne	.+32     	; 0x56e8 <malloc+0xb0>
    56c8:	ed 01       	movw	r28, r26
    56ca:	8a 81       	ldd	r24, Y+2	; 0x02
    56cc:	9b 81       	ldd	r25, Y+3	; 0x03
    56ce:	30 97       	sbiw	r30, 0x00	; 0
    56d0:	19 f0       	breq	.+6      	; 0x56d8 <malloc+0xa0>
    56d2:	93 83       	std	Z+3, r25	; 0x03
    56d4:	82 83       	std	Z+2, r24	; 0x02
    56d6:	04 c0       	rjmp	.+8      	; 0x56e0 <malloc+0xa8>
    56d8:	90 93 9f 0b 	sts	0x0B9F, r25
    56dc:	80 93 9e 0b 	sts	0x0B9E, r24
    56e0:	9d 01       	movw	r18, r26
    56e2:	2e 5f       	subi	r18, 0xFE	; 254
    56e4:	3f 4f       	sbci	r19, 0xFF	; 255
    56e6:	4c c0       	rjmp	.+152    	; 0x5780 <malloc+0x148>
    56e8:	84 1b       	sub	r24, r20
    56ea:	95 0b       	sbc	r25, r21
    56ec:	fd 01       	movw	r30, r26
    56ee:	e8 0f       	add	r30, r24
    56f0:	f9 1f       	adc	r31, r25
    56f2:	41 93       	st	Z+, r20
    56f4:	51 93       	st	Z+, r21
    56f6:	02 97       	sbiw	r24, 0x02	; 2
    56f8:	8d 93       	st	X+, r24
    56fa:	9c 93       	st	X, r25
    56fc:	9f 01       	movw	r18, r30
    56fe:	40 c0       	rjmp	.+128    	; 0x5780 <malloc+0x148>
    5700:	fd 01       	movw	r30, r26
    5702:	a2 81       	ldd	r26, Z+2	; 0x02
    5704:	b3 81       	ldd	r27, Z+3	; 0x03
    5706:	10 97       	sbiw	r26, 0x00	; 0
    5708:	b1 f6       	brne	.-84     	; 0x56b6 <malloc+0x7e>
    570a:	80 91 9c 0b 	lds	r24, 0x0B9C
    570e:	90 91 9d 0b 	lds	r25, 0x0B9D
    5712:	89 2b       	or	r24, r25
    5714:	41 f4       	brne	.+16     	; 0x5726 <malloc+0xee>
    5716:	80 91 7a 03 	lds	r24, 0x037A
    571a:	90 91 7b 03 	lds	r25, 0x037B
    571e:	90 93 9d 0b 	sts	0x0B9D, r25
    5722:	80 93 9c 0b 	sts	0x0B9C, r24
    5726:	20 91 7c 03 	lds	r18, 0x037C
    572a:	30 91 7d 03 	lds	r19, 0x037D
    572e:	21 15       	cp	r18, r1
    5730:	31 05       	cpc	r19, r1
    5732:	49 f4       	brne	.+18     	; 0x5746 <malloc+0x10e>
    5734:	8d b7       	in	r24, 0x3d	; 61
    5736:	28 2f       	mov	r18, r24
    5738:	30 e0       	ldi	r19, 0x00	; 0
    573a:	80 91 78 03 	lds	r24, 0x0378
    573e:	90 91 79 03 	lds	r25, 0x0379
    5742:	28 1b       	sub	r18, r24
    5744:	39 0b       	sbc	r19, r25
    5746:	a0 91 9c 0b 	lds	r26, 0x0B9C
    574a:	b0 91 9d 0b 	lds	r27, 0x0B9D
    574e:	2a 1b       	sub	r18, r26
    5750:	3b 0b       	sbc	r19, r27
    5752:	24 17       	cp	r18, r20
    5754:	35 07       	cpc	r19, r21
    5756:	90 f0       	brcs	.+36     	; 0x577c <malloc+0x144>
    5758:	ca 01       	movw	r24, r20
    575a:	02 96       	adiw	r24, 0x02	; 2
    575c:	28 17       	cp	r18, r24
    575e:	39 07       	cpc	r19, r25
    5760:	68 f0       	brcs	.+26     	; 0x577c <malloc+0x144>
    5762:	9d 01       	movw	r18, r26
    5764:	2e 5f       	subi	r18, 0xFE	; 254
    5766:	3f 4f       	sbci	r19, 0xFF	; 255
    5768:	c9 01       	movw	r24, r18
    576a:	84 0f       	add	r24, r20
    576c:	95 1f       	adc	r25, r21
    576e:	90 93 9d 0b 	sts	0x0B9D, r25
    5772:	80 93 9c 0b 	sts	0x0B9C, r24
    5776:	4d 93       	st	X+, r20
    5778:	5c 93       	st	X, r21
    577a:	02 c0       	rjmp	.+4      	; 0x5780 <malloc+0x148>
    577c:	20 e0       	ldi	r18, 0x00	; 0
    577e:	30 e0       	ldi	r19, 0x00	; 0
    5780:	c9 01       	movw	r24, r18
    5782:	df 91       	pop	r29
    5784:	cf 91       	pop	r28
    5786:	08 95       	ret

00005788 <free>:
    5788:	cf 93       	push	r28
    578a:	df 93       	push	r29
    578c:	00 97       	sbiw	r24, 0x00	; 0
    578e:	09 f4       	brne	.+2      	; 0x5792 <free+0xa>
    5790:	4e c0       	rjmp	.+156    	; 0x582e <free+0xa6>
    5792:	ec 01       	movw	r28, r24
    5794:	22 97       	sbiw	r28, 0x02	; 2
    5796:	1b 82       	std	Y+3, r1	; 0x03
    5798:	1a 82       	std	Y+2, r1	; 0x02
    579a:	a0 91 9e 0b 	lds	r26, 0x0B9E
    579e:	b0 91 9f 0b 	lds	r27, 0x0B9F
    57a2:	10 97       	sbiw	r26, 0x00	; 0
    57a4:	11 f1       	breq	.+68     	; 0x57ea <free+0x62>
    57a6:	40 e0       	ldi	r20, 0x00	; 0
    57a8:	50 e0       	ldi	r21, 0x00	; 0
    57aa:	01 c0       	rjmp	.+2      	; 0x57ae <free+0x26>
    57ac:	dc 01       	movw	r26, r24
    57ae:	ac 17       	cp	r26, r28
    57b0:	bd 07       	cpc	r27, r29
    57b2:	00 f1       	brcs	.+64     	; 0x57f4 <free+0x6c>
    57b4:	bb 83       	std	Y+3, r27	; 0x03
    57b6:	aa 83       	std	Y+2, r26	; 0x02
    57b8:	fe 01       	movw	r30, r28
    57ba:	21 91       	ld	r18, Z+
    57bc:	31 91       	ld	r19, Z+
    57be:	e2 0f       	add	r30, r18
    57c0:	f3 1f       	adc	r31, r19
    57c2:	ea 17       	cp	r30, r26
    57c4:	fb 07       	cpc	r31, r27
    57c6:	71 f4       	brne	.+28     	; 0x57e4 <free+0x5c>
    57c8:	8d 91       	ld	r24, X+
    57ca:	9c 91       	ld	r25, X
    57cc:	11 97       	sbiw	r26, 0x01	; 1
    57ce:	28 0f       	add	r18, r24
    57d0:	39 1f       	adc	r19, r25
    57d2:	2e 5f       	subi	r18, 0xFE	; 254
    57d4:	3f 4f       	sbci	r19, 0xFF	; 255
    57d6:	39 83       	std	Y+1, r19	; 0x01
    57d8:	28 83       	st	Y, r18
    57da:	fd 01       	movw	r30, r26
    57dc:	82 81       	ldd	r24, Z+2	; 0x02
    57de:	93 81       	ldd	r25, Z+3	; 0x03
    57e0:	9b 83       	std	Y+3, r25	; 0x03
    57e2:	8a 83       	std	Y+2, r24	; 0x02
    57e4:	41 15       	cp	r20, r1
    57e6:	51 05       	cpc	r21, r1
    57e8:	59 f4       	brne	.+22     	; 0x5800 <free+0x78>
    57ea:	d0 93 9f 0b 	sts	0x0B9F, r29
    57ee:	c0 93 9e 0b 	sts	0x0B9E, r28
    57f2:	1d c0       	rjmp	.+58     	; 0x582e <free+0xa6>
    57f4:	fd 01       	movw	r30, r26
    57f6:	82 81       	ldd	r24, Z+2	; 0x02
    57f8:	93 81       	ldd	r25, Z+3	; 0x03
    57fa:	ad 01       	movw	r20, r26
    57fc:	00 97       	sbiw	r24, 0x00	; 0
    57fe:	b1 f6       	brne	.-84     	; 0x57ac <free+0x24>
    5800:	fa 01       	movw	r30, r20
    5802:	d3 83       	std	Z+3, r29	; 0x03
    5804:	c2 83       	std	Z+2, r28	; 0x02
    5806:	21 91       	ld	r18, Z+
    5808:	31 91       	ld	r19, Z+
    580a:	e2 0f       	add	r30, r18
    580c:	f3 1f       	adc	r31, r19
    580e:	ec 17       	cp	r30, r28
    5810:	fd 07       	cpc	r31, r29
    5812:	69 f4       	brne	.+26     	; 0x582e <free+0xa6>
    5814:	88 81       	ld	r24, Y
    5816:	99 81       	ldd	r25, Y+1	; 0x01
    5818:	28 0f       	add	r18, r24
    581a:	39 1f       	adc	r19, r25
    581c:	2e 5f       	subi	r18, 0xFE	; 254
    581e:	3f 4f       	sbci	r19, 0xFF	; 255
    5820:	fa 01       	movw	r30, r20
    5822:	31 83       	std	Z+1, r19	; 0x01
    5824:	20 83       	st	Z, r18
    5826:	8a 81       	ldd	r24, Y+2	; 0x02
    5828:	9b 81       	ldd	r25, Y+3	; 0x03
    582a:	93 83       	std	Z+3, r25	; 0x03
    582c:	82 83       	std	Z+2, r24	; 0x02
    582e:	df 91       	pop	r29
    5830:	cf 91       	pop	r28
    5832:	08 95       	ret

00005834 <atoi>:
    5834:	fc 01       	movw	r30, r24
    5836:	88 27       	eor	r24, r24
    5838:	99 27       	eor	r25, r25
    583a:	e8 94       	clt
    583c:	21 91       	ld	r18, Z+
    583e:	20 32       	cpi	r18, 0x20	; 32
    5840:	e9 f3       	breq	.-6      	; 0x583c <atoi+0x8>
    5842:	29 30       	cpi	r18, 0x09	; 9
    5844:	10 f0       	brcs	.+4      	; 0x584a <atoi+0x16>
    5846:	2e 30       	cpi	r18, 0x0E	; 14
    5848:	c8 f3       	brcs	.-14     	; 0x583c <atoi+0x8>
    584a:	2b 32       	cpi	r18, 0x2B	; 43
    584c:	41 f0       	breq	.+16     	; 0x585e <atoi+0x2a>
    584e:	2d 32       	cpi	r18, 0x2D	; 45
    5850:	39 f4       	brne	.+14     	; 0x5860 <atoi+0x2c>
    5852:	68 94       	set
    5854:	04 c0       	rjmp	.+8      	; 0x585e <atoi+0x2a>
    5856:	0e 94 e2 2c 	call	0x59c4	; 0x59c4 <__mulhi_const_10>
    585a:	82 0f       	add	r24, r18
    585c:	91 1d       	adc	r25, r1
    585e:	21 91       	ld	r18, Z+
    5860:	20 53       	subi	r18, 0x30	; 48
    5862:	2a 30       	cpi	r18, 0x0A	; 10
    5864:	c0 f3       	brcs	.-16     	; 0x5856 <atoi+0x22>
    5866:	1e f4       	brtc	.+6      	; 0x586e <atoi+0x3a>
    5868:	90 95       	com	r25
    586a:	81 95       	neg	r24
    586c:	9f 4f       	sbci	r25, 0xFF	; 255
    586e:	08 95       	ret

00005870 <memcpy_P>:
    5870:	fb 01       	movw	r30, r22
    5872:	dc 01       	movw	r26, r24
    5874:	02 c0       	rjmp	.+4      	; 0x587a <memcpy_P+0xa>
    5876:	05 90       	lpm	r0, Z+
    5878:	0d 92       	st	X+, r0
    587a:	41 50       	subi	r20, 0x01	; 1
    587c:	50 40       	sbci	r21, 0x00	; 0
    587e:	d8 f7       	brcc	.-10     	; 0x5876 <memcpy_P+0x6>
    5880:	08 95       	ret

00005882 <strchr_P>:
    5882:	fc 01       	movw	r30, r24
    5884:	05 90       	lpm	r0, Z+
    5886:	06 16       	cp	r0, r22
    5888:	21 f0       	breq	.+8      	; 0x5892 <strchr_P+0x10>
    588a:	00 20       	and	r0, r0
    588c:	d9 f7       	brne	.-10     	; 0x5884 <strchr_P+0x2>
    588e:	c0 01       	movw	r24, r0
    5890:	08 95       	ret
    5892:	31 97       	sbiw	r30, 0x01	; 1
    5894:	cf 01       	movw	r24, r30
    5896:	08 95       	ret

00005898 <strcmp_P>:
    5898:	fb 01       	movw	r30, r22
    589a:	dc 01       	movw	r26, r24
    589c:	8d 91       	ld	r24, X+
    589e:	05 90       	lpm	r0, Z+
    58a0:	80 19       	sub	r24, r0
    58a2:	01 10       	cpse	r0, r1
    58a4:	d9 f3       	breq	.-10     	; 0x589c <strcmp_P+0x4>
    58a6:	99 0b       	sbc	r25, r25
    58a8:	08 95       	ret

000058aa <strcpy_P>:
    58aa:	fb 01       	movw	r30, r22
    58ac:	dc 01       	movw	r26, r24
    58ae:	05 90       	lpm	r0, Z+
    58b0:	0d 92       	st	X+, r0
    58b2:	00 20       	and	r0, r0
    58b4:	e1 f7       	brne	.-8      	; 0x58ae <strcpy_P+0x4>
    58b6:	08 95       	ret

000058b8 <strlen_P>:
    58b8:	fc 01       	movw	r30, r24
    58ba:	05 90       	lpm	r0, Z+
    58bc:	00 20       	and	r0, r0
    58be:	e9 f7       	brne	.-6      	; 0x58ba <strlen_P+0x2>
    58c0:	80 95       	com	r24
    58c2:	90 95       	com	r25
    58c4:	8e 0f       	add	r24, r30
    58c6:	9f 1f       	adc	r25, r31
    58c8:	08 95       	ret

000058ca <strncmp_P>:
    58ca:	fb 01       	movw	r30, r22
    58cc:	dc 01       	movw	r26, r24
    58ce:	41 50       	subi	r20, 0x01	; 1
    58d0:	50 40       	sbci	r21, 0x00	; 0
    58d2:	30 f0       	brcs	.+12     	; 0x58e0 <strncmp_P+0x16>
    58d4:	8d 91       	ld	r24, X+
    58d6:	05 90       	lpm	r0, Z+
    58d8:	80 19       	sub	r24, r0
    58da:	19 f4       	brne	.+6      	; 0x58e2 <strncmp_P+0x18>
    58dc:	00 20       	and	r0, r0
    58de:	b9 f7       	brne	.-18     	; 0x58ce <strncmp_P+0x4>
    58e0:	88 1b       	sub	r24, r24
    58e2:	99 0b       	sbc	r25, r25
    58e4:	08 95       	ret

000058e6 <strncpy_P>:
    58e6:	fb 01       	movw	r30, r22
    58e8:	dc 01       	movw	r26, r24
    58ea:	41 50       	subi	r20, 0x01	; 1
    58ec:	50 40       	sbci	r21, 0x00	; 0
    58ee:	48 f0       	brcs	.+18     	; 0x5902 <strncpy_P+0x1c>
    58f0:	05 90       	lpm	r0, Z+
    58f2:	0d 92       	st	X+, r0
    58f4:	00 20       	and	r0, r0
    58f6:	c9 f7       	brne	.-14     	; 0x58ea <strncpy_P+0x4>
    58f8:	01 c0       	rjmp	.+2      	; 0x58fc <strncpy_P+0x16>
    58fa:	1d 92       	st	X+, r1
    58fc:	41 50       	subi	r20, 0x01	; 1
    58fe:	50 40       	sbci	r21, 0x00	; 0
    5900:	e0 f7       	brcc	.-8      	; 0x58fa <strncpy_P+0x14>
    5902:	08 95       	ret

00005904 <memcpy>:
    5904:	fb 01       	movw	r30, r22
    5906:	dc 01       	movw	r26, r24
    5908:	02 c0       	rjmp	.+4      	; 0x590e <memcpy+0xa>
    590a:	01 90       	ld	r0, Z+
    590c:	0d 92       	st	X+, r0
    590e:	41 50       	subi	r20, 0x01	; 1
    5910:	50 40       	sbci	r21, 0x00	; 0
    5912:	d8 f7       	brcc	.-10     	; 0x590a <memcpy+0x6>
    5914:	08 95       	ret

00005916 <memset>:
    5916:	dc 01       	movw	r26, r24
    5918:	01 c0       	rjmp	.+2      	; 0x591c <memset+0x6>
    591a:	6d 93       	st	X+, r22
    591c:	41 50       	subi	r20, 0x01	; 1
    591e:	50 40       	sbci	r21, 0x00	; 0
    5920:	e0 f7       	brcc	.-8      	; 0x591a <memset+0x4>
    5922:	08 95       	ret

00005924 <strchr>:
    5924:	fc 01       	movw	r30, r24
    5926:	81 91       	ld	r24, Z+
    5928:	86 17       	cp	r24, r22
    592a:	21 f0       	breq	.+8      	; 0x5934 <strchr+0x10>
    592c:	88 23       	and	r24, r24
    592e:	d9 f7       	brne	.-10     	; 0x5926 <strchr+0x2>
    5930:	99 27       	eor	r25, r25
    5932:	08 95       	ret
    5934:	31 97       	sbiw	r30, 0x01	; 1
    5936:	cf 01       	movw	r24, r30
    5938:	08 95       	ret

0000593a <strncpy>:
    593a:	fb 01       	movw	r30, r22
    593c:	dc 01       	movw	r26, r24
    593e:	41 50       	subi	r20, 0x01	; 1
    5940:	50 40       	sbci	r21, 0x00	; 0
    5942:	48 f0       	brcs	.+18     	; 0x5956 <strncpy+0x1c>
    5944:	01 90       	ld	r0, Z+
    5946:	0d 92       	st	X+, r0
    5948:	00 20       	and	r0, r0
    594a:	c9 f7       	brne	.-14     	; 0x593e <strncpy+0x4>
    594c:	01 c0       	rjmp	.+2      	; 0x5950 <strncpy+0x16>
    594e:	1d 92       	st	X+, r1
    5950:	41 50       	subi	r20, 0x01	; 1
    5952:	50 40       	sbci	r21, 0x00	; 0
    5954:	e0 f7       	brcc	.-8      	; 0x594e <strncpy+0x14>
    5956:	08 95       	ret

00005958 <strrchr>:
    5958:	fc 01       	movw	r30, r24
    595a:	81 e0       	ldi	r24, 0x01	; 1
    595c:	90 e0       	ldi	r25, 0x00	; 0
    595e:	01 90       	ld	r0, Z+
    5960:	06 16       	cp	r0, r22
    5962:	09 f4       	brne	.+2      	; 0x5966 <strrchr+0xe>
    5964:	cf 01       	movw	r24, r30
    5966:	00 20       	and	r0, r0
    5968:	d1 f7       	brne	.-12     	; 0x595e <strrchr+0x6>
    596a:	01 97       	sbiw	r24, 0x01	; 1
    596c:	08 95       	ret

0000596e <strupr>:
    596e:	dc 01       	movw	r26, r24
    5970:	6c 91       	ld	r22, X
    5972:	61 56       	subi	r22, 0x61	; 97
    5974:	6a 31       	cpi	r22, 0x1A	; 26
    5976:	08 f0       	brcs	.+2      	; 0x597a <strupr+0xc>
    5978:	60 5e       	subi	r22, 0xE0	; 224
    597a:	6f 5b       	subi	r22, 0xBF	; 191
    597c:	6d 93       	st	X+, r22
    597e:	c1 f7       	brne	.-16     	; 0x5970 <strupr+0x2>
    5980:	08 95       	ret

00005982 <itoa>:
    5982:	fb 01       	movw	r30, r22
    5984:	9f 01       	movw	r18, r30
    5986:	e8 94       	clt
    5988:	42 30       	cpi	r20, 0x02	; 2
    598a:	c4 f0       	brlt	.+48     	; 0x59bc <itoa+0x3a>
    598c:	45 32       	cpi	r20, 0x25	; 37
    598e:	b4 f4       	brge	.+44     	; 0x59bc <itoa+0x3a>
    5990:	4a 30       	cpi	r20, 0x0A	; 10
    5992:	29 f4       	brne	.+10     	; 0x599e <itoa+0x1c>
    5994:	97 fb       	bst	r25, 7
    5996:	1e f4       	brtc	.+6      	; 0x599e <itoa+0x1c>
    5998:	90 95       	com	r25
    599a:	81 95       	neg	r24
    599c:	9f 4f       	sbci	r25, 0xFF	; 255
    599e:	64 2f       	mov	r22, r20
    59a0:	77 27       	eor	r23, r23
    59a2:	0e 94 c4 2f 	call	0x5f88	; 0x5f88 <__udivmodhi4>
    59a6:	80 5d       	subi	r24, 0xD0	; 208
    59a8:	8a 33       	cpi	r24, 0x3A	; 58
    59aa:	0c f0       	brlt	.+2      	; 0x59ae <itoa+0x2c>
    59ac:	89 5d       	subi	r24, 0xD9	; 217
    59ae:	81 93       	st	Z+, r24
    59b0:	cb 01       	movw	r24, r22
    59b2:	00 97       	sbiw	r24, 0x00	; 0
    59b4:	a1 f7       	brne	.-24     	; 0x599e <itoa+0x1c>
    59b6:	16 f4       	brtc	.+4      	; 0x59bc <itoa+0x3a>
    59b8:	5d e2       	ldi	r21, 0x2D	; 45
    59ba:	51 93       	st	Z+, r21
    59bc:	10 82       	st	Z, r1
    59be:	c9 01       	movw	r24, r18
    59c0:	0c 94 2a 2f 	jmp	0x5e54	; 0x5e54 <strrev>

000059c4 <__mulhi_const_10>:
    59c4:	7a e0       	ldi	r23, 0x0A	; 10
    59c6:	97 9f       	mul	r25, r23
    59c8:	90 2d       	mov	r25, r0
    59ca:	87 9f       	mul	r24, r23
    59cc:	80 2d       	mov	r24, r0
    59ce:	91 0d       	add	r25, r1
    59d0:	11 24       	eor	r1, r1
    59d2:	08 95       	ret

000059d4 <snprintf>:
    59d4:	a0 e1       	ldi	r26, 0x10	; 16
    59d6:	b0 e0       	ldi	r27, 0x00	; 0
    59d8:	e0 ef       	ldi	r30, 0xF0	; 240
    59da:	fc e2       	ldi	r31, 0x2C	; 44
    59dc:	0c 94 e6 2f 	jmp	0x5fcc	; 0x5fcc <__prologue_saves__+0x1c>
    59e0:	0f 89       	ldd	r16, Y+23	; 0x17
    59e2:	18 8d       	ldd	r17, Y+24	; 0x18
    59e4:	89 8d       	ldd	r24, Y+25	; 0x19
    59e6:	9a 8d       	ldd	r25, Y+26	; 0x1a
    59e8:	97 ff       	sbrs	r25, 7
    59ea:	02 c0       	rjmp	.+4      	; 0x59f0 <snprintf+0x1c>
    59ec:	80 e0       	ldi	r24, 0x00	; 0
    59ee:	90 e8       	ldi	r25, 0x80	; 128
    59f0:	01 97       	sbiw	r24, 0x01	; 1
    59f2:	98 87       	std	Y+8, r25	; 0x08
    59f4:	8f 83       	std	Y+7, r24	; 0x07
    59f6:	1c 83       	std	Y+4, r17	; 0x04
    59f8:	0b 83       	std	Y+3, r16	; 0x03
    59fa:	86 e0       	ldi	r24, 0x06	; 6
    59fc:	8e 83       	std	Y+6, r24	; 0x06
    59fe:	ae 01       	movw	r20, r28
    5a00:	43 5e       	subi	r20, 0xE3	; 227
    5a02:	5f 4f       	sbci	r21, 0xFF	; 255
    5a04:	5a 83       	std	Y+2, r21	; 0x02
    5a06:	49 83       	std	Y+1, r20	; 0x01
    5a08:	6b 8d       	ldd	r22, Y+27	; 0x1b
    5a0a:	7c 8d       	ldd	r23, Y+28	; 0x1c
    5a0c:	ce 01       	movw	r24, r28
    5a0e:	03 96       	adiw	r24, 0x03	; 3
    5a10:	0e 94 1c 2d 	call	0x5a38	; 0x5a38 <vfprintf>
    5a14:	4f 81       	ldd	r20, Y+7	; 0x07
    5a16:	58 85       	ldd	r21, Y+8	; 0x08
    5a18:	57 fd       	sbrc	r21, 7
    5a1a:	0a c0       	rjmp	.+20     	; 0x5a30 <snprintf+0x5c>
    5a1c:	29 85       	ldd	r18, Y+9	; 0x09
    5a1e:	3a 85       	ldd	r19, Y+10	; 0x0a
    5a20:	42 17       	cp	r20, r18
    5a22:	53 07       	cpc	r21, r19
    5a24:	0c f4       	brge	.+2      	; 0x5a28 <snprintf+0x54>
    5a26:	9a 01       	movw	r18, r20
    5a28:	02 0f       	add	r16, r18
    5a2a:	13 1f       	adc	r17, r19
    5a2c:	f8 01       	movw	r30, r16
    5a2e:	10 82       	st	Z, r1
    5a30:	e4 e0       	ldi	r30, 0x04	; 4
    5a32:	60 96       	adiw	r28, 0x10	; 16
    5a34:	0c 94 02 30 	jmp	0x6004	; 0x6004 <__epilogue_restores__+0x1c>

00005a38 <vfprintf>:
    5a38:	2f 92       	push	r2
    5a3a:	3f 92       	push	r3
    5a3c:	5f 92       	push	r5
    5a3e:	6f 92       	push	r6
    5a40:	7f 92       	push	r7
    5a42:	8f 92       	push	r8
    5a44:	9f 92       	push	r9
    5a46:	af 92       	push	r10
    5a48:	bf 92       	push	r11
    5a4a:	cf 92       	push	r12
    5a4c:	df 92       	push	r13
    5a4e:	ef 92       	push	r14
    5a50:	ff 92       	push	r15
    5a52:	0f 93       	push	r16
    5a54:	1f 93       	push	r17
    5a56:	cf 93       	push	r28
    5a58:	df 93       	push	r29
    5a5a:	cd b7       	in	r28, 0x3d	; 61
    5a5c:	de b7       	in	r29, 0x3e	; 62
    5a5e:	2b 97       	sbiw	r28, 0x0b	; 11
    5a60:	0f b6       	in	r0, 0x3f	; 63
    5a62:	f8 94       	cli
    5a64:	de bf       	out	0x3e, r29	; 62
    5a66:	0f be       	out	0x3f, r0	; 63
    5a68:	cd bf       	out	0x3d, r28	; 61
    5a6a:	3c 01       	movw	r6, r24
    5a6c:	4b 01       	movw	r8, r22
    5a6e:	6a 01       	movw	r12, r20
    5a70:	fc 01       	movw	r30, r24
    5a72:	17 82       	std	Z+7, r1	; 0x07
    5a74:	16 82       	std	Z+6, r1	; 0x06
    5a76:	83 81       	ldd	r24, Z+3	; 0x03
    5a78:	81 fd       	sbrc	r24, 1
    5a7a:	03 c0       	rjmp	.+6      	; 0x5a82 <vfprintf+0x4a>
    5a7c:	8f ef       	ldi	r24, 0xFF	; 255
    5a7e:	9f ef       	ldi	r25, 0xFF	; 255
    5a80:	bb c1       	rjmp	.+886    	; 0x5df8 <vfprintf+0x3c0>
    5a82:	1e 01       	movw	r2, r28
    5a84:	08 94       	sec
    5a86:	21 1c       	adc	r2, r1
    5a88:	31 1c       	adc	r3, r1
    5a8a:	f3 01       	movw	r30, r6
    5a8c:	33 81       	ldd	r19, Z+3	; 0x03
    5a8e:	f4 01       	movw	r30, r8
    5a90:	33 fd       	sbrc	r19, 3
    5a92:	85 91       	lpm	r24, Z+
    5a94:	33 ff       	sbrs	r19, 3
    5a96:	81 91       	ld	r24, Z+
    5a98:	4f 01       	movw	r8, r30
    5a9a:	88 23       	and	r24, r24
    5a9c:	09 f4       	brne	.+2      	; 0x5aa0 <vfprintf+0x68>
    5a9e:	a9 c1       	rjmp	.+850    	; 0x5df2 <vfprintf+0x3ba>
    5aa0:	85 32       	cpi	r24, 0x25	; 37
    5aa2:	39 f4       	brne	.+14     	; 0x5ab2 <vfprintf+0x7a>
    5aa4:	33 fd       	sbrc	r19, 3
    5aa6:	85 91       	lpm	r24, Z+
    5aa8:	33 ff       	sbrs	r19, 3
    5aaa:	81 91       	ld	r24, Z+
    5aac:	4f 01       	movw	r8, r30
    5aae:	85 32       	cpi	r24, 0x25	; 37
    5ab0:	29 f4       	brne	.+10     	; 0x5abc <vfprintf+0x84>
    5ab2:	b3 01       	movw	r22, r6
    5ab4:	90 e0       	ldi	r25, 0x00	; 0
    5ab6:	0e 94 3a 2f 	call	0x5e74	; 0x5e74 <fputc>
    5aba:	e7 cf       	rjmp	.-50     	; 0x5a8a <vfprintf+0x52>
    5abc:	98 2f       	mov	r25, r24
    5abe:	aa 24       	eor	r10, r10
    5ac0:	10 e0       	ldi	r17, 0x00	; 0
    5ac2:	55 24       	eor	r5, r5
    5ac4:	10 32       	cpi	r17, 0x20	; 32
    5ac6:	b0 f4       	brcc	.+44     	; 0x5af4 <vfprintf+0xbc>
    5ac8:	9b 32       	cpi	r25, 0x2B	; 43
    5aca:	69 f0       	breq	.+26     	; 0x5ae6 <vfprintf+0xae>
    5acc:	9c 32       	cpi	r25, 0x2C	; 44
    5ace:	28 f4       	brcc	.+10     	; 0x5ada <vfprintf+0xa2>
    5ad0:	90 32       	cpi	r25, 0x20	; 32
    5ad2:	51 f0       	breq	.+20     	; 0x5ae8 <vfprintf+0xb0>
    5ad4:	93 32       	cpi	r25, 0x23	; 35
    5ad6:	71 f4       	brne	.+28     	; 0x5af4 <vfprintf+0xbc>
    5ad8:	0b c0       	rjmp	.+22     	; 0x5af0 <vfprintf+0xb8>
    5ada:	9d 32       	cpi	r25, 0x2D	; 45
    5adc:	39 f0       	breq	.+14     	; 0x5aec <vfprintf+0xb4>
    5ade:	90 33       	cpi	r25, 0x30	; 48
    5ae0:	49 f4       	brne	.+18     	; 0x5af4 <vfprintf+0xbc>
    5ae2:	11 60       	ori	r17, 0x01	; 1
    5ae4:	2a c0       	rjmp	.+84     	; 0x5b3a <vfprintf+0x102>
    5ae6:	12 60       	ori	r17, 0x02	; 2
    5ae8:	14 60       	ori	r17, 0x04	; 4
    5aea:	27 c0       	rjmp	.+78     	; 0x5b3a <vfprintf+0x102>
    5aec:	18 60       	ori	r17, 0x08	; 8
    5aee:	25 c0       	rjmp	.+74     	; 0x5b3a <vfprintf+0x102>
    5af0:	10 61       	ori	r17, 0x10	; 16
    5af2:	23 c0       	rjmp	.+70     	; 0x5b3a <vfprintf+0x102>
    5af4:	17 fd       	sbrc	r17, 7
    5af6:	2a c0       	rjmp	.+84     	; 0x5b4c <vfprintf+0x114>
    5af8:	29 2f       	mov	r18, r25
    5afa:	20 53       	subi	r18, 0x30	; 48
    5afc:	2a 30       	cpi	r18, 0x0A	; 10
    5afe:	88 f4       	brcc	.+34     	; 0x5b22 <vfprintf+0xea>
    5b00:	16 ff       	sbrs	r17, 6
    5b02:	07 c0       	rjmp	.+14     	; 0x5b12 <vfprintf+0xda>
    5b04:	8a e0       	ldi	r24, 0x0A	; 10
    5b06:	a8 9e       	mul	r10, r24
    5b08:	c0 01       	movw	r24, r0
    5b0a:	11 24       	eor	r1, r1
    5b0c:	a2 2e       	mov	r10, r18
    5b0e:	a8 0e       	add	r10, r24
    5b10:	14 c0       	rjmp	.+40     	; 0x5b3a <vfprintf+0x102>
    5b12:	8a e0       	ldi	r24, 0x0A	; 10
    5b14:	58 9e       	mul	r5, r24
    5b16:	c0 01       	movw	r24, r0
    5b18:	11 24       	eor	r1, r1
    5b1a:	52 2e       	mov	r5, r18
    5b1c:	58 0e       	add	r5, r24
    5b1e:	10 62       	ori	r17, 0x20	; 32
    5b20:	0c c0       	rjmp	.+24     	; 0x5b3a <vfprintf+0x102>
    5b22:	9e 32       	cpi	r25, 0x2E	; 46
    5b24:	21 f4       	brne	.+8      	; 0x5b2e <vfprintf+0xf6>
    5b26:	16 fd       	sbrc	r17, 6
    5b28:	64 c1       	rjmp	.+712    	; 0x5df2 <vfprintf+0x3ba>
    5b2a:	10 64       	ori	r17, 0x40	; 64
    5b2c:	06 c0       	rjmp	.+12     	; 0x5b3a <vfprintf+0x102>
    5b2e:	9c 36       	cpi	r25, 0x6C	; 108
    5b30:	11 f4       	brne	.+4      	; 0x5b36 <vfprintf+0xfe>
    5b32:	10 68       	ori	r17, 0x80	; 128
    5b34:	02 c0       	rjmp	.+4      	; 0x5b3a <vfprintf+0x102>
    5b36:	98 36       	cpi	r25, 0x68	; 104
    5b38:	49 f4       	brne	.+18     	; 0x5b4c <vfprintf+0x114>
    5b3a:	f4 01       	movw	r30, r8
    5b3c:	33 fd       	sbrc	r19, 3
    5b3e:	95 91       	lpm	r25, Z+
    5b40:	33 ff       	sbrs	r19, 3
    5b42:	91 91       	ld	r25, Z+
    5b44:	4f 01       	movw	r8, r30
    5b46:	99 23       	and	r25, r25
    5b48:	09 f0       	breq	.+2      	; 0x5b4c <vfprintf+0x114>
    5b4a:	bc cf       	rjmp	.-136    	; 0x5ac4 <vfprintf+0x8c>
    5b4c:	89 2f       	mov	r24, r25
    5b4e:	85 54       	subi	r24, 0x45	; 69
    5b50:	83 30       	cpi	r24, 0x03	; 3
    5b52:	18 f0       	brcs	.+6      	; 0x5b5a <vfprintf+0x122>
    5b54:	80 52       	subi	r24, 0x20	; 32
    5b56:	83 30       	cpi	r24, 0x03	; 3
    5b58:	38 f4       	brcc	.+14     	; 0x5b68 <vfprintf+0x130>
    5b5a:	24 e0       	ldi	r18, 0x04	; 4
    5b5c:	30 e0       	ldi	r19, 0x00	; 0
    5b5e:	c2 0e       	add	r12, r18
    5b60:	d3 1e       	adc	r13, r19
    5b62:	8f e3       	ldi	r24, 0x3F	; 63
    5b64:	89 83       	std	Y+1, r24	; 0x01
    5b66:	0f c0       	rjmp	.+30     	; 0x5b86 <vfprintf+0x14e>
    5b68:	93 36       	cpi	r25, 0x63	; 99
    5b6a:	31 f0       	breq	.+12     	; 0x5b78 <vfprintf+0x140>
    5b6c:	93 37       	cpi	r25, 0x73	; 115
    5b6e:	81 f0       	breq	.+32     	; 0x5b90 <vfprintf+0x158>
    5b70:	93 35       	cpi	r25, 0x53	; 83
    5b72:	09 f0       	breq	.+2      	; 0x5b76 <vfprintf+0x13e>
    5b74:	56 c0       	rjmp	.+172    	; 0x5c22 <vfprintf+0x1ea>
    5b76:	20 c0       	rjmp	.+64     	; 0x5bb8 <vfprintf+0x180>
    5b78:	f6 01       	movw	r30, r12
    5b7a:	80 81       	ld	r24, Z
    5b7c:	89 83       	std	Y+1, r24	; 0x01
    5b7e:	22 e0       	ldi	r18, 0x02	; 2
    5b80:	30 e0       	ldi	r19, 0x00	; 0
    5b82:	c2 0e       	add	r12, r18
    5b84:	d3 1e       	adc	r13, r19
    5b86:	71 01       	movw	r14, r2
    5b88:	81 e0       	ldi	r24, 0x01	; 1
    5b8a:	a8 2e       	mov	r10, r24
    5b8c:	b1 2c       	mov	r11, r1
    5b8e:	12 c0       	rjmp	.+36     	; 0x5bb4 <vfprintf+0x17c>
    5b90:	f6 01       	movw	r30, r12
    5b92:	e0 80       	ld	r14, Z
    5b94:	f1 80       	ldd	r15, Z+1	; 0x01
    5b96:	16 fd       	sbrc	r17, 6
    5b98:	03 c0       	rjmp	.+6      	; 0x5ba0 <vfprintf+0x168>
    5b9a:	6f ef       	ldi	r22, 0xFF	; 255
    5b9c:	7f ef       	ldi	r23, 0xFF	; 255
    5b9e:	02 c0       	rjmp	.+4      	; 0x5ba4 <vfprintf+0x16c>
    5ba0:	6a 2d       	mov	r22, r10
    5ba2:	70 e0       	ldi	r23, 0x00	; 0
    5ba4:	22 e0       	ldi	r18, 0x02	; 2
    5ba6:	30 e0       	ldi	r19, 0x00	; 0
    5ba8:	c2 0e       	add	r12, r18
    5baa:	d3 1e       	adc	r13, r19
    5bac:	c7 01       	movw	r24, r14
    5bae:	0e 94 1f 2f 	call	0x5e3e	; 0x5e3e <strnlen>
    5bb2:	5c 01       	movw	r10, r24
    5bb4:	1f 77       	andi	r17, 0x7F	; 127
    5bb6:	13 c0       	rjmp	.+38     	; 0x5bde <vfprintf+0x1a6>
    5bb8:	f6 01       	movw	r30, r12
    5bba:	e0 80       	ld	r14, Z
    5bbc:	f1 80       	ldd	r15, Z+1	; 0x01
    5bbe:	16 fd       	sbrc	r17, 6
    5bc0:	03 c0       	rjmp	.+6      	; 0x5bc8 <vfprintf+0x190>
    5bc2:	6f ef       	ldi	r22, 0xFF	; 255
    5bc4:	7f ef       	ldi	r23, 0xFF	; 255
    5bc6:	02 c0       	rjmp	.+4      	; 0x5bcc <vfprintf+0x194>
    5bc8:	6a 2d       	mov	r22, r10
    5bca:	70 e0       	ldi	r23, 0x00	; 0
    5bcc:	22 e0       	ldi	r18, 0x02	; 2
    5bce:	30 e0       	ldi	r19, 0x00	; 0
    5bd0:	c2 0e       	add	r12, r18
    5bd2:	d3 1e       	adc	r13, r19
    5bd4:	c7 01       	movw	r24, r14
    5bd6:	0e 94 14 2f 	call	0x5e28	; 0x5e28 <strnlen_P>
    5bda:	5c 01       	movw	r10, r24
    5bdc:	10 68       	ori	r17, 0x80	; 128
    5bde:	13 ff       	sbrs	r17, 3
    5be0:	07 c0       	rjmp	.+14     	; 0x5bf0 <vfprintf+0x1b8>
    5be2:	1b c0       	rjmp	.+54     	; 0x5c1a <vfprintf+0x1e2>
    5be4:	b3 01       	movw	r22, r6
    5be6:	80 e2       	ldi	r24, 0x20	; 32
    5be8:	90 e0       	ldi	r25, 0x00	; 0
    5bea:	0e 94 3a 2f 	call	0x5e74	; 0x5e74 <fputc>
    5bee:	5a 94       	dec	r5
    5bf0:	85 2d       	mov	r24, r5
    5bf2:	90 e0       	ldi	r25, 0x00	; 0
    5bf4:	a8 16       	cp	r10, r24
    5bf6:	b9 06       	cpc	r11, r25
    5bf8:	a8 f3       	brcs	.-22     	; 0x5be4 <vfprintf+0x1ac>
    5bfa:	0f c0       	rjmp	.+30     	; 0x5c1a <vfprintf+0x1e2>
    5bfc:	f7 01       	movw	r30, r14
    5bfe:	17 fd       	sbrc	r17, 7
    5c00:	85 91       	lpm	r24, Z+
    5c02:	17 ff       	sbrs	r17, 7
    5c04:	81 91       	ld	r24, Z+
    5c06:	7f 01       	movw	r14, r30
    5c08:	b3 01       	movw	r22, r6
    5c0a:	90 e0       	ldi	r25, 0x00	; 0
    5c0c:	0e 94 3a 2f 	call	0x5e74	; 0x5e74 <fputc>
    5c10:	51 10       	cpse	r5, r1
    5c12:	5a 94       	dec	r5
    5c14:	08 94       	sec
    5c16:	a1 08       	sbc	r10, r1
    5c18:	b1 08       	sbc	r11, r1
    5c1a:	a1 14       	cp	r10, r1
    5c1c:	b1 04       	cpc	r11, r1
    5c1e:	71 f7       	brne	.-36     	; 0x5bfc <vfprintf+0x1c4>
    5c20:	e5 c0       	rjmp	.+458    	; 0x5dec <vfprintf+0x3b4>
    5c22:	94 36       	cpi	r25, 0x64	; 100
    5c24:	11 f0       	breq	.+4      	; 0x5c2a <vfprintf+0x1f2>
    5c26:	99 36       	cpi	r25, 0x69	; 105
    5c28:	69 f5       	brne	.+90     	; 0x5c84 <vfprintf+0x24c>
    5c2a:	17 ff       	sbrs	r17, 7
    5c2c:	0a c0       	rjmp	.+20     	; 0x5c42 <vfprintf+0x20a>
    5c2e:	f6 01       	movw	r30, r12
    5c30:	60 81       	ld	r22, Z
    5c32:	71 81       	ldd	r23, Z+1	; 0x01
    5c34:	82 81       	ldd	r24, Z+2	; 0x02
    5c36:	93 81       	ldd	r25, Z+3	; 0x03
    5c38:	24 e0       	ldi	r18, 0x04	; 4
    5c3a:	30 e0       	ldi	r19, 0x00	; 0
    5c3c:	c2 0e       	add	r12, r18
    5c3e:	d3 1e       	adc	r13, r19
    5c40:	0d c0       	rjmp	.+26     	; 0x5c5c <vfprintf+0x224>
    5c42:	f6 01       	movw	r30, r12
    5c44:	80 81       	ld	r24, Z
    5c46:	91 81       	ldd	r25, Z+1	; 0x01
    5c48:	9c 01       	movw	r18, r24
    5c4a:	b9 01       	movw	r22, r18
    5c4c:	88 27       	eor	r24, r24
    5c4e:	77 fd       	sbrc	r23, 7
    5c50:	80 95       	com	r24
    5c52:	98 2f       	mov	r25, r24
    5c54:	42 e0       	ldi	r20, 0x02	; 2
    5c56:	50 e0       	ldi	r21, 0x00	; 0
    5c58:	c4 0e       	add	r12, r20
    5c5a:	d5 1e       	adc	r13, r21
    5c5c:	01 2f       	mov	r16, r17
    5c5e:	0f 76       	andi	r16, 0x6F	; 111
    5c60:	97 ff       	sbrs	r25, 7
    5c62:	08 c0       	rjmp	.+16     	; 0x5c74 <vfprintf+0x23c>
    5c64:	90 95       	com	r25
    5c66:	80 95       	com	r24
    5c68:	70 95       	com	r23
    5c6a:	61 95       	neg	r22
    5c6c:	7f 4f       	sbci	r23, 0xFF	; 255
    5c6e:	8f 4f       	sbci	r24, 0xFF	; 255
    5c70:	9f 4f       	sbci	r25, 0xFF	; 255
    5c72:	00 68       	ori	r16, 0x80	; 128
    5c74:	2a e0       	ldi	r18, 0x0A	; 10
    5c76:	30 e0       	ldi	r19, 0x00	; 0
    5c78:	a1 01       	movw	r20, r2
    5c7a:	0e 94 66 2f 	call	0x5ecc	; 0x5ecc <__ultoa_invert>
    5c7e:	b8 2e       	mov	r11, r24
    5c80:	b2 18       	sub	r11, r2
    5c82:	3d c0       	rjmp	.+122    	; 0x5cfe <vfprintf+0x2c6>
    5c84:	95 37       	cpi	r25, 0x75	; 117
    5c86:	21 f4       	brne	.+8      	; 0x5c90 <vfprintf+0x258>
    5c88:	1f 7e       	andi	r17, 0xEF	; 239
    5c8a:	2a e0       	ldi	r18, 0x0A	; 10
    5c8c:	30 e0       	ldi	r19, 0x00	; 0
    5c8e:	1c c0       	rjmp	.+56     	; 0x5cc8 <vfprintf+0x290>
    5c90:	19 7f       	andi	r17, 0xF9	; 249
    5c92:	9f 36       	cpi	r25, 0x6F	; 111
    5c94:	61 f0       	breq	.+24     	; 0x5cae <vfprintf+0x276>
    5c96:	90 37       	cpi	r25, 0x70	; 112
    5c98:	20 f4       	brcc	.+8      	; 0x5ca2 <vfprintf+0x26a>
    5c9a:	98 35       	cpi	r25, 0x58	; 88
    5c9c:	09 f0       	breq	.+2      	; 0x5ca0 <vfprintf+0x268>
    5c9e:	a9 c0       	rjmp	.+338    	; 0x5df2 <vfprintf+0x3ba>
    5ca0:	0f c0       	rjmp	.+30     	; 0x5cc0 <vfprintf+0x288>
    5ca2:	90 37       	cpi	r25, 0x70	; 112
    5ca4:	39 f0       	breq	.+14     	; 0x5cb4 <vfprintf+0x27c>
    5ca6:	98 37       	cpi	r25, 0x78	; 120
    5ca8:	09 f0       	breq	.+2      	; 0x5cac <vfprintf+0x274>
    5caa:	a3 c0       	rjmp	.+326    	; 0x5df2 <vfprintf+0x3ba>
    5cac:	04 c0       	rjmp	.+8      	; 0x5cb6 <vfprintf+0x27e>
    5cae:	28 e0       	ldi	r18, 0x08	; 8
    5cb0:	30 e0       	ldi	r19, 0x00	; 0
    5cb2:	0a c0       	rjmp	.+20     	; 0x5cc8 <vfprintf+0x290>
    5cb4:	10 61       	ori	r17, 0x10	; 16
    5cb6:	14 fd       	sbrc	r17, 4
    5cb8:	14 60       	ori	r17, 0x04	; 4
    5cba:	20 e1       	ldi	r18, 0x10	; 16
    5cbc:	30 e0       	ldi	r19, 0x00	; 0
    5cbe:	04 c0       	rjmp	.+8      	; 0x5cc8 <vfprintf+0x290>
    5cc0:	14 fd       	sbrc	r17, 4
    5cc2:	16 60       	ori	r17, 0x06	; 6
    5cc4:	20 e1       	ldi	r18, 0x10	; 16
    5cc6:	32 e0       	ldi	r19, 0x02	; 2
    5cc8:	17 ff       	sbrs	r17, 7
    5cca:	08 c0       	rjmp	.+16     	; 0x5cdc <vfprintf+0x2a4>
    5ccc:	f6 01       	movw	r30, r12
    5cce:	60 81       	ld	r22, Z
    5cd0:	71 81       	ldd	r23, Z+1	; 0x01
    5cd2:	82 81       	ldd	r24, Z+2	; 0x02
    5cd4:	93 81       	ldd	r25, Z+3	; 0x03
    5cd6:	44 e0       	ldi	r20, 0x04	; 4
    5cd8:	50 e0       	ldi	r21, 0x00	; 0
    5cda:	08 c0       	rjmp	.+16     	; 0x5cec <vfprintf+0x2b4>
    5cdc:	f6 01       	movw	r30, r12
    5cde:	80 81       	ld	r24, Z
    5ce0:	91 81       	ldd	r25, Z+1	; 0x01
    5ce2:	bc 01       	movw	r22, r24
    5ce4:	80 e0       	ldi	r24, 0x00	; 0
    5ce6:	90 e0       	ldi	r25, 0x00	; 0
    5ce8:	42 e0       	ldi	r20, 0x02	; 2
    5cea:	50 e0       	ldi	r21, 0x00	; 0
    5cec:	c4 0e       	add	r12, r20
    5cee:	d5 1e       	adc	r13, r21
    5cf0:	a1 01       	movw	r20, r2
    5cf2:	0e 94 66 2f 	call	0x5ecc	; 0x5ecc <__ultoa_invert>
    5cf6:	b8 2e       	mov	r11, r24
    5cf8:	b2 18       	sub	r11, r2
    5cfa:	01 2f       	mov	r16, r17
    5cfc:	0f 77       	andi	r16, 0x7F	; 127
    5cfe:	06 ff       	sbrs	r16, 6
    5d00:	09 c0       	rjmp	.+18     	; 0x5d14 <vfprintf+0x2dc>
    5d02:	0e 7f       	andi	r16, 0xFE	; 254
    5d04:	ba 14       	cp	r11, r10
    5d06:	30 f4       	brcc	.+12     	; 0x5d14 <vfprintf+0x2dc>
    5d08:	04 ff       	sbrs	r16, 4
    5d0a:	06 c0       	rjmp	.+12     	; 0x5d18 <vfprintf+0x2e0>
    5d0c:	02 fd       	sbrc	r16, 2
    5d0e:	04 c0       	rjmp	.+8      	; 0x5d18 <vfprintf+0x2e0>
    5d10:	0f 7e       	andi	r16, 0xEF	; 239
    5d12:	02 c0       	rjmp	.+4      	; 0x5d18 <vfprintf+0x2e0>
    5d14:	1b 2d       	mov	r17, r11
    5d16:	01 c0       	rjmp	.+2      	; 0x5d1a <vfprintf+0x2e2>
    5d18:	1a 2d       	mov	r17, r10
    5d1a:	04 ff       	sbrs	r16, 4
    5d1c:	0c c0       	rjmp	.+24     	; 0x5d36 <vfprintf+0x2fe>
    5d1e:	fe 01       	movw	r30, r28
    5d20:	eb 0d       	add	r30, r11
    5d22:	f1 1d       	adc	r31, r1
    5d24:	80 81       	ld	r24, Z
    5d26:	80 33       	cpi	r24, 0x30	; 48
    5d28:	11 f4       	brne	.+4      	; 0x5d2e <vfprintf+0x2f6>
    5d2a:	09 7e       	andi	r16, 0xE9	; 233
    5d2c:	08 c0       	rjmp	.+16     	; 0x5d3e <vfprintf+0x306>
    5d2e:	1f 5f       	subi	r17, 0xFF	; 255
    5d30:	02 ff       	sbrs	r16, 2
    5d32:	05 c0       	rjmp	.+10     	; 0x5d3e <vfprintf+0x306>
    5d34:	03 c0       	rjmp	.+6      	; 0x5d3c <vfprintf+0x304>
    5d36:	80 2f       	mov	r24, r16
    5d38:	86 78       	andi	r24, 0x86	; 134
    5d3a:	09 f0       	breq	.+2      	; 0x5d3e <vfprintf+0x306>
    5d3c:	1f 5f       	subi	r17, 0xFF	; 255
    5d3e:	e0 2e       	mov	r14, r16
    5d40:	03 fd       	sbrc	r16, 3
    5d42:	14 c0       	rjmp	.+40     	; 0x5d6c <vfprintf+0x334>
    5d44:	00 ff       	sbrs	r16, 0
    5d46:	0f c0       	rjmp	.+30     	; 0x5d66 <vfprintf+0x32e>
    5d48:	15 15       	cp	r17, r5
    5d4a:	10 f0       	brcs	.+4      	; 0x5d50 <vfprintf+0x318>
    5d4c:	ab 2c       	mov	r10, r11
    5d4e:	0b c0       	rjmp	.+22     	; 0x5d66 <vfprintf+0x32e>
    5d50:	ab 2c       	mov	r10, r11
    5d52:	a5 0c       	add	r10, r5
    5d54:	a1 1a       	sub	r10, r17
    5d56:	15 2d       	mov	r17, r5
    5d58:	06 c0       	rjmp	.+12     	; 0x5d66 <vfprintf+0x32e>
    5d5a:	b3 01       	movw	r22, r6
    5d5c:	80 e2       	ldi	r24, 0x20	; 32
    5d5e:	90 e0       	ldi	r25, 0x00	; 0
    5d60:	0e 94 3a 2f 	call	0x5e74	; 0x5e74 <fputc>
    5d64:	1f 5f       	subi	r17, 0xFF	; 255
    5d66:	15 15       	cp	r17, r5
    5d68:	c0 f3       	brcs	.-16     	; 0x5d5a <vfprintf+0x322>
    5d6a:	04 c0       	rjmp	.+8      	; 0x5d74 <vfprintf+0x33c>
    5d6c:	15 15       	cp	r17, r5
    5d6e:	10 f4       	brcc	.+4      	; 0x5d74 <vfprintf+0x33c>
    5d70:	51 1a       	sub	r5, r17
    5d72:	01 c0       	rjmp	.+2      	; 0x5d76 <vfprintf+0x33e>
    5d74:	55 24       	eor	r5, r5
    5d76:	e4 fe       	sbrs	r14, 4
    5d78:	10 c0       	rjmp	.+32     	; 0x5d9a <vfprintf+0x362>
    5d7a:	b3 01       	movw	r22, r6
    5d7c:	80 e3       	ldi	r24, 0x30	; 48
    5d7e:	90 e0       	ldi	r25, 0x00	; 0
    5d80:	0e 94 3a 2f 	call	0x5e74	; 0x5e74 <fputc>
    5d84:	e2 fe       	sbrs	r14, 2
    5d86:	1e c0       	rjmp	.+60     	; 0x5dc4 <vfprintf+0x38c>
    5d88:	e1 fe       	sbrs	r14, 1
    5d8a:	03 c0       	rjmp	.+6      	; 0x5d92 <vfprintf+0x35a>
    5d8c:	88 e5       	ldi	r24, 0x58	; 88
    5d8e:	90 e0       	ldi	r25, 0x00	; 0
    5d90:	02 c0       	rjmp	.+4      	; 0x5d96 <vfprintf+0x35e>
    5d92:	88 e7       	ldi	r24, 0x78	; 120
    5d94:	90 e0       	ldi	r25, 0x00	; 0
    5d96:	b3 01       	movw	r22, r6
    5d98:	0c c0       	rjmp	.+24     	; 0x5db2 <vfprintf+0x37a>
    5d9a:	8e 2d       	mov	r24, r14
    5d9c:	86 78       	andi	r24, 0x86	; 134
    5d9e:	91 f0       	breq	.+36     	; 0x5dc4 <vfprintf+0x38c>
    5da0:	e1 fe       	sbrs	r14, 1
    5da2:	02 c0       	rjmp	.+4      	; 0x5da8 <vfprintf+0x370>
    5da4:	8b e2       	ldi	r24, 0x2B	; 43
    5da6:	01 c0       	rjmp	.+2      	; 0x5daa <vfprintf+0x372>
    5da8:	80 e2       	ldi	r24, 0x20	; 32
    5daa:	07 fd       	sbrc	r16, 7
    5dac:	8d e2       	ldi	r24, 0x2D	; 45
    5dae:	b3 01       	movw	r22, r6
    5db0:	90 e0       	ldi	r25, 0x00	; 0
    5db2:	0e 94 3a 2f 	call	0x5e74	; 0x5e74 <fputc>
    5db6:	06 c0       	rjmp	.+12     	; 0x5dc4 <vfprintf+0x38c>
    5db8:	b3 01       	movw	r22, r6
    5dba:	80 e3       	ldi	r24, 0x30	; 48
    5dbc:	90 e0       	ldi	r25, 0x00	; 0
    5dbe:	0e 94 3a 2f 	call	0x5e74	; 0x5e74 <fputc>
    5dc2:	aa 94       	dec	r10
    5dc4:	ba 14       	cp	r11, r10
    5dc6:	c0 f3       	brcs	.-16     	; 0x5db8 <vfprintf+0x380>
    5dc8:	ba 94       	dec	r11
    5dca:	f1 01       	movw	r30, r2
    5dcc:	eb 0d       	add	r30, r11
    5dce:	f1 1d       	adc	r31, r1
    5dd0:	80 81       	ld	r24, Z
    5dd2:	b3 01       	movw	r22, r6
    5dd4:	90 e0       	ldi	r25, 0x00	; 0
    5dd6:	0e 94 3a 2f 	call	0x5e74	; 0x5e74 <fputc>
    5dda:	bb 20       	and	r11, r11
    5ddc:	39 f0       	breq	.+14     	; 0x5dec <vfprintf+0x3b4>
    5dde:	f4 cf       	rjmp	.-24     	; 0x5dc8 <vfprintf+0x390>
    5de0:	b3 01       	movw	r22, r6
    5de2:	80 e2       	ldi	r24, 0x20	; 32
    5de4:	90 e0       	ldi	r25, 0x00	; 0
    5de6:	0e 94 3a 2f 	call	0x5e74	; 0x5e74 <fputc>
    5dea:	5a 94       	dec	r5
    5dec:	55 20       	and	r5, r5
    5dee:	c1 f7       	brne	.-16     	; 0x5de0 <vfprintf+0x3a8>
    5df0:	4c ce       	rjmp	.-872    	; 0x5a8a <vfprintf+0x52>
    5df2:	f3 01       	movw	r30, r6
    5df4:	86 81       	ldd	r24, Z+6	; 0x06
    5df6:	97 81       	ldd	r25, Z+7	; 0x07
    5df8:	2b 96       	adiw	r28, 0x0b	; 11
    5dfa:	0f b6       	in	r0, 0x3f	; 63
    5dfc:	f8 94       	cli
    5dfe:	de bf       	out	0x3e, r29	; 62
    5e00:	0f be       	out	0x3f, r0	; 63
    5e02:	cd bf       	out	0x3d, r28	; 61
    5e04:	df 91       	pop	r29
    5e06:	cf 91       	pop	r28
    5e08:	1f 91       	pop	r17
    5e0a:	0f 91       	pop	r16
    5e0c:	ff 90       	pop	r15
    5e0e:	ef 90       	pop	r14
    5e10:	df 90       	pop	r13
    5e12:	cf 90       	pop	r12
    5e14:	bf 90       	pop	r11
    5e16:	af 90       	pop	r10
    5e18:	9f 90       	pop	r9
    5e1a:	8f 90       	pop	r8
    5e1c:	7f 90       	pop	r7
    5e1e:	6f 90       	pop	r6
    5e20:	5f 90       	pop	r5
    5e22:	3f 90       	pop	r3
    5e24:	2f 90       	pop	r2
    5e26:	08 95       	ret

00005e28 <strnlen_P>:
    5e28:	fc 01       	movw	r30, r24
    5e2a:	05 90       	lpm	r0, Z+
    5e2c:	61 50       	subi	r22, 0x01	; 1
    5e2e:	70 40       	sbci	r23, 0x00	; 0
    5e30:	01 10       	cpse	r0, r1
    5e32:	d8 f7       	brcc	.-10     	; 0x5e2a <strnlen_P+0x2>
    5e34:	80 95       	com	r24
    5e36:	90 95       	com	r25
    5e38:	8e 0f       	add	r24, r30
    5e3a:	9f 1f       	adc	r25, r31
    5e3c:	08 95       	ret

00005e3e <strnlen>:
    5e3e:	fc 01       	movw	r30, r24
    5e40:	61 50       	subi	r22, 0x01	; 1
    5e42:	70 40       	sbci	r23, 0x00	; 0
    5e44:	01 90       	ld	r0, Z+
    5e46:	01 10       	cpse	r0, r1
    5e48:	d8 f7       	brcc	.-10     	; 0x5e40 <strnlen+0x2>
    5e4a:	80 95       	com	r24
    5e4c:	90 95       	com	r25
    5e4e:	8e 0f       	add	r24, r30
    5e50:	9f 1f       	adc	r25, r31
    5e52:	08 95       	ret

00005e54 <strrev>:
    5e54:	dc 01       	movw	r26, r24
    5e56:	fc 01       	movw	r30, r24
    5e58:	67 2f       	mov	r22, r23
    5e5a:	71 91       	ld	r23, Z+
    5e5c:	77 23       	and	r23, r23
    5e5e:	e1 f7       	brne	.-8      	; 0x5e58 <strrev+0x4>
    5e60:	32 97       	sbiw	r30, 0x02	; 2
    5e62:	04 c0       	rjmp	.+8      	; 0x5e6c <strrev+0x18>
    5e64:	7c 91       	ld	r23, X
    5e66:	6d 93       	st	X+, r22
    5e68:	70 83       	st	Z, r23
    5e6a:	62 91       	ld	r22, -Z
    5e6c:	ae 17       	cp	r26, r30
    5e6e:	bf 07       	cpc	r27, r31
    5e70:	c8 f3       	brcs	.-14     	; 0x5e64 <strrev+0x10>
    5e72:	08 95       	ret

00005e74 <fputc>:
    5e74:	0f 93       	push	r16
    5e76:	1f 93       	push	r17
    5e78:	cf 93       	push	r28
    5e7a:	df 93       	push	r29
    5e7c:	8c 01       	movw	r16, r24
    5e7e:	eb 01       	movw	r28, r22
    5e80:	8b 81       	ldd	r24, Y+3	; 0x03
    5e82:	81 ff       	sbrs	r24, 1
    5e84:	1b c0       	rjmp	.+54     	; 0x5ebc <fputc+0x48>
    5e86:	82 ff       	sbrs	r24, 2
    5e88:	0d c0       	rjmp	.+26     	; 0x5ea4 <fputc+0x30>
    5e8a:	2e 81       	ldd	r18, Y+6	; 0x06
    5e8c:	3f 81       	ldd	r19, Y+7	; 0x07
    5e8e:	8c 81       	ldd	r24, Y+4	; 0x04
    5e90:	9d 81       	ldd	r25, Y+5	; 0x05
    5e92:	28 17       	cp	r18, r24
    5e94:	39 07       	cpc	r19, r25
    5e96:	64 f4       	brge	.+24     	; 0x5eb0 <fputc+0x3c>
    5e98:	e8 81       	ld	r30, Y
    5e9a:	f9 81       	ldd	r31, Y+1	; 0x01
    5e9c:	01 93       	st	Z+, r16
    5e9e:	f9 83       	std	Y+1, r31	; 0x01
    5ea0:	e8 83       	st	Y, r30
    5ea2:	06 c0       	rjmp	.+12     	; 0x5eb0 <fputc+0x3c>
    5ea4:	e8 85       	ldd	r30, Y+8	; 0x08
    5ea6:	f9 85       	ldd	r31, Y+9	; 0x09
    5ea8:	80 2f       	mov	r24, r16
    5eaa:	09 95       	icall
    5eac:	89 2b       	or	r24, r25
    5eae:	31 f4       	brne	.+12     	; 0x5ebc <fputc+0x48>
    5eb0:	8e 81       	ldd	r24, Y+6	; 0x06
    5eb2:	9f 81       	ldd	r25, Y+7	; 0x07
    5eb4:	01 96       	adiw	r24, 0x01	; 1
    5eb6:	9f 83       	std	Y+7, r25	; 0x07
    5eb8:	8e 83       	std	Y+6, r24	; 0x06
    5eba:	02 c0       	rjmp	.+4      	; 0x5ec0 <fputc+0x4c>
    5ebc:	0f ef       	ldi	r16, 0xFF	; 255
    5ebe:	1f ef       	ldi	r17, 0xFF	; 255
    5ec0:	c8 01       	movw	r24, r16
    5ec2:	df 91       	pop	r29
    5ec4:	cf 91       	pop	r28
    5ec6:	1f 91       	pop	r17
    5ec8:	0f 91       	pop	r16
    5eca:	08 95       	ret

00005ecc <__ultoa_invert>:
    5ecc:	fa 01       	movw	r30, r20
    5ece:	aa 27       	eor	r26, r26
    5ed0:	28 30       	cpi	r18, 0x08	; 8
    5ed2:	51 f1       	breq	.+84     	; 0x5f28 <__ultoa_invert+0x5c>
    5ed4:	20 31       	cpi	r18, 0x10	; 16
    5ed6:	81 f1       	breq	.+96     	; 0x5f38 <__ultoa_invert+0x6c>
    5ed8:	e8 94       	clt
    5eda:	6f 93       	push	r22
    5edc:	6e 7f       	andi	r22, 0xFE	; 254
    5ede:	6e 5f       	subi	r22, 0xFE	; 254
    5ee0:	7f 4f       	sbci	r23, 0xFF	; 255
    5ee2:	8f 4f       	sbci	r24, 0xFF	; 255
    5ee4:	9f 4f       	sbci	r25, 0xFF	; 255
    5ee6:	af 4f       	sbci	r26, 0xFF	; 255
    5ee8:	b1 e0       	ldi	r27, 0x01	; 1
    5eea:	3e d0       	rcall	.+124    	; 0x5f68 <__ultoa_invert+0x9c>
    5eec:	b4 e0       	ldi	r27, 0x04	; 4
    5eee:	3c d0       	rcall	.+120    	; 0x5f68 <__ultoa_invert+0x9c>
    5ef0:	67 0f       	add	r22, r23
    5ef2:	78 1f       	adc	r23, r24
    5ef4:	89 1f       	adc	r24, r25
    5ef6:	9a 1f       	adc	r25, r26
    5ef8:	a1 1d       	adc	r26, r1
    5efa:	68 0f       	add	r22, r24
    5efc:	79 1f       	adc	r23, r25
    5efe:	8a 1f       	adc	r24, r26
    5f00:	91 1d       	adc	r25, r1
    5f02:	a1 1d       	adc	r26, r1
    5f04:	6a 0f       	add	r22, r26
    5f06:	71 1d       	adc	r23, r1
    5f08:	81 1d       	adc	r24, r1
    5f0a:	91 1d       	adc	r25, r1
    5f0c:	a1 1d       	adc	r26, r1
    5f0e:	20 d0       	rcall	.+64     	; 0x5f50 <__ultoa_invert+0x84>
    5f10:	09 f4       	brne	.+2      	; 0x5f14 <__ultoa_invert+0x48>
    5f12:	68 94       	set
    5f14:	3f 91       	pop	r19
    5f16:	2a e0       	ldi	r18, 0x0A	; 10
    5f18:	26 9f       	mul	r18, r22
    5f1a:	11 24       	eor	r1, r1
    5f1c:	30 19       	sub	r19, r0
    5f1e:	30 5d       	subi	r19, 0xD0	; 208
    5f20:	31 93       	st	Z+, r19
    5f22:	de f6       	brtc	.-74     	; 0x5eda <__ultoa_invert+0xe>
    5f24:	cf 01       	movw	r24, r30
    5f26:	08 95       	ret
    5f28:	46 2f       	mov	r20, r22
    5f2a:	47 70       	andi	r20, 0x07	; 7
    5f2c:	40 5d       	subi	r20, 0xD0	; 208
    5f2e:	41 93       	st	Z+, r20
    5f30:	b3 e0       	ldi	r27, 0x03	; 3
    5f32:	0f d0       	rcall	.+30     	; 0x5f52 <__ultoa_invert+0x86>
    5f34:	c9 f7       	brne	.-14     	; 0x5f28 <__ultoa_invert+0x5c>
    5f36:	f6 cf       	rjmp	.-20     	; 0x5f24 <__ultoa_invert+0x58>
    5f38:	46 2f       	mov	r20, r22
    5f3a:	4f 70       	andi	r20, 0x0F	; 15
    5f3c:	40 5d       	subi	r20, 0xD0	; 208
    5f3e:	4a 33       	cpi	r20, 0x3A	; 58
    5f40:	18 f0       	brcs	.+6      	; 0x5f48 <__ultoa_invert+0x7c>
    5f42:	49 5d       	subi	r20, 0xD9	; 217
    5f44:	31 fd       	sbrc	r19, 1
    5f46:	40 52       	subi	r20, 0x20	; 32
    5f48:	41 93       	st	Z+, r20
    5f4a:	02 d0       	rcall	.+4      	; 0x5f50 <__ultoa_invert+0x84>
    5f4c:	a9 f7       	brne	.-22     	; 0x5f38 <__ultoa_invert+0x6c>
    5f4e:	ea cf       	rjmp	.-44     	; 0x5f24 <__ultoa_invert+0x58>
    5f50:	b4 e0       	ldi	r27, 0x04	; 4
    5f52:	a6 95       	lsr	r26
    5f54:	97 95       	ror	r25
    5f56:	87 95       	ror	r24
    5f58:	77 95       	ror	r23
    5f5a:	67 95       	ror	r22
    5f5c:	ba 95       	dec	r27
    5f5e:	c9 f7       	brne	.-14     	; 0x5f52 <__ultoa_invert+0x86>
    5f60:	00 97       	sbiw	r24, 0x00	; 0
    5f62:	61 05       	cpc	r22, r1
    5f64:	71 05       	cpc	r23, r1
    5f66:	08 95       	ret
    5f68:	9b 01       	movw	r18, r22
    5f6a:	ac 01       	movw	r20, r24
    5f6c:	0a 2e       	mov	r0, r26
    5f6e:	06 94       	lsr	r0
    5f70:	57 95       	ror	r21
    5f72:	47 95       	ror	r20
    5f74:	37 95       	ror	r19
    5f76:	27 95       	ror	r18
    5f78:	ba 95       	dec	r27
    5f7a:	c9 f7       	brne	.-14     	; 0x5f6e <__ultoa_invert+0xa2>
    5f7c:	62 0f       	add	r22, r18
    5f7e:	73 1f       	adc	r23, r19
    5f80:	84 1f       	adc	r24, r20
    5f82:	95 1f       	adc	r25, r21
    5f84:	a0 1d       	adc	r26, r0
    5f86:	08 95       	ret

00005f88 <__udivmodhi4>:
    5f88:	aa 1b       	sub	r26, r26
    5f8a:	bb 1b       	sub	r27, r27
    5f8c:	51 e1       	ldi	r21, 0x11	; 17
    5f8e:	07 c0       	rjmp	.+14     	; 0x5f9e <__udivmodhi4_ep>

00005f90 <__udivmodhi4_loop>:
    5f90:	aa 1f       	adc	r26, r26
    5f92:	bb 1f       	adc	r27, r27
    5f94:	a6 17       	cp	r26, r22
    5f96:	b7 07       	cpc	r27, r23
    5f98:	10 f0       	brcs	.+4      	; 0x5f9e <__udivmodhi4_ep>
    5f9a:	a6 1b       	sub	r26, r22
    5f9c:	b7 0b       	sbc	r27, r23

00005f9e <__udivmodhi4_ep>:
    5f9e:	88 1f       	adc	r24, r24
    5fa0:	99 1f       	adc	r25, r25
    5fa2:	5a 95       	dec	r21
    5fa4:	a9 f7       	brne	.-22     	; 0x5f90 <__udivmodhi4_loop>
    5fa6:	80 95       	com	r24
    5fa8:	90 95       	com	r25
    5faa:	bc 01       	movw	r22, r24
    5fac:	cd 01       	movw	r24, r26
    5fae:	08 95       	ret

00005fb0 <__prologue_saves__>:
    5fb0:	2f 92       	push	r2
    5fb2:	3f 92       	push	r3
    5fb4:	4f 92       	push	r4
    5fb6:	5f 92       	push	r5
    5fb8:	6f 92       	push	r6
    5fba:	7f 92       	push	r7
    5fbc:	8f 92       	push	r8
    5fbe:	9f 92       	push	r9
    5fc0:	af 92       	push	r10
    5fc2:	bf 92       	push	r11
    5fc4:	cf 92       	push	r12
    5fc6:	df 92       	push	r13
    5fc8:	ef 92       	push	r14
    5fca:	ff 92       	push	r15
    5fcc:	0f 93       	push	r16
    5fce:	1f 93       	push	r17
    5fd0:	cf 93       	push	r28
    5fd2:	df 93       	push	r29
    5fd4:	cd b7       	in	r28, 0x3d	; 61
    5fd6:	de b7       	in	r29, 0x3e	; 62
    5fd8:	ca 1b       	sub	r28, r26
    5fda:	db 0b       	sbc	r29, r27
    5fdc:	0f b6       	in	r0, 0x3f	; 63
    5fde:	f8 94       	cli
    5fe0:	de bf       	out	0x3e, r29	; 62
    5fe2:	0f be       	out	0x3f, r0	; 63
    5fe4:	cd bf       	out	0x3d, r28	; 61
    5fe6:	09 94       	ijmp

00005fe8 <__epilogue_restores__>:
    5fe8:	2a 88       	ldd	r2, Y+18	; 0x12
    5fea:	39 88       	ldd	r3, Y+17	; 0x11
    5fec:	48 88       	ldd	r4, Y+16	; 0x10
    5fee:	5f 84       	ldd	r5, Y+15	; 0x0f
    5ff0:	6e 84       	ldd	r6, Y+14	; 0x0e
    5ff2:	7d 84       	ldd	r7, Y+13	; 0x0d
    5ff4:	8c 84       	ldd	r8, Y+12	; 0x0c
    5ff6:	9b 84       	ldd	r9, Y+11	; 0x0b
    5ff8:	aa 84       	ldd	r10, Y+10	; 0x0a
    5ffa:	b9 84       	ldd	r11, Y+9	; 0x09
    5ffc:	c8 84       	ldd	r12, Y+8	; 0x08
    5ffe:	df 80       	ldd	r13, Y+7	; 0x07
    6000:	ee 80       	ldd	r14, Y+6	; 0x06
    6002:	fd 80       	ldd	r15, Y+5	; 0x05
    6004:	0c 81       	ldd	r16, Y+4	; 0x04
    6006:	1b 81       	ldd	r17, Y+3	; 0x03
    6008:	aa 81       	ldd	r26, Y+2	; 0x02
    600a:	b9 81       	ldd	r27, Y+1	; 0x01
    600c:	ce 0f       	add	r28, r30
    600e:	d1 1d       	adc	r29, r1
    6010:	0f b6       	in	r0, 0x3f	; 63
    6012:	f8 94       	cli
    6014:	de bf       	out	0x3e, r29	; 62
    6016:	0f be       	out	0x3f, r0	; 63
    6018:	cd bf       	out	0x3d, r28	; 61
    601a:	ed 01       	movw	r28, r26
    601c:	08 95       	ret

0000601e <_exit>:
    601e:	ff cf       	rjmp	.-2      	; 0x601e <_exit>
